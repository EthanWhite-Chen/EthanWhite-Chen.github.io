<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ethanwhite-chen.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言Spring的循环依赖，也就是两个bean之间产生了互相依赖，那么引出的问题就是如何顺利的将两个bean创建出来并注册到容器中。更有甚者，产生了循环依赖的bean还需要生成动态代理对象，这种情况则比普通的循环依赖更为复杂。 本篇文章将对Spring中的循环依赖进行详细分析，结合示例工程，流程图示和源码，力求一文阐释清楚Spring中的循环依赖问题以及如何解决，并会在最后给出Spring中的三个">
<meta property="og:type" content="article">
<meta property="og:title" content="一文彻底明白Spring的循环依赖">
<meta property="og:url" content="https://ethanwhite-chen.github.io/2023/05/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/index.html">
<meta property="og:site_name" content="ykchen的个人博客">
<meta property="og:description" content="前言Spring的循环依赖，也就是两个bean之间产生了互相依赖，那么引出的问题就是如何顺利的将两个bean创建出来并注册到容器中。更有甚者，产生了循环依赖的bean还需要生成动态代理对象，这种情况则比普通的循环依赖更为复杂。 本篇文章将对Spring中的循环依赖进行详细分析，结合示例工程，流程图示和源码，力求一文阐释清楚Spring中的循环依赖问题以及如何解决，并会在最后给出Spring中的三个">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847dddf8699b423eba9cc3841135bb24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="article:published_time" content="2023-05-23T15:05:07.000Z">
<meta property="article:modified_time" content="2023-05-23T15:18:21.140Z">
<meta property="article:author" content="EthanWhite-Chen">
<meta property="article:tag" content="java">
<meta property="article:tag" content="aop">
<meta property="article:tag" content="ioc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847dddf8699b423eba9cc3841135bb24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

<link rel="canonical" href="https://ethanwhite-chen.github.io/2023/05/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>一文彻底明白Spring的循环依赖 | ykchen的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ykchen的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到ykchen的技术总结分享博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ethanwhite-chen" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          一文彻底明白Spring的循环依赖
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-23 23:05:07 / Modified: 23:18:21" itemprop="dateCreated datePublished" datetime="2023-05-23T23:05:07+08:00">2023-05-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>27 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Spring</strong>的循环依赖，也就是两个<strong>bean</strong>之间产生了互相依赖，那么引出的问题就是如何顺利的将两个<strong>bean</strong>创建出来并注册到容器中。更有甚者，产生了循环依赖的<strong>bean</strong>还需要生成动态代理对象，这种情况则比普通的循环依赖更为复杂。</p>
<p>本篇文章将对<strong>Spring</strong>中的循环依赖进行详细分析，结合<strong>示例工程</strong>，<strong>流程图示</strong>和<strong>源码</strong>，力求一文阐释清楚<strong>Spring</strong>中的循环依赖问题以及如何解决，并会在最后给出<strong>Spring</strong>中的三个缓存的具体作用。</p>
<p>在开始本文的分析前，有如下几点概念说明。</p>
<ol>
<li><strong>bean</strong>的实例化，就是将<strong>bean</strong>的对象<strong>new</strong>出来，称为<strong>bean</strong>的原始对象，原始对象没有完成属性注入，不能称为<strong>bean</strong>；</li>
<li><strong>bean</strong>的属性注入，就是为<strong>bean</strong>的原始对象注入其它<strong>bean</strong>即依赖注入，完成依赖注入的原始对象，此时可以作为<strong>bean</strong>放入容器；</li>
<li><strong>bean</strong>的初始化可以理解为：<strong>bean</strong>实例化 + <strong>bean</strong>属性注入。</li>
</ol>
<p><strong>Spring</strong>版本：<strong>5.3.2</strong></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一-循环依赖的产生"><a href="#一-循环依赖的产生" class="headerlink" title="一. 循环依赖的产生"></a>一. 循环依赖的产生</h3><p>如果有两个业务类实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceB myServiceB;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceA myServiceA;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么<strong>Spring</strong>在初始化<strong>MyServiceA</strong>的<strong>bean</strong>时候，会为<strong>MyServiceA</strong>的原始对象注入<strong>MyServiceB</strong>的<strong>bean</strong>，此时由于容器中没有<strong>MyServiceB</strong>的<strong>bean</strong>，所以<strong>Spring</strong>又会去初始化<strong>MyServiceB</strong>的<strong>bean</strong>，初始化<strong>MyServiceB</strong>的bean的时候，会为<strong>MyServiceB</strong>的原始对象注入<strong>MyServiceA</strong>的<strong>bean</strong>，此时就发生了循环依赖。</p>
<p>后续都将<strong>MyServiceA</strong>简称为<strong>A</strong>，将<strong>MyServiceB</strong>简称为<strong>B</strong>。</p>
<h3 id="二-循环依赖的解决"><a href="#二-循环依赖的解决" class="headerlink" title="二. 循环依赖的解决"></a>二. 循环依赖的解决</h3><p>如下是循环依赖中最复杂的一种情况，即两个需要生成动态代理的<strong>bean</strong>之间形成了循环依赖。</p>
<p>业务类如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceA</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String initMessage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceB myServiceB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyService A execute.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        initMessage = <span class="string">&quot;MyService A.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceB</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String initMessage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceA myServiceA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyService B execute.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        initMessage = <span class="string">&quot;MyService B.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在业务类中使用了@<strong>MyAnnotation</strong>注解来修饰方法，该注解是自定义注解，没有任何含义，仅为了帮助在<strong>SpringAOP</strong>中进行切点声明，@<strong>MyAnnotation</strong>注解定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切面如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.leanr.spring.ioc.mytest.MyAnnotation)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">allMethodPointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;allMethodPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeBeforeMethod</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyAspect execute.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.leanr.spring.ioc.mytest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>测试类如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span></span><br><span class="line">                <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么针对上面这种需要生成动态代理的<strong>bean</strong>之间存在循环依赖的情况，整个解决流程如下所示。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847dddf8699b423eba9cc3841135bb24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Spring-循环依赖示意图"></p>
<p>上述流程图中，出现了<strong>一级缓存</strong>，<strong>二级缓存</strong>和<strong>三级缓存</strong>，如果对这三个缓存没有概念，那么就暂时不要去深究，就当这三个缓存是三个<strong>Map</strong>，在下面的章节，会结合源码，具体分析其作用。</p>
<h3 id="三-源码分析"><a href="#三-源码分析" class="headerlink" title="三. 源码分析"></a>三. 源码分析</h3><p>在<strong>Spring</strong>中，如果基于<strong>XML</strong>配置<strong>bean</strong>，那么使用的容器为<strong>ClassPathXmlApplicationContext</strong>，如果是基于注解配置<strong>bean</strong>，则使用的容器为<strong>AnnotationConfigApplicationContext</strong>。以<strong>AnnotationConfigApplicationContext</strong>为例，其构造函数如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">// 初始化容器</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>AnnotationConfigApplicationContext</strong>的构造函数中会调用到<strong>AbstractApplicationContext</strong>的<strong>refresh()</strong> 方法，实际上无论是基于<strong>XML</strong>配置<strong>bean</strong>，还是基于注解配置<strong>bean</strong>，亦或者是<strong>Springboot</strong>中，在初始化容器时都会调用到<strong>AbstractApplicationContext</strong>的<strong>refresh()</strong> 方法中。下面看一下<strong>refresh()</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化所有非延时加载的单例bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关心<strong>refresh()</strong> 方法中调用的<strong>finishBeanFactoryInitialization()</strong> 方法，该方法会初始化所有非延时加载的单例<strong>bean</strong>，其实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有非延时加载的单例bean</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>finishBeanFactoryInitialization()</strong> 方法中会调用到<strong>DefaultListableBeanFactory</strong>的<strong>preInstantiateSingletons()</strong> 方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个循环中通过getBean()方法初始化bean</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是FactoryBean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不是FactoryBean，则通过getBean()方法来初始化bean</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这里需要注意，<strong>Spring</strong>中初始化<strong>bean</strong>，是通过调用容器的<strong>getBean()</strong> 方法来完成，在<strong>getBean()</strong> 方法中如果获取不到<strong>bean</strong>，此时就会初始化这个<strong>bean</strong>，<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法的实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">0public Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 有三种情况会调用到这里</span></span><br><span class="line">    <span class="comment">// 1. 容器启动的时候初始化A，所以调用到这里以进行A的初始化</span></span><br><span class="line">    <span class="comment">// 2. 初始化A的时候要属性注入B，所以调用到这里以进行B的初始化</span></span><br><span class="line">    <span class="comment">// 3. 初始化B的时候要属性注入A，所以调用到这里以获取A的bean</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">        String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object beanInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1和情况2：去一级缓存中获取bean，是获取不到的</span></span><br><span class="line">    <span class="comment">// 情况3：依次去一级缓存，二级缓存和三级缓存中获取A的bean</span></span><br><span class="line">    <span class="comment">// 情况3：在本示例中，最终会在三级缓存中获取到A原始对象对应的ObjectFactory</span></span><br><span class="line">    <span class="comment">// 情况3：然后通过A原始对象对应的ObjectFactory获取A原始对象（的代理对象）</span></span><br><span class="line">    <span class="comment">// 情况3：获取到A原始对象（的代理对象）后，会将其放入二级缓存</span></span><br><span class="line">    <span class="comment">// 情况3：然后将A原始对象对应的ObjectFactory从三级缓存删除</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非单例bean是无法支持循环依赖的，所以这里判断是否是非单例bean的循环依赖场景，如果是则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况1和情况2都会执行到这里</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 在上面的getSingleton()方法中会调用到createBean()方法</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            beanCreation.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际会有三种情况调用到<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法，总结如下。</p>
<ol>
<li>容器初始化的时候，初始化<strong>A</strong>，这种情况，是无法从一级缓存中获取到<strong>A</strong>的<strong>bean</strong>（或者代理<strong>bean</strong>）的，所以调用<strong>getSingleton(String)</strong> 方法会返回<strong>null</strong>，然后调用<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;<strong>?**&gt;)方法来获取（初始化）</strong>A**；</li>
<li>初始化<strong>A</strong>的时候，会属性注入<strong>B</strong>，此时会调用到<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法来初始化<strong>B</strong>，这种情况的逻辑同上；</li>
<li>初始化<strong>B</strong>的时候，会属性注入<strong>A</strong>，此时会调用到<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法来获取<strong>A</strong>的<strong>bean</strong>（或者代理<strong>bean</strong>），并且能够在<strong>getSingleton(String)</strong> 方法中获取到<strong>A</strong>的原始对象对应的<strong>ObjectFactory</strong>，然后通过<strong>A</strong>的原始对象对应的<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法获取到<strong>A</strong>的原始对象（的代理对象），并将其放入二级缓存，最后将<strong>A</strong>的原始对象对应的<strong>ObjectFactory</strong>从三级缓存中删除。</li>
</ol>
<p>上述的情况1和情况2，在<strong>getSingleton(String)</strong> 方法中只会去一级缓存获取，而情况三会依次去一级缓存，二级缓存和三级缓存中获取，这是因为有一个叫做<strong>singletonsCurrentlyInCreation</strong>的集合会对即将实例化并执行初始化逻辑的<strong>bean</strong>进行标记，那么在情况1和情况2中，<strong>singletonsCurrentlyInCreation</strong>中都是没有<strong>A</strong>或<strong>B</strong>的标记的，只有情况3的<strong>singletonsCurrentlyInCreation</strong>中有<strong>A</strong>的标记，如果有标记，表明这时发生了循环依赖，所以需要去到二级缓存或者三级缓存中获取到提前暴露出来的对象。</p>
<p>如果是情况1或者情况2，那么就会调用到<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;<strong>?**&gt;)方法来初始化</strong>A<strong>或者</strong>B<strong>，这里传入的</strong>ObjectFactory**&lt;<strong>?**&gt;实际是一个</strong>Lambdas<strong>表达式，所以调用</strong>ObjectFactory<strong>的</strong>getObject()** 方法，就会调用到<strong>createBean()</strong> 方法。下面继续看<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;**?**&gt;)方法的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向singletonsCurrentlyInCreation集合中添加beanName</span></span><br><span class="line">            <span class="comment">// 标记beanName对应的bean正在初始化，这里就是标记A或者B正在初始化</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用getObject()方法，实际就是调用之前的createBean()方法</span></span><br><span class="line">                <span class="comment">// 这里得到的singletonObject就是初始化后得到的bean（或者代理bean）</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 移除A或者B正在初始化的标记</span></span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">// 将A或者B的bean放入一级缓存</span></span><br><span class="line">                <span class="comment">// 删除A或者B在二级缓存中的原始对象（的代理对象）</span></span><br><span class="line">                <span class="comment">// 删除A或者B在三级缓存中的ObjectFactory</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DefaultSingletonBeanRegistry</strong>的<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;<strong>?**&gt;)方法中首先会标记</strong>A<strong>或者</strong>B<strong>正在初始化，然后调用到</strong>AbstractAutowireCapableBeanFactory<strong>的</strong>createBean()** 方法，在<strong>createBean()</strong> 方法中会真正的把对象<strong>new</strong>出来以得到原始对象，然后为原始对象属性注入其它<strong>bean</strong>（循环依赖就是在这里发生）和执行初始化逻辑，在<strong>createBean()</strong> 方法执行完后，就会得到真正可用的<strong>bean</strong>（或代理<strong>bean</strong>），之后就从<strong>singletonsCurrentlyInCreation</strong>中移除正在初始化的标记，然后将<strong>bean</strong>（或者代理<strong>bean</strong>）放入一级缓存，然后删除在二级缓存中的原始对象（的代理对象），删除在三级缓存中的<strong>ObjectFactory</strong>。那么重点就是<strong>createBean()</strong> 方法，其实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到BeanDefinition</span></span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化在这里</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进<strong>doCreateBean()</strong> 方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把A或者B的对象new出来，称作原始对象</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的bean就是A或者B的原始对象，此时没有被属性注入，也没有执行初始化逻辑</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里计算结果为true，目的是提前将A或B的原始对象对应的ObjectFactory放到三级缓存中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将A或者B的原始对象对应的ObjectFactory放到三级缓存中</span></span><br><span class="line">        <span class="comment">// 那么ObjectFactory的getObejct()方法实际就会调用到getEarlyBeanReference()方法</span></span><br><span class="line">        <span class="comment">// 如果需要动态代理，getEarlyBeanReference()方法会返回原始对象的代理对象</span></span><br><span class="line">        <span class="comment">// 如果不需要动态代理，getEarlyBeanReference()方法会返回原始对象</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里为A或者B的原始对象进行属性注入</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 调用initializeBean()方法来为A或者B的原始对象执行初始化的逻辑</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 这里会从二级缓存中将A或者B的原始对象（的代理对象）获取出来</span></span><br><span class="line">        <span class="comment">// 如果是初始化A的时候调用到这里，那么能够获取出来A的原始对象（的代理对象）</span></span><br><span class="line">        <span class="comment">// 如果是初始化B的时候调用到这里，那么不能够获取出来B的原始对象（的代理对象）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">// 只有A能进到这里</span></span><br><span class="line">                <span class="comment">// 将A的原始对象（的代理对象）替换A的原始对象</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原始对象（的代理对象）返回</span></span><br><span class="line">    <span class="comment">// 其实这里的对象已经是可以使用的bean了</span></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>doCreateBean()</strong> 方法可以概括如下。</p>
<ol>
<li><strong>new</strong>出对象以得到<strong>A</strong>或<strong>B</strong>的原始对象，然后将<strong>A</strong>或<strong>B</strong>的原始对象对应的<strong>ObjectFactory</strong>放入三级缓存（提前暴露原始对象的<strong>ObjectFactory</strong>到三级缓存中，以使得发生循环依赖的时候能够在三级缓存中通过原始对象的<strong>ObjectFactory</strong>获得原始对象或者原始对象的代理对象）；</li>
<li>为原始对象进行属性注入，这里就分为两种情况。<ol>
<li>为<strong>A</strong>原始对象属性注入<strong>B</strong>的<strong>bean</strong>，那么就触发了初始化<strong>B</strong>的逻辑；</li>
<li>为<strong>B</strong>原始对象属性注入<strong>A</strong>的<strong>bean</strong>，那么在这里，就会使用到<strong>A</strong>提前暴露到三级缓存中的<strong>ObjectFactory</strong>来获取<strong>A</strong>的原始对象（的代理对象），由前面的分析可知，通过<strong>A</strong>的<strong>ObjectFactory</strong>来获取到<strong>A</strong>的原始对象（的代理对象）后，会将其放入二级缓存，所以这个时候二级缓存中存在<strong>A</strong>的原始对象（的代理对象）。</li>
</ol>
</li>
<li>调用initializeBean()方法来为A或者B的原始对象执行初始化的逻辑，initializeBean()方法中有一个和循环依赖密切相关的执行步骤就是在后置处理器中为需要动态代理的对象生成代理对象，那么这里又有两种情况。<ol>
<li>初始化<strong>A</strong>的时候执行到这里，说明<strong>B</strong>的初始化已经执行完毕了（因为<strong>A</strong>的属性注入已经结束了），所以<strong>A</strong>原始对象的代理对象就已经生成并且注入到了<strong>B</strong>的<strong>bean</strong>（或者代理<strong>bean</strong>）中，所以这里<strong>A</strong>就不能再在<strong>initializeBean()</strong> 方法的后置处理器中再生成一个代理对象，如果生成就出现了两个代理对象违反了单例；</li>
<li>初始化<strong>B</strong>的时候执行到这里，<strong>B</strong>原始对象的代理对象还没有在任何一个地方有生成，所以需要在<strong>initializeBean()</strong> 方法的后置处理器中生成一个代理对象，并将这个代理对象返回。同时，在前面的分析中已知，只有通过调用<strong>ObjectFactory</strong>来获取原始对象（的代理对象）的时候，才会将原始对象（的代理对象）放入二级缓存，所以<strong>B</strong>的原始对象（的代理对象）是没有被放入到二级缓存中去的。</li>
</ol>
</li>
<li>由于doCreateBean()方法是需要返回可用的bean，所以在A和B都需要动态代理的情况下，还需要为属性注入和执行了初始化逻辑之后的对象再最后做一步操作，那就是将A和B的动态代理对象获取到并返回。<ol>
<li>对于<strong>A</strong>，<strong>A</strong>的动态代理对象在二级缓存中，所以调用<strong>getSingleton()</strong> 方法从二级缓存中获取并返回；</li>
<li>对于<strong>B</strong>，<strong>B</strong>的动态代理对象不存在于二级缓存中，但是当前<strong>B</strong>的对象已经是在后置处理器中生成的动态代理对象，所以直接返回。</li>
</ol>
</li>
</ol>
<p>那么到这里，<strong>Spring</strong>使用三级缓存来解决循环依赖的问题就基本分析完毕，建议结合第二节中的流程图一起阅读。</p>
<h3 id="四-一级缓存作用"><a href="#四-一级缓存作用" class="headerlink" title="四. 一级缓存作用"></a>四. 一级缓存作用</h3><p>一级缓存的定义在<strong>DefaultSingletonBeanRegistry</strong>中，定义如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>

<p>一级缓存用于存放容器中可以使用的<strong>bean</strong>或者代理<strong>bean</strong>，像例子中的<strong>A</strong>和<strong>B</strong>，由于它们都需要生成动态代理对象，所以它们在一级缓存中存放的就是它们的代理<strong>bean</strong>，后续容器中任何地方使用<strong>A</strong>和<strong>B</strong>，都是使用的一级缓存中它们的代理<strong>bean</strong>。</p>
<h3 id="五-二级缓存作用"><a href="#五-二级缓存作用" class="headerlink" title="五. 二级缓存作用"></a>五. 二级缓存作用</h3><p>二级缓存的定义在<strong>DefaultSingletonBeanRegistry</strong>中，定义如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>二级缓存用于存放原始对象（的代理对象），以让在有多重循环依赖的时候其它对象都从二级缓存中拿到同一个当前原始对象（的代理对象），并且只有在调用了三级缓存中的<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法获取原始对象（的代理对象）时，才会将原始对象（的代理对象）放入二级缓存，而调用三级缓存中的<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法获取原始对象（的代理对象）这种情况只会发生在有循环依赖的时候，所以，**<code>二级缓存在没有循环依赖的情况下不会被使用到</code>**。</p>
<h3 id="六-三级缓存作用"><a href="#六-三级缓存作用" class="headerlink" title="六. 三级缓存作用"></a>六. 三级缓存作用</h3><p>三级缓存的定义在<strong>DefaultSingletonBeanRegistry</strong>中，定义如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>三级缓存用于存放原始对象对应的<strong>ObjectFactory</strong>，每生成一个原始对象，都会将这个原始对象对应的<strong>ObjectFactory</strong>放到三级缓存中，通过调用<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法，就能够在需要动态代理的情况下为原始对象生成代理对象并返回，否则返回原始对象，以此来处理循环依赖时还需要动态代理的情况。</p>
<p>为什么会存在三级缓存，主要原因就是：**<code>延迟代理对象的创建</code><strong>。设想一下，如果在创建出一个原始对象的时候，就直接将这个原始对象的代理对象创建出来（如果需要创建的话），然后就放在二级缓存中，似乎感觉三级缓存就没有存在的必要了对吧，但是请打住，这里存在的问题就是，如果真这么做了，那么每一个对象在创建出原始对象后，就都会去创建代理对象，而</strong>Spring<strong>的原始设计中，代理对象的创建应该是由</strong>AnnotationAwareAspectJAutoProxyCreator<strong>这个后置处理器的</strong>postProcessAfterInitialization()** 来完成，也就是：**<code>在对象初始化完毕后，再去创建代理对象</code><strong>。如果真的只用两个缓存来解决循环依赖，那么就会打破</strong>Spring<strong>对</strong>AOP**的一个设计思想。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Spring</strong>中发生循环依赖，简单讲就是<strong>A</strong>的<strong>bean</strong>依赖<strong>B</strong>的<strong>bean</strong>，<strong>B</strong>的<strong>bean</strong>又依赖<strong>A</strong>的<strong>bean</strong>。</p>
<p><strong>Spring</strong>解决循环依赖的思路就是，当<strong>A</strong>的<strong>bean</strong>需要<strong>B</strong>的<strong>bean</strong>的时候，提前将<strong>A</strong>的<strong>bean</strong>放在缓存中（实际是将<strong>A</strong>的<strong>ObjectFactory</strong>放到三级缓存），然后再去创建<strong>B</strong>的<strong>bean</strong>，但是<strong>B</strong>的<strong>bean</strong>也需要<strong>A</strong>的<strong>bean</strong>，那么这个时候就去缓存中拿<strong>A</strong>的<strong>bean</strong>，<strong>B</strong>的<strong>bean</strong>创建完毕后，再回来继续创建<strong>A</strong>的<strong>bean</strong>，最终完成循环依赖的解决。</p>
<p>那么有几个问题需要结合整篇文章的讨论，进行一个总结。</p>
<p><strong>1. 为什么不直接使用一级缓存来解决循环依赖</strong></p>
<p>一级缓存中预期存放的是一个正常完整的<strong>bean</strong>，而如果只用一级缓存来解决循环依赖，那么一级缓存中会在某个时间段存在不完整的<strong>bean</strong>，这是不安全的。</p>
<p><strong>2. 为什么不直接使用一级缓存和二级缓存解决循环依赖</strong></p>
<p>这个问题需要结合为什么引入三级缓存来分析。引用第六节的论述，使用一级缓存和二级缓存确实可以解决循环依赖，但是这要求每个原始对象创建出来后就立即生成动态代理对象（如果有的话），然后将这个动态代理对象放入二级缓存，这就打破了<strong>Spring</strong>对<strong>AOP</strong>的设计原则，即：**<code>在对象初始化完毕后，再去创建代理对象</code><strong>。所以引入三级缓存，并且在三级缓存中存放一个对象的</strong>ObjectFactory<strong>，目的就是：</strong><code>延迟代理对象的创建</code>**，这里延迟到啥时候创建呢，有两种情况：第一种就是确实存在循环依赖，那么没办法，只能在需要的时候就创建出来代理对象然后放到二级缓存中，第二种就是不存在循环依赖，那就是正常的在初始化的后置处理器中创建。</p>
<p>因此不直接使用一级缓存和二级缓存来解决循环依赖的原因就是：**<code>希望在不存在循环依赖的情况下不破坏Spring对AOP的设计原则</code>**。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢大佬的打赏，我会继续努力哒！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/vx-pay.jpg" alt="EthanWhite-Chen WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/zfb-pay.jpg" alt="EthanWhite-Chen Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/aop/" rel="tag"># aop</a>
              <a href="/tags/ioc/" rel="tag"># ioc</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/" rel="prev" title="了解@Enable* 原理">
      <i class="fa fa-chevron-left"></i> 了解@Enable* 原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/05/24/MQ%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B8%89%E8%BF%9E%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%E3%80%81%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E7%A7%AF%E5%8E%8B%EF%BC%9F/" rel="next" title="MQ面试问题三连：如何解决消息不丢失、重复消费、积压？">
      MQ面试问题三连：如何解决消息不丢失、重复消费、积压？ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E6%96%87"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-number">2.1.</span> <span class="nav-text">一. 循环依赖的产生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="nav-number">2.2.</span> <span class="nav-text">二. 循环依赖的解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text">三. 源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8"><span class="nav-number">2.4.</span> <span class="nav-text">四. 一级缓存作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8"><span class="nav-number">2.5.</span> <span class="nav-text">五. 二级缓存作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8"><span class="nav-number">2.6.</span> <span class="nav-text">六. 三级缓存作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">EthanWhite-Chen</p>
  <div class="site-description" itemprop="description">不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ethanwhite-chen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ethanwhite-chen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ykchen998@foxmail.com" title="E-Mail → ykchen998@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EthanWhite-Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">152k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">4:36</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
