<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ethanwhite-chen.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
<meta property="og:type" content="website">
<meta property="og:title" content="ykchen的个人博客">
<meta property="og:url" content="https://ethanwhite-chen.github.io/page/2/index.html">
<meta property="og:site_name" content="ykchen的个人博客">
<meta property="og:description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="EthanWhite-Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ethanwhite-chen.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>ykchen的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ykchen的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到ykchen的技术总结分享博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ethanwhite-chen" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/" class="post-title-link" itemprop="url">线程之间如何进⾏通讯的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-23 15:34:01 / Modified: 15:36:54" itemprop="dateCreated datePublished" datetime="2023-05-23T15:34:01+08:00">2023-05-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、为什么需要线程通信"><a href="#1、为什么需要线程通信" class="headerlink" title="1、为什么需要线程通信"></a><strong>1、为什么需要线程通信</strong></h2><p>线程是操作系统调度的最小单位，有自己的栈空间，可以按照既定的代码逐步的执行，但是如果每个线程间都孤立的运行，那就会造资源浪费。所以在现实中，我们需要这些线程间可以按照指定的规则共同完成一件任务，所以这些线程之间就需要互相协调，这个过程被称为线程的通信。</p>
<p>线程的通信可以被定义为：</p>
<blockquote>
<p>线程通信就是当多个线程共同操作共享的资源时，互相告知自己的状态以避免资源争夺。</p>
</blockquote>
<h2 id="2、线程通信的方式"><a href="#2、线程通信的方式" class="headerlink" title="2、线程通信的方式"></a><strong>2、线程通信的方式</strong></h2><p>线程通信主要可以分为三种方式，分别为<strong>共享内存</strong>、<strong>消息传递</strong>和<strong>管道流</strong>。每种方式有不同的方法来实现</p>
<ul>
<li>共享内存：线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式通信。</li>
</ul>
<blockquote>
<p>volatile共享内存</p>
</blockquote>
<ul>
<li>消息传递：线程之间没有公共的状态，线程之间必须通过明确的发送信息来显示的进行通信。</li>
</ul>
<blockquote>
<p>wait&#x2F;notify等待通知方式<br>join方式</p>
</blockquote>
<ul>
<li>管道流</li>
</ul>
<blockquote>
<p>管道输入&#x2F;输出流的形式</p>
</blockquote>
<h3 id="2-1共享内存"><a href="#2-1共享内存" class="headerlink" title="2.1共享内存"></a><strong>2.1共享内存</strong></h3><p>在学习Volatile之前，我们先了解下Java的内存模型，</p>
<img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-347345d6926e3a1dfc81126bad653c2d_720w.webp" class title="img">

<p>在java中，所有堆内存中的所有的数据（实例域、静态域和数组元素）存放在主内存中可以在线程之间共享，一些局部变量、方法中定义的参数存放在本地内存中不会在线程间共享。线程之间的共享变量存储在主内存中，本地内存存储了共享变量的副本。如果线程A要和线程B通信，则需要经过以下步骤</p>
<blockquote>
<p>①线程A把本地内存A更新过的共享变量刷新到主内存中<br>②线程B到内存中去读取线程A之前已更新过的共享变量。</p>
</blockquote>
<p>这保证了线程间的通信必须经过主内存。下面引出我们要学习的关键字<strong>volatile</strong></p>
<p>volatile有一个关键的特性：保证内存可见性，即多个线程访问内存中的同一个被volatile关键字修饰的变量时，当某一个线程修改完该变量后，需要先将这个最新修改的值写回到主内存，从而保证下一个读取该变量的线程取得的就是主内存中该数据的最新值，这样就保证线程之间的透明性，便于线程通信。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Simon Lang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/5 15:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">                        flag=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong>：线程A和线程B交替执行</p>
<img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-8b019fb2a574d808b018bc76892d4b38_720w.webp" class title="img">

<h3 id="2-2消息传递"><a href="#2-2消息传递" class="headerlink" title="2.2消息传递"></a><strong>2.2消息传递</strong></h3><h3 id="2-2-1wait-x2F-notify等待通知方式"><a href="#2-2-1wait-x2F-notify等待通知方式" class="headerlink" title="2.2.1wait&#x2F;notify等待通知方式"></a>2.2.1wait&#x2F;notify等待通知方式</h3><p>从字面上理解，等待通知机制就是将处于等待状态的线程将由其它线程发出通知后重新获取CPU资源，继续执行之前没有执行完的任务。最典型的例子生产者–消费者模式</p>
<img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-871a224a8559dfba4f751656453f996d_720w.webp" class title="img">

<p>有一个产品队列，生产者想要在队列中添加产品，消费者需要从队列中取出产品，如果队列为空，消费者应该等待生产者添加产品后才进行消费，队列为满时，生产者需要等待消费者消费一部分产品后才能继续生产。队列可以认为是java模型里的临界资源，生产者和消费者认为是不同的线程，它们需要交替的占用临界资源来进行各自方法的执行，所以就需要线程间通信。</p>
<p>生产者–消费者模型主要为了方便复用和解耦，java语言实现线程之间的通信协作的方式是等待&#x2F;通知机制</p>
<p>等待&#x2F;通知机制提供了三个方法用于线程间的通信</p>
<p><strong>wait()当前线程释放锁并进入等待(阻塞)状态</strong>notify()唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后继续竞争锁notifyAll()唤醒所有正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后继续竞争锁</p>
<p>等待&#x2F;通知机制是指一个线程A调用了对象Object的wait()方法进入等待状态，而另一线程B调用了对象Object的notify()或者notifyAll()方法，当线程A收到通知后就可以从对象Object的wait()方法返回，进而执行后序的操作。线程间的通信需要对象Object来完成，对象中的wait()、notify()、notifyAll()方法就如同开关信号，用来完成等待方和通知方的交互。</p>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">static</span> Object lock=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       Thread waitThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitThread</span>(),<span class="string">&quot;WaitThread&quot;</span>);</span><br><span class="line">       waitThread.start();</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">       Thread notifyThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">NotifyThread</span>(),<span class="string">&quot;NotifyThread&quot;</span>);</span><br><span class="line">       notifyThread.start();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//等待线程</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="comment">//加锁</span></span><br><span class="line">           <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">               <span class="comment">//条件不满足时，继续等待，同时释放lock锁</span></span><br><span class="line">               <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;flag为true，不满足条件，继续等待&quot;</span>);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       lock.wait();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//条件满足</span></span><br><span class="line">               System.out.println(<span class="string">&quot;flag为false，我要从wait状态返回继续执行了&quot;</span>);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//通知线程</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotifyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="comment">//加锁</span></span><br><span class="line">           <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">               <span class="comment">//获取lock锁，然后进行通知，但不会立即释放lock锁，需要该线程执行完毕</span></span><br><span class="line">               lock.notifyAll();</span><br><span class="line">               System.out.println(<span class="string">&quot;设置flag为false,我发出通知了，但是我不会立马释放锁&quot;</span>);</span><br><span class="line">               flag=<span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-c7ba75ae87a07c84a40a9e9d053f4ece_720w.webp" class title="img">

<p><strong>NOTE</strong>：使用wait()、notify()和notifyAll()需要注意以下细节</p>
<ul>
<li>使用wait()、notify()和notifyAll()需要先调用对象加锁</li>
<li>调用wait()方法后，线程状态由Running变成Waiting，并将当前线程放置到对象的等待队列</li>
<li>notify()和notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()和notifyAll()的线程释放锁之后等待线程才有机会从wait()返回</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部转移到同步队列，被移到的线程状态由Waiting变为Blocked。</li>
<li>从wait()方法返回的前提是获得调用对象的锁</li>
</ul>
<p>其实等待通知机制有有一个经典的范式，该范式可以分为两部分，分别是等待方（消费者）和通知方（生产者）</p>
<ul>
<li>等待方</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line"><span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">对象.wait()</span><br><span class="line">&#125;</span><br><span class="line">对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通知方</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">改变条件</span><br><span class="line">对象.notifyAll</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2join方式"><a href="#2-2-2join方式" class="headerlink" title="2.2.2join方式"></a>2.2.2join方式</h3><p>在很多应用场景中存在这样一种情况，主线程创建并启动子线程后，如果子线程要进行很耗时的计算，那么主线程将比子线程先结束，但是主线程需要子线程的计算的结果来进行自己下一步的计算，这时主线程就需要等待子线程，java中提供可join()方法解决这个问题。</p>
<p>join()方法的作用是：在当前线程A调用线程B的join()方法后，会让当前线程A阻塞，直到线程B的逻辑执行完成，A线程才会解除阻塞，然后继续执行自己的业务逻辑，这样做可以节省计算机中资源。</p>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程0开始执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            JoinThread jt=<span class="keyword">new</span> <span class="title class_">JoinThread</span>(thread,i);</span><br><span class="line">            jt.start();</span><br><span class="line">            thread=jt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JoinThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">JoinThread</span><span class="params">(Thread thread,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.thread=thread;</span><br><span class="line">            <span class="built_in">this</span>.i=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-0399a18ecdba2fc75eeb9bdf4cb2b95f_720w.webp" class title="img">

<p><strong>NOTE</strong>：每个线程的终止的前提是前驱线程的终止，每个线程等待前驱线程终止后，才从join方法返回，实际上，这里涉及了等待&#x2F;通知机制，即下一个线程的执行需要接受前驱线程结束的通知。</p>
<h3 id="2-3管道输入-x2F-输出流"><a href="#2-3管道输入-x2F-输出流" class="headerlink" title="2.3管道输入&#x2F;输出流"></a><strong>2.3管道输入&#x2F;输出流</strong></h3><p>管道流是是一种使用比较少的线程间通信方式，管道输入&#x2F;输出流和普通文件输入&#x2F;输出流或者网络输出&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，传输的媒介为管道。</p>
<p>管道输入&#x2F;输出流主要包括4种具体的实现：PipedOutputStrean、PipedInputStrean、PipedReader和PipedWriter，前两种面向字节，后两种面向字符。</p>
<p>java的管道的输入和输出实际上使用的是一个循环缓冲数组来实现的，默认为1024，输入流从这个数组中读取数据，输出流从这个数组中写入数据，当这个缓冲数组已满的时候，输出流所在的线程就会被阻塞，当向这个缓冲数组为空时，输入流所在的线程就会被阻塞。</p>
<img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-2d66bec02a173901042d5a7a8758f910_720w.webp" class title="img">



<blockquote>
<p>buffer：缓冲数组，默认为1024<br>out：从缓冲数组中读数据<br>in：从缓冲数组中写数据</p>
</blockquote>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPip</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PipedWriter</span> <span class="variable">writer</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedWriter</span>();</span><br><span class="line">        <span class="type">PipedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedReader</span>();</span><br><span class="line">        <span class="comment">//使用connect方法将输入流和输出流连接起来</span></span><br><span class="line">        writer.connect(reader);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(reader) , <span class="string">&quot;PrintThread&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程printThread</span></span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//读取输入的内容</span></span><br><span class="line">            <span class="keyword">while</span>((receive = System.in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                writer.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader reader;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Print</span><span class="params">(PipedReader reader)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.reader = reader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = reader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//字符转换</span></span><br><span class="line">                    System.out.print((<span class="type">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.print(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-c41f942b2334033655a44371ea0fe480_720w.webp" class title="img">



<p><strong>NOTE</strong>：对于Piped类型的流，必须先进性绑定，也就是调用connect()方法，如果没有将输入&#x2F;输出流绑定起来，对于该流的访问将抛出异常。</p>
<p>如果有什么疑问可以联系我，（公众号有我的联系方式）让我们每天一起每天进步一点点</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Spring事务原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-23 14:05:51 / Modified: 14:07:29" itemprop="dateCreated datePublished" datetime="2023-05-23T14:05:51+08:00">2023-05-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>26 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Spring事务原理一探"><a href="#Spring事务原理一探" class="headerlink" title="Spring事务原理一探"></a><strong>Spring事务原理一探</strong></h2><p>概括来讲，事务是一个由有限操作集合组成的逻辑单元。事务操作包含两个目的，数据一致以及操作隔离。数据一致是指事务提交时保证事务内的所有操作都成功完成，并且更改永久生效；事务回滚时，保证能够恢复到事务执行之前的状态。操作隔离则是指多个同时执行的事务之间应该相互独立，互不影响。</p>
<p>事务是一个比较广泛的概念，事务管理资源除了我们熟知的数据库外，还可以包含消息队列、文件系统等。当然，一般来说，我们说的事务单指“数据库事务”。接下来我们会以MySQL数据库、Spring声明式事务为主要研究对象，但是很多事务概念、接口抽象和实现方式同时适用于其他情况。</p>
<h2 id="事务属性和行为"><a href="#事务属性和行为" class="headerlink" title="事务属性和行为"></a><strong>事务属性和行为</strong></h2><p><strong>ACID属性</strong></p>
<p>提到事务，不可避免需要涉及到事务的ACID属性：</p>
<ul>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。</li>
</ul>
<p>我们将严格遵循ACID属性的事务称为<strong>刚性事务</strong>。与之相对，期望最终一致性，在事务执行的中间状态允许暂时不遵循ACID属性的事务称为<strong>柔性事务</strong>，可参考<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/ab1a1c6b08a1">传统事务与柔性事务</a>，柔性事务的使用涉及到<strong>分布式事务</strong>方案，可以后续扩展，这里我们先将注意集中在事务实现原理上。</p>
<p><strong>隔离级别</strong></p>
<p>根据SQL92标准，MySQL的InnoDB引擎提供四种<strong>隔离级别</strong>（即ACID中的I）：读未提交（READ UNCOMMITTED）、读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）和串行化（SERIALIZABLE），InnoDB默认的隔离级别是<code>REPEATABLE READ</code>，其可避免<em>脏读</em>和<em>不可重复读</em>，但不能避免<em>幻读</em>，需要指出的是，InnoDB引擎的多版本并发控制机制（MVCC）并没有完全避免<em>幻读</em>，关于该问题以及隔离级别说明，可参考<a href="https://link.zhihu.com/?target=http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">MySQL的InnoDB的幻读问题</a>。</p>
<p><strong>传播机制</strong></p>
<p>Spring针对方法嵌套调用时事务的创建行为定义了七种<strong>事务传播机制</strong>，分别是PROPAGATION_REQUIRED、PROPAGATION_SUPPORT、PROPAGATION_MANDATORY、PROPAGATION_REQUIRES_NEW、PROPAGATION_NOT_SUPPORTED、PROPAGATION_NEVER以及PROPAGATION_NESTED，基本上从字面意思就能知道每种传播机制各自的行为表现，Spring默认的事务传播机制是<code>PROPAGATION_REQUIRED</code>，即如果当前存在事务，则使用当前事务，否则创建新的事务。详情可参考<a href="https://link.zhihu.com/?target=https://juejin.im/post/5ae9639af265da0b926564e7">Spring事务传播行为</a>。</p>
<p><strong>事务行为</strong></p>
<p>事务的行为包括事务开启、事务提交和事务回滚。InnoDB所有的用户SQL执行都在事务控制之内，在默认情况下，<strong>autocommit</strong>设置为<code>true</code>，单条SQL执行成功后，MySQL会自动提交事务，或者如果SQL执行出错，则根据异常类型执行事务提交或者回滚。可以使用<code>START TRANSACTION</code>（SQL标准）或者<code>BEGIN</code>开启事务，使用<code>COMMIT</code>和<code>ROLLBACK</code>提交和回滚事务；也可以通过设置autocommit属性来控制事务行为，当设置autocommit为<code>false</code>时，其后执行的多条SQL语句将在一个事务内，直到执行<code>COMMIT</code>或者<code>ROLLBACK</code>事务才会提交或者回滚。</p>
<h2 id="AOP增强"><a href="#AOP增强" class="headerlink" title="AOP增强"></a><strong>AOP增强</strong></h2><p>Spring使用<strong>AOP</strong>（面向切面编程）来实现<strong>声明式事务</strong>，后续在讲Spring事务具体实现的时候会详细说明，关于AOP的概念可参考<a href="https://link.zhihu.com/?target=https://blog.csdn.net/qukaiwei/article/details/50367761">Spring AOP概念理解（通俗易懂）</a>，这里不再细说。说下<strong>动态代理</strong>和<strong>AOP增强</strong>。</p>
<p>动态代理是Spring实现AOP的默认方式，分为两种：<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong>。JDK动态代理面向接口，通过反射生成目标代理接口的匿名实现类；CGLIB动态代理则通过继承，使用字节码增强技术（或者<code>objenesis</code>类库）为目标代理类生成代理子类。Spring默认对接口实现使用JDK动态代理，对具体类使用CGLIB，同时也支持配置全局使用CGLIB来生成代理对象。</p>
<p>我们在切面配置中会使用到<code>@Aspect</code>注解，这里用到了<strong>Aspectj</strong>的切面表达式。Aspectj是java语言实现的一个AOP框架，使用静态代理模式，拥有完善的AOP功能，与Spring AOP互为补充。Spring采用了Aspectj强大的切面表达式定义方式，但是默认情况下仍然使用动态代理方式，并未使用Aspectj的编译器和织入器，当然也支持配置使用Aspectj静态代理替代动态代理方式。Aspectj功能更强大，比方说它支持对字段、POJO类进行增强，与之相对，Spring只支持对Bean方法级别进行增强。</p>
<p>Spring对方法的增强有五种方式：</p>
<ul>
<li>前置增强（<code>org.springframework.aop.BeforeAdvice</code>）：在目标方法执行之前进行增强；</li>
<li>后置增强（<code>org.springframework.aop.AfterReturningAdvice</code>）：在目标方法执行之后进行增强；</li>
<li>环绕增强（<code>org.aopalliance.intercept.MethodInterceptor</code>）：在目标方法执行前后都执行增强；</li>
<li>异常抛出增强（<code>org.springframework.aop.ThrowsAdvice</code>）：在目标方法抛出异常后执行增强；</li>
<li>引介增强（<code>org.springframework.aop.IntroductionInterceptor</code>）：为目标类添加新的方法和属性。</li>
</ul>
<p>声明式事务的实现就是通过环绕增强的方式，在目标方法执行之前开启事务，在目标方法执行之后提交或者回滚事务，事务拦截器的继承关系图可以体现这一点：</p>
<img src="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/v2-e1b27f9e03b55e4695b72177d3fc60d8_720w.webp" class title="img">



<h2 id="Spring事务抽象"><a href="#Spring事务抽象" class="headerlink" title="Spring事务抽象"></a>Spring事务抽象</h2><p>统一一致的事务抽象是Spring框架的一大优势，无论是全局事务还是本地事务，JTA、JDBC、Hibernate还是JPA，Spring都使用统一的编程模型，使得应用程序可以很容易地在全局事务与本地事务，或者不同的事务框架之间进行切换。下图是Spring事务抽象的核心类图：</p>
<img src="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/v2-ff9900cb40f07db75d1190628f464564_720w.webp" class title="img">



<p>接口<code>PlatformTransactionManager</code>定义了事务操作的行为，其依赖<code>TransactionDefinition</code>和<code>TransactionStatus</code>接口，其实大部分的事务属性和行为我们以MySQL数据库为例已经有过了解，这里再对应介绍下。</p>
<ul>
<li><code>PlatformTransactionManager</code>：事务管理器</li>
<li><code>getTransaction</code>方法：事务获取操作，根据事务属性定义，获取当前事务或者创建新事物；</li>
<li><code>commit</code>方法：事务提交操作，注意这里所说的提交并非直接提交事务，而是根据当前事务状态执行提交或者回滚操作；</li>
<li><code>rollback</code>方法：事务回滚操作，同样，也并非一定直接回滚事务，也有可能只是标记事务为只读，等待其他调用方执行回滚。</li>
<li><code>TransactionDefinition</code>：事务属性定义</li>
<li><code>getPropagationBehavior</code>方法：返回事务的传播属性，默认是<code>PROPAGATION_REQUIRED</code>；</li>
<li><code>getIsolationLevel</code>方法：返回事务隔离级别，事务隔离级别只有在创建新事务时才有效，也就是说只对应传播属性<code>PROPAGATION_REQUIRED</code>和<code>PROPAGATION_REQUIRES_NEW</code>；</li>
<li><code>getTimeout</code>方法：返回事务超时时间，以秒为单位，同样只有在创建新事务时才有效；</li>
<li><code>isReadOnly</code>方法：是否优化为只读事务，支持这项属性的事务管理器会将事务标记为只读，只读事务不允许有写操作，不支持只读属性的事务管理器需要忽略这项设置，这一点跟其他事务属性定义不同，针对其他不支持的属性设置，事务管理器应该抛出异常。</li>
<li><code>getName</code>方法：返回事务名称，声明式事务中默认值为“类的完全限定名.方法名”。</li>
<li><code>TransactionStatus</code>：当前事务状态</li>
<li><code>isNewTransaction</code>方法：当前方法是否创建了新事务（区别于使用现有事务以及没有事务）；</li>
<li><code>hasSavepoint</code>方法：在嵌套事务场景中，判断当前事务是否包含保存点；</li>
<li><code>setRollbackOnly</code>和<code>isRollbackOnly</code>方法：只读属性设置（主要用于标记事务，等待回滚）和查询；</li>
<li><code>flush</code>方法：刷新底层会话中的修改到数据库，一般用于刷新如Hibernate&#x2F;JPA的会话，是否生效由具体事务资源实现决定；</li>
<li><code>isCompleted</code>方法：判断当前事务是否已完成（已提交或者已回滚）。</li>
</ul>
<p>部分Spring包含的对<code>PlatformTransactionManager</code>的实现类如下图所示：</p>
<img src="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/v2-d3e4c3f534dd8a1981f972d429e2c982_720w.webp" class title="img">



<p><code>AbstractPlatformTransactionManager</code>抽象类实现了Spring事务的标准流程，其子类<code>DataSourceTransactionManager</code>是我们使用较多的JDBC单数据源事务管理器，而<code>JtaTransactionManager</code>是JTA（Java Transaction API）规范的实现类，另外两个则分别是JavaEE容器<em>WebLogic</em>和<em>WebSphere</em>的JTA事务管理器的具体实现。</p>
<h2 id="Spring事务切面"><a href="#Spring事务切面" class="headerlink" title="Spring事务切面"></a>Spring事务切面</h2><p>之前提到，Spring采用AOP来实现声明式事务，那么事务的AOP切面是如何织入的呢？这一点涉及到AOP动态代理对象的生成过程。</p>
<p>代理对象生成的核心类是<code>AbstractAutoProxyCreator</code>，实现了<code>BeanPostProcessor</code>接口，会在<strong>Bean初始化完成之后</strong>，通过<code>postProcessAfterInitialization</code>方法生成代理对象，关于<code>BeanPostProcessor</code>在Bean生命周期中的作用，可参考<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/xrq730/p/5721366.html">一些常用的Spring扩展接口</a>。</p>
<p>看一下<code>AbstractAutoProxyCreator</code>类的核心代码，主要关注三个方法：postProcessAfterInitialization、wrapIfNecessary和createProxy，为了突出核心流程，以注释代替了部分代码的具体实现，后续的源码分析也采用相同的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 创建代理对象</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数检查，跳过已经执行过代理对象生成，或者已知的不需要生成代理对象的Bean</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    <span class="comment">// 查询当前Bean所有的AOP增强配置，最终是通过AOPUtils工具类实现</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 执行AOP织入，创建代理对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">        <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化代理工厂类</span></span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当全局使用动态代理时，设置是否需要对目标Bean强制使用CGLIB动态代理</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建AOP增强顾问，包含框架公共增强和应用程序自定义增强</span></span><br><span class="line">    <span class="comment">// 设置proxyFactory属性，如增强、目标类、是否允许变更等</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是通过调用<code>ProxyFactory#getProxy(java.lang.ClassLoader)</code>方法来创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProxyFactory.class</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProxyFactory父类ProxyCreatorSupport.class</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyCreatorSupport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.aopProxyFactory = <span class="keyword">new</span> <span class="title class_">DefaultAopProxyFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ProxyFactory</code>的父类构造器实例化了<code>DefaultAopProxyFactory</code>类，从其源代码我们可以看到Spring动态代理方式选择策略的实现：如果目标类optimize，proxyTargetClass属性设置为<code>true</code>或者未指定需要代理的接口，则使用CGLIB生成代理对象，否则使用JDK动态代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">AopProxyFactory</span>, Serializable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">        <span class="comment">// 如果optimize，proxyTargetClass属性设置为true或者未指定代理接口，则使用CGLIB生成代理对象</span></span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="comment">// 参数检查，targetClass为空抛出异常</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 目标类本身是接口或者代理对象，仍然使用JDK动态代理</span></span><br><span class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Objenesis是一个可以不通过构造器创建子类的java工具类库</span></span><br><span class="line">            <span class="comment">// 作为Spring 4.0后CGLIB的默认实现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则使用JDK动态代理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring事务拦截"><a href="#Spring事务拦截" class="headerlink" title="Spring事务拦截"></a>Spring事务拦截</h2><p>我们已经了解了AOP切面织入生成代理对象的过程，当Bean方法通过代理对象调用时，会触发对应的AOP增强拦截器，前面提到声明式事务是一种环绕增强，对应接口为<code>MethodInterceptor</code>，事务增强对该接口的实现为<code>TransactionInterceptor</code>，类图如下：</p>
<img src="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/v2-8abdb6f84a52c95957d22497b7a9c248_720w.webp" class title="img">



<p>事务拦截器<code>TransactionInterceptor</code>在<code>invoke</code>方法中，通过调用父类<code>TransactionAspectSupport</code>的<code>invokeWithinTransaction</code>方法进行事务处理，该方法支持声明式事务和编程式事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionInterceptor.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 获取targetClass</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> <span class="title class_">InvocationCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 实际执行目标方法</span></span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransactionInterceptor父类TransactionAspectSupport.class</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">    <span class="comment">// 查询目标方法事务属性、确定事务管理器、构造连接点标识（用于确认事务名称）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// 事务获取</span></span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过回调执行目标方法</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 目标方法执行抛出异常，根据异常类型执行事务提交或者回滚操作</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理当前线程事务信息</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标方法执行成功，提交事务</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 带回调的事务执行处理，一般用于编程式事务</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在讲Spring事务抽象时，有提到事务抽象的核心接口为<code>PlatformTransactionManager</code>，它负责管理事务行为，包括事务的获取、提交和回滚。在<code>invokeWithinTransaction</code>方法中，我们可以看到<code>createTransactionIfNecessary</code>、<code>commitTransactionAfterReturning</code>和<code>completeTransactionAfterThrowing</code>都是针对该接口编程，并不依赖于特定事务管理器，这里是对Spring事务抽象的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TransactionAspectSupport.class</span></span><br><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(</span></span><br><span class="line"><span class="params">        PlatformTransactionManager tm, TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取事务</span></span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commitTransactionAfterReturning</span><span class="params">(TransactionInfo txInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">completeTransactionAfterThrowing</span><span class="params">(TransactionInfo txInfo, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 异常类型为回滚异常，执行事务回滚</span></span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 异常类型为非回滚异常，仍然执行事务提交</span></span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TransactionInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>另外，在获取事务时，<code>AbstractPlatformTransactionManager#doBegin</code>方法负责开启新事务，在<code>DataSourceTransactionManager</code>有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数据库连接con</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">        txObject.setMustRestoreAutoCommit(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Switching JDBC Connection [&quot;</span> + con + <span class="string">&quot;] to manual commit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里才真正开启了数据库事务。</p>
<h2 id="Spring事务同步"><a href="#Spring事务同步" class="headerlink" title="Spring事务同步"></a>Spring事务同步</h2><p>提到事务传播机制时，我们经常提到一个条件“如果当前已有事务”，那么Spring是如何知道当前是否已经开启了事务呢？在<code>AbstractPlatformTransactionManager</code>中是这样做的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPlatformTransactionManager.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line">    <span class="comment">// 参数为null时构造默认值</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前事务对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title function_">doGetTransaction</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前事务对象是否包含活跃事务</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isExistingTransaction</span><span class="params">(Object transaction)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>getTransaction</code>方法是<code>final</code>的，无法被子类覆盖，保证了获取事务流程的一致和稳定。抽象方法<code>doGetTransaction</code>获取当前事务对象，方法<code>isExistingTransaction</code>判断当前事务对象是否存在活跃事务，具体逻辑由特定事务管理器实现，看下我们使用最多的<code>DataSourceTransactionManager</code>对应的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataSourceTransactionManager.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doGetTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionObject</span>();</span><br><span class="line">    txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">    <span class="type">ConnectionHolder</span> <span class="variable">conHolder</span> <span class="operator">=</span></span><br><span class="line">            (ConnectionHolder) TransactionSynchronizationManager.getResource(<span class="built_in">this</span>.dataSource);</span><br><span class="line">    txObject.setConnectionHolder(conHolder, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isExistingTransaction</span><span class="params">(Object transaction)</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line">    <span class="keyword">return</span> (txObject.hasConnectionHolder() &amp;&amp; txObject.getConnectionHolder().isTransactionActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，获取当前事务对象时，使用了<code>TransactionSynchronizationManager#getResource</code>方法，类图如下：</p>
<img src="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/v2-102f07dd273c2a9e093ea4dec88c18c5_720w.webp" class title="img">



<p><code>TransactionSynchronizationManager</code>通过<code>ThreadLocal</code>对象在当前线程记录了<code>resources</code>和<code>synchronizations</code>属性。<code>resources</code>是一个HashMap，用于记录当前参与事务的事务资源，方便进行事务同步，在<code>DataSourceTransactionManager</code>的例子中就是以<code>dataSource</code>作为key，保存了数据库连接，这样在同一个线程中，不同的方法调用就可以通过<code>dataSource</code>获取相同的数据库连接，从而保证所有操作在一个事务中进行。<code>synchronizations</code>属性是一个<code>TransactionSynchronization</code>对象的集合，<code>AbstractPlatformTransactionManager</code>类中定义了事务操作各个阶段的调用流程，以事务提交为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPlatformTransactionManager.class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">beforeCompletionInvoked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prepareForCommit(status);</span><br><span class="line">            triggerBeforeCommit(status);</span><br><span class="line">            triggerBeforeCompletion(status);</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 记录日志</span></span><br><span class="line">                ...</span><br><span class="line">                doCommit(status);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="comment">// 事务调用异常处理</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            triggerAfterCommit(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，有很多<em>trigger</em>前缀的方法，这些方法用于在事务操作的各个阶段触发回调，从而可以精确控制在事务执行的不同阶段所要执行的操作，这些回调实际上都通过<code>TransactionSynchronizationUtils</code>来实现，它会遍历<code>TransactionSynchronizationManager#synchronizations</code>集合中的<code>TransactionSynchronization</code>对象，然后分别触发集合中各个元素对应方法的调用。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> <span class="title class_">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCommit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something after commit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码就在当前线程的事务<code>synchronizations</code>属性中，添加了一个自定义同步类，如果当前存在事务，那么在事务管理器执行事务提交之后，就会触发<code>afterCommit</code>方法，可以通过这种方式在事务执行的不同阶段自定义一些操作。</p>
<p>到这里，我们已经对Spring事务的实现原理和处理流程有了一定的了解。</p>
<p>想要阅读更多技术干货、行业洞察，欢迎关注<a href="https://link.zhihu.com/?target=https://yunxin.163.com/dev-blog/?from=zhihu&utm_source=zhihu&utm_medium=article&">网易云信博客</a>。</p>
<p>了解<a href="https://link.zhihu.com/?target=https://yunxin.163.com/?from=zhihu&utm_source=zhihu&utm_medium=article&">网易云信</a>，来自网易核心架构的通信与视频云服务。</p>
<hr>
<p>网易云信（NeteaseYunXin）是集网易18年IM以及音视频技术打造的PaaS服务产品，来自网易核心技术架构的通信与视频云服务，稳定易用且功能全面，致力于提供全球领先的技术能力和场景化解决方案。开发者通过集成客户端SDK和云端OPEN API，即可快速实现包含IM、音视频通话、直播、点播、互动白板、短信等功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/23/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/23/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">Dubbo的负载均衡</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-23 11:13:22 / Modified: 14:01:52" itemprop="dateCreated datePublished" datetime="2023-05-23T11:13:22+08:00">2023-05-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dubbo是一个分布式服务框架，能避免单点故障和支持服务的横向扩容。一个服务通常会部署多个实例。如何从多个服务 Provider 组成的集群中挑选出一个进行调用，就涉及到一个负载均衡的策略。</p>
<hr>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><p>在讨论负载均衡之前，我想先解释一下这3个概念。</p>
<ol>
<li>负载均衡</li>
<li>集群容错</li>
<li>服务路由</li>
</ol>
<p>这3个概念容易混淆。他们都描述了怎么从多个 Provider 中选择一个来进行调用。那他们到底有什么区别呢?下面我来举一个简单的例子，把这几个概念阐述清楚吧。</p>
<p>有一个Dubbo的用户服务，在北京部署了10个，在上海部署了20个。一个杭州的服务消费方发起了一次调用，然后发生了以下的事情:</p>
<ol>
<li>根据配置的路由规则，如果杭州发起的调用，会路由到比较近的上海的20个 Provider。</li>
<li>根据配置的随机负载均衡策略，在20个 Provider 中随机选择了一个来调用，假设随机到了第7个 Provider。</li>
<li>结果调用第7个 Provider 失败了。</li>
<li>根据配置的Failover集群容错模式，重试其他服务器。</li>
<li>重试了第13个 Provider，调用成功。</li>
</ol>
<p>上面的第1，2，4步骤就分别对应了路由，负载均衡和集群容错。 Dubbo中，先通过路由，从多个 Provider 中按照路由规则，选出一个子集。再根据负载均衡从子集中选出一个 Provider 进行本次调用。如果调用失败了，根据集群容错策略，进行重试或定时重发或快速失败等。 可以看到Dubbo中的路由，负载均衡和集群容错发生在一次RPC调用的不同阶段。最先是路由，然后是负载均衡，最后是集群容错。 本文档只讨论负载均衡，路由和集群容错在其他的文档中进行说明。</p>
<h2 id="Dubbo内置负载均衡策略"><a href="#Dubbo内置负载均衡策略" class="headerlink" title="Dubbo内置负载均衡策略"></a>Dubbo内置负载均衡策略</h2><p>Dubbo内置了4种负载均衡策略:</p>
<ol>
<li>RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的<strong>默认</strong>负载均衡策略。</li>
<li>RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。</li>
<li>LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。</li>
<li>ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。</li>
</ol>
<h3 id="1-随机负载均衡"><a href="#1-随机负载均衡" class="headerlink" title="1.随机负载均衡"></a>1.随机负载均衡</h3><p>顾名思义，随机负载均衡策略就是从多个 Provider 中随机选择一个。但是 Dubbo 中的随机负载均衡有一个权重的概念，即按照权重设置随机概率。比如说，有10个 Provider，并不是说，每个 Provider 的概率都是一样的，而是要结合这10个 Provider 的权重来分配概率。</p>
<p>Dubbo中，可以对 Provider 设置权重。比如机器性能好的，可以设置大一点的权重，性能差的，可以设置小一点的权重。权重会对负载均衡产生影响。可以在Dubbo Admin中对 Provider 进行权重的设置。</p>
<p><strong>基于权重的负载均衡算法</strong></p>
<p>随机策略会先判断所有的 Invoker 的权重是不是一样的，如果都是一样的，那么处理就比较简单了。使用random.nexInt(length)就可以随机生成一个 Invoker 的序号,根据序号选择对应的 Invoker 。如果没有在Dubbo Admin中对服务 Provider 设置权重，那么所有的 Invoker 的权重就是一样的，默认是100。 如果权重不一样，那就需要结合权重来设置随机概率了。算法大概如下： 假如有4个 Invoker。</p>
<img src="/2023/05/23/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/05/23/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/v2-28b41cd3916d26b04a3231216e0a5eba_720w.webp" class title="img">

<p>A，B，C和D总的权重是10 + 20 + 20 + 30 &#x3D; 80。将80个数分布在如下的图中:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------------------------------------------+</span><br><span class="line">|          |                    |                    |                              |</span><br><span class="line">+-----------------------------------------------------------------------------------+</span><br><span class="line">1          10                   30                   50                             80</span><br><span class="line"></span><br><span class="line">|-----A----|---------B----------|----------C---------|---------------D--------------|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------15</span><br><span class="line"></span><br><span class="line">-------------------------------------------37</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------54</span><br></pre></td></tr></table></figure>

<p>上面的图中一共有4块区域，长度分别是A，B，C和D的权重。使用random.nextInt(10 + 20 + 20 + 30)，从80个数中随机选择一个。然后再判断该数分布在哪个区域。比如，如果随机到37，37是分布在C区域的，那么就选择 Invoker C。15是在B区域，54是在D区域。</p>
<p><strong>随机负载均衡源码</strong></p>
<p>下面是随机负载均衡的源码，为了方便阅读和理解，我把无关部分都去掉了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> invokers.size();      <span class="comment">// Invoker 总数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>;               <span class="comment">// 所有 Invoker 的权重的和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是不是所有的 Invoker 的权重都是一样的</span></span><br><span class="line">        <span class="comment">// 如果权重都一样，就简单了。直接用Random生成索引就可以了。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sameWeight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> getWeight(invokers.get(i), invocation);</span><br><span class="line">            totalWeight += weight; <span class="comment">// Sum</span></span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; weight != getWeight(invokers.get(i - <span class="number">1</span>), invocation)) &#123;</span><br><span class="line">                sameWeight = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 如果不是所有的 Invoker 权重都相同，那么基于权重来随机选择。权重越大的，被选中的概率越大</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> random.nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                offset -= getWeight(invokers.get(i), invocation);</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有 Invoker 权重相同</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(random.nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-轮询负载均衡"><a href="#2-轮询负载均衡" class="headerlink" title="2.轮询负载均衡"></a>2.轮询负载均衡</h3><p>轮询负载均衡，就是依次的调用所有的 Provider。和随机负载均衡策略一样，轮询负载均衡策略也有权重的概念。 轮询负载均衡算法可以让RPC调用严格按照我们设置的比例来分配。不管是少量的调用还是大量的调用。但是轮询负载均衡算法也有不足的地方，存在慢的 Provider 累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上，导致整个系统变慢。</p>
<h3 id="3-最少活跃调用数负载均衡"><a href="#3-最少活跃调用数负载均衡" class="headerlink" title="3.最少活跃调用数负载均衡"></a>3.最少活跃调用数负载均衡</h3><p>官方解释：</p>
<blockquote>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差，使慢的机器收到更少。</p>
</blockquote>
<p>这个解释好像说的不是太明白。目的是让更慢的机器收到更少的请求，但具体怎么实现的还是不太清楚。举个例子：每个服务维护一个活跃数计数器。当A机器开始处理请求，该计数器加1，此时A还未处理完成。若处理完毕则计数器减1。而B机器接受到请求后很快处理完毕。那么A,B的活跃数分别是1，0。当又产生了一个新的请求，则选择B机器去执行(B活跃数最小)，这样使慢的机器A收到少的请求。</p>
<p>处理一个新的请求时，Consumer 会检查所有 Provider 的活跃数，如果具有最小活跃数的 Invoker 只有一个，直接返回该 Invoker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果只有一个最小则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> invokers.get(leastIndexs[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果最小活跃数的 Invoker 有多个，且权重不相等同时总权重大于0，这时随机生成一个权重，范围在 (0，totalWeight) 间内。最后根据随机生成的权重，来选择 Invoker。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果权重不相同且权重大于0则按总权重数随机</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offsetWeight</span> <span class="operator">=</span> random.nextInt(totalWeight);</span><br><span class="line">    <span class="comment">// 并确定随机值落在哪个片断上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leastIndex</span> <span class="operator">=</span> leastIndexs[i];</span><br><span class="line">        offsetWeight -= getWeight(invokers.get(leastIndex), invocation);</span><br><span class="line">        <span class="keyword">if</span> (offsetWeight &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-一致性Hash算法"><a href="#4-一致性Hash算法" class="headerlink" title="4.一致性Hash算法"></a>4.一致性Hash算法</h3><p>使用一致性 Hash 算法，让相同参数的请求总是发到同一 Provider。 当某一台 Provider 崩溃时，原本发往该 Provider 的请求，基于虚拟节点，平摊到其它 Provider，不会引起剧烈变动。 算法参见：<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a>。</p>
<p>缺省只对第一个参数Hash，如果要修改，请配置:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>缺省用160份虚拟节点，如果要修改，请配置:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>一致性Hash算法可以和缓存机制配合起来使用。比如有一个服务getUserInfo(String userId)。设置了Hash算法后，相同的userId的调用，都会发送到同一个 Provider。这个 Provider 上可以把用户数据在内存中进行缓存，减少访问数据库或分布式缓存的次数。如果业务上允许这部分数据有一段时间的不一致，可以考虑这种做法。减少对数据库，缓存等中间件的依赖和访问次数，同时减少了网络IO操作，提高系统性能。</p>
<h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><p>如果不指定负载均衡，默认使用随机负载均衡。我们也可以根据自己的需要，显式指定一个负载均衡。 可以在多个地方类来配置负载均衡，比如 Provider 端，Consumer端，服务级别，方法级别等。</p>
<h3 id="服务端服务级别"><a href="#服务端服务级别" class="headerlink" title="服务端服务级别"></a>服务端服务级别</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>该服务的所有方法都使用roundrobin负载均衡。</p>
<h3 id="客户端服务级别"><a href="#客户端服务级别" class="headerlink" title="客户端服务级别"></a>客户端服务级别</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>该服务的所有方法都使用roundrobin负载均衡。</p>
<h3 id="服务端方法级别"><a href="#服务端方法级别" class="headerlink" title="服务端方法级别"></a>服务端方法级别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service interface=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;hello&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br></pre></td></tr></table></figure>

<p>只有该服务的hello方法使用roundrobin负载均衡。</p>
<h3 id="客户端方法级别"><a href="#客户端方法级别" class="headerlink" title="客户端方法级别"></a>客户端方法级别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference interface=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;hello&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure>

<p>只有该服务的hello方法使用roundrobin负载均衡。</p>
<p>和Dubbo其他的配置类似，多个配置是有覆盖关系的：</p>
<ol>
<li>方法级优先，接口级次之，全局配置再次之。</li>
<li>如果级别一样，则消费方优先，提供方次之。</li>
</ol>
<p>所以，上面4种配置的优先级是:</p>
<ol>
<li>客户端方法级别配置。</li>
<li>客户端接口级别配置。</li>
<li>服务端方法级别配置。</li>
<li>服务端接口级别配置。</li>
</ol>
<h2 id="扩展负载均衡"><a href="#扩展负载均衡" class="headerlink" title="扩展负载均衡"></a>扩展负载均衡</h2><p>Dubbo的4种负载均衡的实现，大多数情况下能满足要求。有时候，因为业务的需要，我们可能需要实现自己的负载均衡策略。本章只说明如何配置负载均衡算法。关于Dubbo扩展机制的更多内容，请前往<a href="https://link.zhihu.com/?target=https://lark.alipay.com/aliware_articles/vtpf9h/pe9pyr">Dubbo可扩展机制实战</a>。</p>
<ol>
<li>实现LoadBalance接口, 以下是Dubbo的LoadBalance接口:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(RandomLoadBalance.NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="meta">@Adaptive(&quot;loadbalance&quot;)</span></span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是SPI的接口，select方法的参数如下:</p>
<ul>
<li>invokers: 所有的服务 Provider 列表。</li>
<li>url: 一些配置信息，比如接口名，是否check，序列化方式。</li>
<li>invocation: RPC调用的信息，包括方法名，方法参数类型，方法参数。 下面是我们自己实现的一个LoadBalance，实现很简单，选择第一个 Invoker:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.dubbo;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoLoadBalance</span> <span class="keyword">implements</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[DemoLoadBalance]Select the first invoker...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>添加资源文件 添加文件:<code>src/main/resource/META-INF/dubbo/com.alibaba.dubbo.rpc.cluster.LoadBalance</code>。这是一个简单的文本文件。文件内容如下:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo=my=com.demo.dubbo.DemoLoadBalance</span><br></pre></td></tr></table></figure>

<ol>
<li>配置使用自定义LoadBalance</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference id=&quot;helloService&quot; interface=&quot;com.demo.dubbo.api.IHelloService&quot; loadbalance=&quot;demo&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>在Consumer端的<code>dubbo:reference</code>中配置<code>&lt;loadbalance=&quot;demo&quot;&gt;</code></p>
<p>经过上面的3个步骤，我们编写了一个自定义的LoadBalance，并告诉Dubbo使用它了。启动Dubbo，我们就能看到Dubbo已经使用了自定义的DemoLoadBalance。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/21/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional-%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional-%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">事务注解@Transactional 失效的3种场景及解决办法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-21 20:05:44" itemprop="dateCreated datePublished" datetime="2023-05-21T20:05:44+08:00">2023-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-22 16:27:06" itemprop="dateModified" datetime="2023-05-22T16:27:06+08:00">2023-05-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@Transactional 这个是Spring中常用的事物注解，如果事物运行失败，则进行回滚，那么偶尔会遇到这个注解失效的情况，下面进行分析</p>
<hr>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>@Transactional</code> 注解相信大家并不陌生，平时开发中很常用的一个注解，它能保证方法内多个数据库操作要么同时成功、要么同时失败。使用<code>@Transactional</code>注解时需要注意许多的细节，不然你会发现<code>@Transactional</code>总是莫名其妙的就失效了。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务管理在系统开发中是不可缺少的一部分，<code>Spring</code>提供了很好事务管理机制，主要分为<code>编程式事务</code>和<code>声明式事务</code>两种。</p>
<p><strong>编程式事务</strong>：是指在代码中手动的管理事务的提交、回滚等操作，代码侵入性比较强，如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TODO something</span></span><br><span class="line">     transactionManager.commit(status);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    transactionManager.rollback(status);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvoiceApplyException</span>(<span class="string">&quot;异常失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>声明式事务</strong>：基于<code>AOP</code>面向切面的，它将具体业务与事务处理部分解耦，代码侵入性很低，所以在实际开发中声明式事务用的比较多。声明式事务也有两种实现方式，一是基于<code>TX</code>和<code>AOP</code>的xml配置文件方式，二种就是基于@Transactional注解了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">  	<span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">       <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Transactional介绍"><a href="#Transactional介绍" class="headerlink" title="@Transactional介绍"></a>@Transactional介绍</h1><h2 id="1、-Transactional注解可以作用于哪些地方？"><a href="#1、-Transactional注解可以作用于哪些地方？" class="headerlink" title="1、@Transactional注解可以作用于哪些地方？"></a>1、@Transactional注解可以作用于哪些地方？</h2><p>@Transactional 可以作用在<code>接口</code>、<code>类</code>、<code>类方法</code>。</p>
<ul>
<li><strong>作用于类</strong>：当把@Transactional 注解放在类上时，表示所有该类的<code>public</code>方法都配置相同的事务属性信息。</li>
<li><strong>作用于方法</strong>：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。</li>
<li><strong>作用于接口</strong>：不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CityInfoDictMapper cityInfoDictMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setCityLevel(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setCityCode(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">        <span class="keyword">return</span> insert + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、-Transactional注有哪些属性？"><a href="#2、-Transactional注有哪些属性？" class="headerlink" title="2、@Transactional注有哪些属性？"></a>2、@Transactional注有哪些属性？</h2><h3 id="propagation属性"><a href="#propagation属性" class="headerlink" title="propagation属性"></a><strong>propagation属性</strong></h3><p><code>propagation</code> 代表事务的传播行为，默认值为 <code>Propagation.REQUIRED</code>，其他的属性信息如下：</p>
<ul>
<li><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。**(** 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></li>
<li><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</li>
<li><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li>
<li><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。**(** 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></li>
<li><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</li>
<li><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</li>
<li><code>Propagation.NESTED</code> ：和 Propagation.REQUIRED 效果一样。</li>
</ul>
<h5 id="isolation-属性"><a href="#isolation-属性" class="headerlink" title="isolation 属性"></a><strong>isolation 属性</strong></h5><p><code>isolation</code> ：事务的隔离级别，默认值为 <code>Isolation.DEFAULT</code>。</p>
<ul>
<li>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</li>
<li>Isolation.READ_UNCOMMITTED</li>
<li>Isolation.READ_COMMITTED</li>
<li>Isolation.REPEATABLE_READ</li>
<li>Isolation.SERIALIZABLE</li>
</ul>
<h5 id="timeout-属性"><a href="#timeout-属性" class="headerlink" title="timeout 属性"></a><strong>timeout 属性</strong></h5><p><code>timeout</code> ：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p>
<h5 id="readOnly-属性"><a href="#readOnly-属性" class="headerlink" title="readOnly 属性"></a><strong>readOnly 属性</strong></h5><p><code>readOnly</code> ：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p>
<h5 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a><strong>rollbackFor 属性</strong></h5><p><code>rollbackFor</code> ：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p>
<h5 id="noRollbackFor属性"><a href="#noRollbackFor属性" class="headerlink" title="noRollbackFor属性**"></a><strong>noRollbackFor</strong>属性**</h5><p><code>noRollbackFor</code>：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</p>
<h1 id="Transactional失效场景"><a href="#Transactional失效场景" class="headerlink" title="@Transactional失效场景"></a>@Transactional失效场景</h1><p>接下来我们结合具体的代码分析一下哪些场景下，@Transactional 注解会失效。</p>
<h4 id="1、-Transactional-应用在非-public-修饰的方法上"><a href="#1、-Transactional-应用在非-public-修饰的方法上" class="headerlink" title="1、@Transactional 应用在非 public 修饰的方法上"></a>1、@Transactional 应用在非 public 修饰的方法上</h4><p>如果<code>Transactional</code>注解应用在非<code>public</code> 修饰的方法上，Transactional将会失效。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/19/170f0e025a51a1b4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<p>之所以会失效是因为在Spring AOP 代理时，如上图所示 <code>TransactionInterceptor</code> （事务拦截器）在目标方法执行前后进行拦截，<code>DynamicAdvisedInterceptor</code>（CglibAopProxy 的内部类）的 intercept 方法或 <code>JdkDynamicAopProxy</code> 的 invoke 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>的 <code>computeTransactionAttribute</code> 方法，获取Transactional 注解的事务配置信息。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">oxygene复制代码<span class="keyword">protected</span> TransactionAttribute computeTransactionAttribute(<span class="keyword">Method</span> <span class="title function_">method</span>,</span><br><span class="line">    <span class="title function_">Class</span>&lt;?&gt; <span class="title function_">targetClass</span>) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">        // Don&#x27;t allow no-public methods as required.</span></span><br><span class="line"><span class="comment">        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p>
<p><strong>注意：<code>protected</code>、<code>private</code> 修饰的方法上使用 <code>@Transactional</code> 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</strong></p>
<h4 id="2、-Transactional-注解属性-propagation-设置错误"><a href="#2、-Transactional-注解属性-propagation-设置错误" class="headerlink" title="2、@Transactional 注解属性 propagation 设置错误"></a>2、@Transactional 注解属性 propagation 设置错误</h4><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p>
<p><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 <code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 <code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</p>
<h4 id="3、-Transactional-注解属性-rollbackFor-设置错误"><a href="#3、-Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="3、@Transactional  注解属性 rollbackFor 设置错误"></a>3、@Transactional  注解属性 rollbackFor 设置错误</h4><p><code>rollbackFor</code> 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查<code>unchecked</code>异常（继承自 <code>RuntimeException</code> 的异常）或者 <code>Error</code>才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 <strong>rollbackFor</strong>属性。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/19/170f0e025b17b3ca~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stylus复制代码<span class="comment">// 希望自定义的异常可以进行回滚</span></span><br><span class="line">@<span class="built_in">Transactional</span>(propagation= Propagation<span class="selector-class">.REQUIRED</span>,rollbackFor= MyException.class</span><br></pre></td></tr></table></figure>

<p>若在目标方法中抛出的异常是 <code>rollbackFor</code> 指定的异常的子类，事务同样会回滚。Spring源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(Class&lt;?&gt; exceptionClass, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (exceptionClass.getName().contains(<span class="built_in">this</span>.exceptionName)) &#123;</span><br><span class="line">            <span class="comment">// Found it!</span></span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// If we&#x27;ve gone as far as we can go and haven&#x27;t found it...</span></span><br><span class="line">        <span class="keyword">if</span> (exceptionClass == Throwable.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getDepth(exceptionClass.getSuperclass(), depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、同一个类中方法调用，导致-Transactional失效"><a href="#4、同一个类中方法调用，导致-Transactional失效" class="headerlink" title="4、同一个类中方法调用，导致@Transactional失效"></a>4、同一个类中方法调用，导致@Transactional失效</h4><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p>
<p>那为啥会出现这种情况？其实这还是由于使用<code>Spring AOP</code>代理造成的，因为只有<strong>当事务方法被当前类以外的代码调用</strong>时，才会由<code>Spring</code>生成的代理对象来管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Transactional</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">this</span>.insertB();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> insert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional()</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">insertB</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、异常被你的-catch“吃了”导致-Transactional失效"><a href="#5、异常被你的-catch“吃了”导致-Transactional失效" class="headerlink" title="5、异常被你的 catch“吃了”导致@Transactional失效"></a>5、异常被你的 catch“吃了”导致@Transactional失效</h4><p>这种情况是最常见的一种@Transactional注解失效场景，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">            cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            b.insertB();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p>
<p>答案：看具体的情况，如果B本身也有事务注解，那么会回滚。</p>
<p>请参考下面的截图分析</p>
<p><img src="/2023/05/21/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional-%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/df52c75a5a884709aff63c3f4134ebff~tplv-k3u1fbpfcp-zoom-1.awebp" alt="img"></p>
<p>会抛出异常：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.<span class="keyword">transaction</span>.UnexpectedRollbackException: <span class="keyword">Transaction</span> rolled back because it has been marked <span class="keyword">as</span> <span class="keyword">rollback</span>-<span class="keyword">only</span></span><br></pre></td></tr></table></figure>

<p>因为当<code>ServiceB</code>中抛出了一个异常以后，<code>ServiceB</code>标识当前事务需要<code>rollback</code>。但是<code>ServiceA</code>中由于你手动的捕获这个异常并进行处理，<code>ServiceA</code>认为当前事务应该正常<code>commit</code>。此时就出现了前后不一致，也就是因为这样，抛出了前面的<code>UnexpectedRollbackException</code>异常。</p>
<p><code>spring</code>的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行<code>commit</code> or <code>rollback</code>，事务是否执行取决于是否抛出<code>runtime异常</code>。如果抛出<code>runtime exception</code> 并在你的业务方法中没有catch到的话，事务会回滚。</p>
<p>在业务方法中一般不需要catch异常，如果非要catch一定要抛出<code>throw new RuntimeException()</code>，或者注解中指定抛异常类型<code>@Transactional(rollbackFor=Exception.class)</code>，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p>
<h4 id="6、数据库引擎不支持事务"><a href="#6、数据库引擎不支持事务" class="headerlink" title="6、数据库引擎不支持事务"></a>6、数据库引擎不支持事务</h4><p>这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的<code>innodb</code>引擎。一旦数据库引擎切换成不支持事务的<code>myisam</code>，那事务就从根本上失效了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>@Transactional 注解的看似简单易用，但如果对它的用法一知半解，还是会踩到很多坑的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">消息队列产生严重消息堆积怎么处理?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-21 19:01:00" itemprop="dateCreated datePublished" datetime="2023-05-21T19:01:00+08:00">2023-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-22 16:32:03" itemprop="dateModified" datetime="2023-05-22T16:32:03+08:00">2023-05-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么产生消息堆积？"><a href="#为什么产生消息堆积？" class="headerlink" title="为什么产生消息堆积？"></a>为什么产生消息堆积？</h2><p>大多是因为 Consumer 出问题了，没有及时发现，或者故障恢复需要较长的时间，导致大量消息积压在 MQ 中。</p>
<h2 id="消息堆积会有什么后果呢？"><a href="#消息堆积会有什么后果呢？" class="headerlink" title="消息堆积会有什么后果呢？"></a>消息堆积会有什么后果呢？</h2><h3 id="消息被丢弃"><a href="#消息被丢弃" class="headerlink" title="消息被丢弃"></a>消息被丢弃</h3><p>例如 RabbitMQ 有一个消息过期时间 TTL，过期的消息会被扔掉，这样消息就彻底没有了。</p>
<h3 id="磁盘满了"><a href="#磁盘满了" class="headerlink" title="磁盘满了"></a>磁盘满了</h3><p>如果堆积量太大，可能导致磁盘空间不足，那么新消息就进不来了。</p>
<h3 id="海量消息待处理"><a href="#海量消息待处理" class="headerlink" title="海量消息待处理"></a>海量消息待处理</h3><p>如果消息没过期，并且磁盘空间也够用，那么就是产生海量消息等待被消费，Consumer 的噩梦。</p>
<h2 id="如何应对呢？"><a href="#如何应对呢？" class="headerlink" title="如何应对呢？"></a>如何应对呢？</h2><h3 id="消息被丢弃的情况"><a href="#消息被丢弃的情况" class="headerlink" title="消息被丢弃的情况"></a>消息被丢弃的情况</h3><p>首先，要实现防止消息过期问题，不应该设置过期时间。</p>
<p>如果就是设置了过期时间，导致了消息丢失，怎么补救呢？</p>
<p>那就只能在夜深人静，趁着访问量最低的时候，写一个临时程序来补消息了。</p>
<p>例如有订单消息丢了，那就需要找出哪些订单消息丢了，然后重新发到队列。</p>
<h3 id="磁盘不足的情况"><a href="#磁盘不足的情况" class="headerlink" title="磁盘不足的情况"></a>磁盘不足的情况</h3><p>系统通常都是有监控的，达到空间阈值时就会发警报，这时就要马上处理了。</p>
<img src="/2023/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/v2-5dc767965bf2b813bafecd51e13ed41c_720w.webp" class title="img">



<p>例如，在其他机器上创建临时的消息队列，再写一个临时的 Consumer，作为消息的中转，把消息积压队列中的消息取出来，放到临时队列里面去。</p>
<p>快速疏散积压的消息，让磁盘空间恢复正常水平。</p>
<h3 id="快速处理海量积压消息"><a href="#快速处理海量积压消息" class="headerlink" title="快速处理海量积压消息"></a>快速处理海量积压消息</h3><p>Consumer 恢复正常之后，面对堆积如山的消息，怎么处理呢？</p>
<p>如何按照之前正常情况处理的话，猴年马月才能消费完，此过程中还有新消息在不断进来。</p>
<p>例如，积压了 100 万条，有 3 个 Consumer，每一个每秒能处理 200 条，3 个 Consumer 每秒一共能处理 600 条。</p>
<p>大概需要一个多小时才能处理完。</p>
<p>这一个多小时又会积压多少新的消息呢？</p>
<p>所以正常处理肯定不行，需要提速。</p>
<p>例如 Kafka，这个消息积压的 Topic 有 3 个 Partition，那最多就能用 3 个 Consumer，所以增加 Consumer 没有用。</p>
<p>还是可以使用<strong>临时队列</strong>的方式。</p>
<img src="/2023/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/v2-8a6a18065863900773f1491c82af4884_720w.webp" class title="img">



<p>新建一个 Topic，设置为 20 个 Partition</p>
<p>Consumer 不再处理业务逻辑了，只负责搬运，把消息放到临时 Topic 中</p>
<p>这 20 个 Partition 可以有 20个 Consumer 了，它们来处理原来的业务逻辑。</p>
<p>这 20 个 Consumer 每秒一共能处理 4000 条了，这样几分钟就可以处理完积压的 100 万条。</p>
<p>这几分钟新来的消息也不会太多，所以很快就可以恢复正常水平，之后，再把整体结构恢复为原来的形式。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>消息积压还是比较麻烦的，最好是提前防范，做好硬件和消息系统的健康监控。如果出现消息丢失，就要人工查找丢失的消息，然后补上。在消费不过来的时候，可以考虑使用临时队列作为中转，提升处理能力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%90%9E%E6%87%82wait()%E5%92%8Cjoin()%E7%9A%84%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%90%9E%E6%87%82wait()%E5%92%8Cjoin()%E7%9A%84%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">多线程：搞懂 wait() 和 join()的关系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-21 15:33:31 / Modified: 18:47:51" itemprop="dateCreated datePublished" datetime="2023-05-21T15:33:31+08:00">2023-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>多线程：因为上一篇文章join中提到了wait，容易搞混谁等待，谁运行的关系，这篇文章来彻底讲解一下两者的对比</p>
<hr>
<h1 id="前置知识-线程状态"><a href="#前置知识-线程状态" class="headerlink" title="前置知识:线程状态"></a>前置知识:线程状态</h1><p>   public enum State {</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    NEW,</span><br><span class="line"> </span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br><span class="line">**NEW (初始):** 新创建线程对象，但还没有调用 start() 方法</span><br><span class="line">**RUNNABLE (运行):** java 把 就绪 (ready) 和运行 (running) 一起归属于runnable。线程对象创建后，被其它的线程（如: main线程）调用start() 方法。该线程就处于就绪（ready）状态进入可运行线程池中，等待cpu线程调度。就绪状态的线程获得cpu时间片后变为 运行状态 (running)</span><br><span class="line">**BLOCKED (阻塞) :** 线程阻塞于锁</span><br><span class="line">**WAITING（等待) :** 线程等待其它线程唤醒</span><br><span class="line">**TIMED_WAITING (超时等待) :** 该状态不同于WAITING，它可以在指定的时间后自行返回。</span><br><span class="line">**TERMINATED (终止) ：**该线程执行完毕</span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%90%9E%E6%87%82wait()%E5%92%8Cjoin()%E7%9A%84%E5%85%B3%E7%B3%BB/1ea3223fe421ffdf6575a2d304cc4be5.png" alt="线程流转变动"></p>
<h1 id="wait-详解"><a href="#wait-详解" class="headerlink" title="wait() 详解"></a>wait() 详解</h1><p><strong>wait() notify() notifyAll()</strong> 都是 Object类的方法，使用这三个方法的前提是先获得该对象的锁。</p>
<p>调用 wait 方法后，释放持有的对象锁，线程状态有 Running 变为 Waiting，并将当前线程放置到对象的 等待队列；<br>调用notify 或者 notifyAll 方法后，等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回；<br><strong>notify</strong> 方法：将等待队列的一个等待线程从等待队列种移到同步队列中 ，<br><strong>notifyAll</strong> 方法：将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked。<br><strong>等待队列（等待池） 同步队列（锁池）</strong></p>
<p><strong>同步队列（锁池）</strong>：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked。</p>
<p><strong>等待队列（等待池）</strong>：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时 线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting。如果另外的一个线程调用了相同对象的notifyAll()方法，那么 处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么 仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）。</p>
<h1 id="深入join"><a href="#深入join" class="headerlink" title="深入join()"></a>深入join()</h1><p>join() : 保证线程的执行顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        MyThread1 t=<span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;运行&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;执行！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>一句话总结: <strong>让获得这个线程锁（t1）的线程(main) 等待，t1 执行完再唤醒线程(main)，这样就保证了执行顺序。</strong></p>
<p>看完下面的分析就可以更好理解上面的总结</p>
<p>JDK中 join() 的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span>    <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;  </span><br><span class="line">       wait(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;  </span><br><span class="line">        <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        wait(delay);  </span><br><span class="line">        now = System.currentTimeMillis() - base;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>join的实现就是调用wait()方法。</p>
<p>wait() 方法源码&#96;&#96;public final native void wait(long timeout) throws InterruptedException;&#96;<br>该方法为本地方法，调用此方法的当前线程需要释放锁，并等待唤醒。在上述例子中，主线程调用子线程对象的join()方法，因此主线程在此位置需要释放锁，并进行等待。</p>
<p>main线程运行，运行到t.join(等待时间)时，相当于运行 t.wait()，main线程获得线程对象 t 的锁，调用wait(等待时间)方法，main线程又释放掉 线程对象t 的锁，从 running变为 blocked 进入等待队列，等待线程对象t唤醒。</p>
<p><strong>那么join()方法在什么时候唤醒 main线程？</strong></p>
<p>查看Thread类中存在exit()方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * This method is called by the system to give a Thread</span></span><br><span class="line"><span class="comment">      a chance to clean up before it actually exits.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * 这个方法由系统调用，当该线程完全退出前给它一个机会去释放空间。</span></span><br><span class="line"><span class="comment">          /</span></span><br><span class="line"><span class="comment">          private void exit() &#123;</span></span><br><span class="line"><span class="comment">          if (group != null) &#123;                //线程组在Thread初始化时创建，存有创建的子线程</span></span><br><span class="line"><span class="comment">              group.threadTerminated(this);   //调用threadTerminated()方法</span></span><br><span class="line"><span class="comment">              group = null;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">          /* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">          target = <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">          threadLocals = <span class="literal">null</span>;</span><br><span class="line">          inheritableThreadLocals = <span class="literal">null</span>;</span><br><span class="line">          inheritedAccessControlContext = <span class="literal">null</span>;</span><br><span class="line">          blocker = <span class="literal">null</span>;</span><br><span class="line">          uncaughtExceptionHandler = <span class="literal">null</span>;</span><br><span class="line">          </span><br><span class="line">          </span><br></pre></td></tr></table></figure>

<p>   *<br>        exit()在线程执行完run()方法之后会被调用，此时线程组中存在当前子线程，因此会调用线程组的threadTerminated()方法。 查看ThreadGroup.threadTerminated()方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is called by the system to give a Thread</span></span><br><span class="line"><span class="comment">     * a chance to clean up before it actually exits.</span></span><br><span class="line"><span class="comment">     * 这个方法由系统调用，当该线程完全退出前给它一个机会去释放空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="literal">null</span>) &#123;                <span class="comment">//线程组在Thread初始化时创建，存有创建的子线程</span></span><br><span class="line">            group.threadTerminated(<span class="built_in">this</span>);   <span class="comment">//调用threadTerminated()方法</span></span><br><span class="line">            group = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">        target = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">        threadLocals = <span class="literal">null</span>;</span><br><span class="line">        inheritableThreadLocals = <span class="literal">null</span>;</span><br><span class="line">        inheritedAccessControlContext = <span class="literal">null</span>;</span><br><span class="line">        blocker = <span class="literal">null</span>;</span><br><span class="line">        uncaughtExceptionHandler = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>通知线程组，t线程已经终止。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    /** Notifies the group that the thread &#123;@code t&#125; has terminated.</span><br><span class="line">      * 通知线程组，t线程已经终止。</span><br><span class="line">*/</span><br><span class="line">    void threadTerminated(Thread t) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                remove(t);                          //从线程组中删除此线程</span><br><span class="line">    </span><br><span class="line">                if (nthreads == 0) &#123;                //当线程组中线程数为0时</span><br><span class="line">                    notifyAll();                    //唤醒所有待定中的线程</span><br><span class="line">                &#125;</span><br><span class="line">                if (daemon &amp;&amp; (nthreads == 0) &amp;&amp;</span><br><span class="line">                    (nUnstartedThreads == 0) &amp;&amp; (ngroups == 0))</span><br><span class="line">              &#123;</span><br><span class="line">                  destroy();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>


<p>​<br>​    通过此方法，将子线程从线程组中删除，并唤醒其他等待的线程。在上述例子中，此时子线程被销毁，并释放占用的资源，并唤醒等待中的线程。而在join()方法中等待的主线程被唤醒，并获得锁，继续往下执行 t.join() 后面的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">详解java Thread中的join方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-21 15:18:40 / Modified: 15:55:01" itemprop="dateCreated datePublished" datetime="2023-05-21T15:18:40+08:00">2023-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="join-方法作用与原理"><a href="#join-方法作用与原理" class="headerlink" title="join()方法作用与原理"></a>join()方法作用与原理</h1><ol>
<li>join()的作用</li>
<li>join()的原理</li>
<li>总结</li>
</ol>
<h2 id="join-的作用"><a href="#join-的作用" class="headerlink" title="join()的作用"></a>join()的作用</h2><p> <code>join()</code>是 Thread 类中的一个方法，当我们需要让线程按照自己指定的顺序执行的时候，就可以利用这个方法。<strong>「<code>Thread.join()</code>方法表示调用此方法的线程被阻塞，仅当该方法完成以后，才能继续运行」</strong>。</p>
<blockquote>
<p>❝ 作用于 main( )主线程时，会等待其他线程结束后再结束主线程。<br>❞</p>
</blockquote>
<p><strong>「示例」</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread t1 run&quot;</span>);</span><br><span class="line">            count=<span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();<span class="comment">//若把这一行注释掉，则打印的count为0</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 run</span><br><span class="line">count=10</span><br></pre></td></tr></table></figure>

<p>说明在调用<code>t1.join( )</code>方法以后，<code>main()</code>的线程被阻塞，等到<code>t1</code>线程完成以后，<code>main()</code>线程再结束。</p>
<img src="/2023/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/v2-cac99aa740e47b608880c65cb24cec83_720w.webp" class title="img">

<h2 id="join-方法的原理"><a href="#join-方法的原理" class="headerlink" title="join()方法的原理"></a>join()方法的原理</h2><blockquote>
<p>❝ 主要两点，线程如何被阻塞，线程又是如何被唤醒<br>❞</p>
</blockquote>
<p><code>join()</code>方法是<code>Thread</code>类中的，所以我们可以直接查看源码，找到<code>join()</code>方法，如下。</p>
<p>还有另外一个重载的方法，不过实际上调用的就是下图<code>join()</code>方法，只是参数为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;<span class="comment">//只要线程还没结束，主线程就会一直阻塞</span></span><br><span class="line">            wait(<span class="number">0</span>);<span class="comment">//这里的wait调用的本地方法。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//等待一段指定的时间</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 从源码来看，实际上<code>join</code>方法就是调用了<code>wait</code>方法来使得线程阻塞，一直到线程结束运行。注意到，<code>join</code>方法前的<code>synchronized</code>修饰符，它相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span>&#123;</span><br><span class="line"> <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="comment">//代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 也就是说加锁的对象即调用这个锁的线程对象，在<code>main()</code>方法中即为<code>t1</code>，持有这个锁的是主线程即<code>main()</code>方法，也就是说代码相当于如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t1.join()前的代码</span></span><br><span class="line"><span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line"> <span class="comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span></span><br><span class="line"> <span class="keyword">while</span> (t1.isAlive()) &#123;</span><br><span class="line">  t1.wait(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t1.join()后的代码</span></span><br></pre></td></tr></table></figure>

<p>也因此主线程进入等待队列，直到<code>t1</code>线程结束。</p>
<blockquote>
<p>❝ wait 方法被调用以后，是让持有锁的线程进入等待队列，即主线程，t1是被主线程持有的锁对象，因此 t1 线程并不会被阻塞。<br>❞</p>
</blockquote>
<p><strong>「那么问题在于，这里只看到了<code>wait</code>方法，却并没有看到<code>notify</code>或者是<code>notifyAll</code>方法，那么主线程在那里被唤醒呢」</strong>。</p>
<p>这里参考<code>jvm</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ensure_join</span><span class="params">(JavaThread* thread)</span> &#123;</span><br><span class="line"></span><br><span class="line"> Handle <span class="title function_">threadObj</span><span class="params">(thread, thread-&gt;threadObj()</span>);</span><br><span class="line"></span><br><span class="line"> ObjectLocker <span class="title function_">lock</span><span class="params">(threadObj, thread)</span>;</span><br><span class="line"></span><br><span class="line"> hread-&gt;clear_pending_exception();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//这一句中的TERMINATED表示这是线程结束以后运行的</span></span><br><span class="line"> java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里会清楚native线程，isAlive()方法会返回false</span></span><br><span class="line">    java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//thread就是当前线程，调用这个方法唤醒等待的线程。</span></span><br><span class="line"> lock.notify_all(thread);</span><br><span class="line"></span><br><span class="line"> hread-&gt;clear_pending_exception();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其实是<code>jvm</code>虚拟机中存在方法<code>lock.notify_all(thread)</code>，在<code>t1</code>线程结束以后，会调用该方法，最后唤醒主线程。</p>
<p> 所以简化一下，流程即：</p>
<img src="/2023/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/v2-8d1ed7f5621e6a4411486e8952b72139_720w.webp" class title="img">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要注意的其实就两点：</p>
<ol>
<li><code>wait</code>方法是使持有锁的线程进入等待队列，所以主线程会阻塞。</li>
<li>唤醒进程的方法位于<code>jvm</code>中，在线程（调用<code>join</code>方法的线程）结束后主线程被调用。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/21/CopyOnWriteArrayList%E7%9A%84%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%8F%96%E5%88%B0%E6%95%B0%E6%8D%AE%E6%98%AF%E6%9C%80%E6%96%B0%E7%9A%84%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/CopyOnWriteArrayList%E7%9A%84%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%8F%96%E5%88%B0%E6%95%B0%E6%8D%AE%E6%98%AF%E6%9C%80%E6%96%B0%E7%9A%84%EF%BC%9F/" class="post-title-link" itemprop="url">CopyOnWriteArrayList的机制如何保证读取到数据是最新的？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-21 14:37:16 / Modified: 14:47:25" itemprop="dateCreated datePublished" datetime="2023-05-21T14:37:16+08:00">2023-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CopyOnWriteArrayList是写时复制一个数组，读取的还是在原数组，那如何保证读取到数据是最新的</p>
<hr>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>很可惜，<strong>不能保证读到的数据一定是最新的</strong>，因为CopyOnWriteArrayList是弱数据一致性，具体的原因可以看一下这篇文章。</p>
<p>这篇文章想来跟大家来探讨一下，在Java中已经提供了并发安全的集合，为什么有的场景还需要使用<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%AF%BB%E5%86%99%E9%94%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">读写锁</a>，直接用并发安全的集合难道不行么？</p>
<p>在java中，并发安全的集合有很多，这里我就选用常见的CopyOnWriteArrayList为例，解决上述问题的同时，也来说明一下读写锁的价值到底提现在哪。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><em>CopyOnWriteArrayList核心源码分析</em>*</p>
<p>接下来我们分析一下CopyOnWriteArrayList核心的增删改查的方法</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">成员变量</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//底层用来存放元素的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<p>add方法：往集合中添加某个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>add操作先通过lock加锁，保证同一时刻最多只有一个线程可以操作。加锁成功获取到成员变量的数据，然后拷贝<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%95%B0%E7%BB%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">成员变量数组</a>的元素到新的数组，再基于新的数据来添加元素，最后将新拷贝的数组通过setArray来替换旧的成员变量的数组。</p>
<p>remove方法：移除集合中的某个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                                 numMoved);</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=remove&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">remove</a>操作也要先获取到锁。它先是取出对应数组下标的旧元素，然后新建了一个原数组长度减1的新数组，将除了被移除的元素之外，剩余的元素拷贝到新的数组，最后再通过setArray替换旧的成员变量的数组。</p>
<p>set方法：将集合中指定位置的元素替换成新的元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">            if (oldValue != element) &#123;</span><br><span class="line">                int len = elements.length;</span><br><span class="line">                Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">                newElements[index] = element;</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Not quite a no-op; ensures volatile write semantics</span><br><span class="line">                setArray(elements);</span><br><span class="line">            &#125;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>set方法跟add，remove操作一样得先获取到锁才能继续执行。将原数组的原有元素拷贝到新的数组上，在新的数组完成数据的替换，最后也是通过setArray替换旧的成员变量的数组。</p>
<p>size方法：获取集合中元素的个数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">        return getArray().length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size方法操作很简单，就是简单地返回一下当前数组的长度。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">迭代器</a>的构造</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造COWIterator的时候传入当前数组的对象，然后基于当前数组来遍历，也不需要加锁。</p>
<h1 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h1><p>讲完CopyOnWriteArrayList源码，我们可以看出CopyOnWriteArrayList的核心原理就是在对数组进行增删改的时候全部都是先加独占锁，然后对原有的数组进行拷贝，然后基于新复制的数组进行操作，最后将这个新的数组替换成员变量的数组；而对于读的操作来说，都是不加锁的，是基于当前成员变量的数组的这一时刻的快照来读的。其实CopyOnWriteArrayList是基于一种写时复制的思想，写的时候基于新拷贝的数组来操作，之后再赋值给成员变量，读的时候是原有的数组，这样读写其实就是不是同一个数组，这样就避免了读写冲突的情况，这其实也体现了一种<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">读写分离</a>的思想，读写操作的是不同的数组。</p>
<p><strong>CopyOnWriteArrayList适用场景</strong></p>
<p>接下来我们来思考一下，CopyOnWriteArrayList适合使用在什么样的场景中。通过上面源码的分析，我们可以看出，所有的写操作，包括增删改都需要加同一把独占锁，所以同时只允许一个线程对数组进行拷贝赋值的操作，多线程并发情况下所有的操作都是串行执行的，势必会导致并发能力降低，同时每次操作都涉及到了数组的拷贝，性能也不太好；而所有的读操作都不需要加锁，所以同一时间可以允许大量的线程同时读，并发性能高。所以综上我们可以得出一个结论，那就是CopyOnWriteArrayList适合读多写少的场景。</p>
<p><strong>CopyOnWriteArrayList的局限性</strong></p>
<p>说完CopyOnWriteArrayList，我们来想一想它有没有什么缺点。看起来CopyOnWriteArrayList除了写的并发性能差点，好像没有什么缺点了。的确，单从性能来看，确实是这种情况，但是，从数据一致性的角度来看，CopyOnWriteArrayList的数据一致性能力较弱，属于数据弱一致性。所谓的弱一致性，你可以这么理解，在某一个时刻，读到的数据并不是当前这一时刻最新的数据。</p>
<p>就拿CopyOnWriteArrayList举例来说，当有个线程A正在调用add方法来添加元素，此时已经完成了数组的拷贝，并且也将元素添加到数组中，但是还没有将新的数组赋值给成员变量，此时，另一个线程B来调用CopyOnWriteArrayList的size方法，来读取集合中元素的个数，那么此时读到的元素个数其实是不包括线程A要添加的元素，因为线程A并没有将新的数组赋值给成员变量，这就导致了线程B读到的数据不是最新的数据，也就是跟实际的数据不一致。</p>
<p>所以，从上面我们可以看出，CopyOnWriteArrayList对于数据一致性的保证，还是比较弱的。其实不光是CopyOnWriteArrayList，其实Java中的很多集合，队列的实现对于数据一致性的保证都比较弱。</p>
<p><strong>如何来保证数据的强一致性</strong></p>
<p>那么有什么好的办法可以保证数据的强一致性么？当然，保证并发安全，加锁就可以完成，但是加什么锁可以保证数据读写安全和数据一致性，其实最简单粗暴的方法就是对所有的读写都加上同一把独占锁，这样保证所有的读写操作都是串行执行，那么读的时候，其他线程一定不能写，那么读的一定是最新的数据。</p>
<p>如果真的这么去加独占锁，的确能够保证读写安全，但是性能却会很差，这也是为什么CopyOnWriteArrayList的读不加锁的原因，其实CopyOnWriteArrayList在设计的时候，就是降低数据一致性来换取读的性能。</p>
<p>那有没有什么折中的方法，既能保证读的性能不差，又能保证数据强一致性呢。这时就可以用读写锁来实现。所谓的读写锁，就是写的时候，其他线程不能写也不能读，读的时候，其他线程能读，但是不能写。也就是写写、读写互斥，但是读读不互斥。基于这种方式，就能保证读的时候，一定没有人在写，这样读到的数据就一定是最新的，同时也能保证其他线程也能读，不会出现上面举例的那种情况了，也就能保证数据的强一致性。读写锁相比独占锁而言，大大提高了读的并发能力，但是写的时候不能读，相比于CopyOnWriteArrayList而言，读的并发能力有所降低，这可能就是鱼（并发性能）和熊掌（数据一致性）不可兼得吧。</p>
<p>Java中也提供了读写锁的实现，ReentrantReadWriteLock，底层是基于AQS来实现的。有兴趣的小伙伴可以翻一下源码，看看是如何实现的，这里就不再剖析源码了。</p>
<p><strong>总结</strong></p>
<p>好了，通过这篇文章，想必大家知道为什么有并发安全的集合之后，还需要读写锁的原因，因为很多并发安全的集合对于数据一致性的保证是比较弱的，一旦遇到对于数据一致性要求比较高的场景，一些并发安全的集合就不适用了；同时为了避免独占锁带来的性能问题，可以选择读写锁来保证读的并发能力。小伙伴们在实际应用中需要根据应用场景来灵活地选择使用并发安全的集合、读写锁或者是独占锁，其实永远没有最好的选择，只有更好的选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/21/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%80%82%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%80%82%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F/" class="post-title-link" itemprop="url">如何在不适用锁的情况下解决高并发问题？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-21 13:34:40 / Modified: 15:01:56" itemprop="dateCreated datePublished" datetime="2023-05-21T13:34:40+08:00">2023-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试问题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>问题的原话是：如何在实际业务实现中不使用锁解决高并发问题，有没有相关的解决办法？</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>除了使用 synchronized、Lock 加锁之外，Java 中还有很多不需要加锁就可以解决并发问题的工具类</p>
<img src="/2023/05/21/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%80%82%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F/05/21/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%80%82%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F/v2-b732e0e46b87abad6ff059a454e5e825_720w.png" class title="img">

<h1 id="原子工具类"><a href="#原子工具类" class="headerlink" title="原子工具类"></a>原子工具类</h1><p>JDK 1.8 中， java.util.concurrent.atomic 包下类都是原子类，原子类都是基于 sun.misc.Unsafe 实现的。</p>
<ul>
<li>CPU 为了解决并发问题，提供了 CAS 指令，全称 Compare And Swap，即比较并交互</li>
<li>CAS 指令需要 3 个参数，变量、比较值、新值。当变量的当前值与比较值相等时，才把变量更新为新值</li>
<li>CAS 是一条 CPU 指令，由 CPU 硬件级别上保证原子性</li>
<li>java.util.concurrent.atomic 包中的原子分为：原子性基本数据类型、原子性对象引用类型、原子性数组、原子性对象属性更新器和原子性累加器</li>
</ul>
<p><strong>原子性基本数据类型</strong>：AtomicBoolean、AtomicInteger、AtomicLong</p>
<p><strong>原子性对象引用类型</strong>：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p>
<p><strong>原子性数组</strong>：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
<p><strong>原子性对象属性更新</strong>：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、 AtomicReferenceFieldUpdater</p>
<p><strong>原子性累加器</strong>：DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</p>
<p>修改我们之前测试原子性问题的类，使用 AtomicInteger 的简单例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.concurrency.a026;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 原子类 AtomicInteger</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAtomicInteger</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 计数变量</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> <span class="comment">// 线程 1 给 count 加 10000</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">10000</span>; j++) &#123;</span><br><span class="line"> count.incrementAndGet();</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;thread t1 count 加 10000 结束&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 线程 2 给 count 加 10000</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">10000</span>; j++) &#123;</span><br><span class="line"> count.incrementAndGet();</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;thread t2 count 加 10000 结束&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 启动线程 1</span></span><br><span class="line"> t1.start();</span><br><span class="line"> <span class="comment">// 启动线程 2</span></span><br><span class="line"> t2.start();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 等待线程 1 执行完成</span></span><br><span class="line"> t1.join();</span><br><span class="line"> <span class="comment">// 等待线程 2 执行完成</span></span><br><span class="line"> t2.join();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 打印 count 变量</span></span><br><span class="line"> System.out.println(count.get());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如预期</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread t2 count 加 10000 结束</span><br><span class="line">thread t1 count 加 10000 结束</span><br><span class="line">20000</span><br></pre></td></tr></table></figure>

<h1 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h1><ul>
<li>java.lang.ThreadLocal 类用于线程本地化存储。</li>
<li>线程本地化存储，就是为每一个线程创建一个变量，只有本线程可以在该变量中查看和修改值。</li>
<li>典型的使用例子就是，spring 在处理数据库事务问题的时候，就用了 ThreadLocal 为每个线程存储了各自的数据库连接 Connection。</li>
<li>使用 ThreadLocal 要注意，在不使用该变量的时候，一定要调用 remove() 方法移除变量，否则可能造成内存泄漏的问题。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">package</span> constxiong.concurrency.a026;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 原子类 AtomicInteger</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadLocal</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 线程本地存储变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; THREAD_LOCAL_NUM = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;<span class="comment">//初始值</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">3</span>; i++) &#123;<span class="comment">// 启动三个线程</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> add10ByThreadLocal();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> t.start();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程本地存储变量加 5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add10ByThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line"> <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> THREAD_LOCAL_NUM.get();</span><br><span class="line"> n += <span class="number">1</span>;</span><br><span class="line"> THREAD_LOCAL_NUM.set(n);</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : ThreadLocal num=&quot;</span> + n);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> THREAD_LOCAL_NUM.remove();<span class="comment">// 将变量移除</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程最后一个值都打印到了 5</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="title class_">Thread</span>-<span class="number">0</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">1</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">2</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">1</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">1</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">1</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">2</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">2</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">0</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">2</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">2</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">3</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">0</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">3</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">1</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">2</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">0</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">4</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">2</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">4</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">0</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">5</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">1</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">3</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">2</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">5</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">1</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">4</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">1</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h1 id="copy-on-write"><a href="#copy-on-write" class="headerlink" title="copy-on-write"></a>copy-on-write</h1><ul>
<li>根据英文名称可以看出，需要写时复制，体现的是一种延时策略。</li>
<li>Java 中的 copy-on-write 容器包括：CopyOnWriteArrayList、CopyOnWriteArraySet。</li>
<li>涉及到数组的全量复制，所以也比较耗内存，在写少的情况下使用比较适合。</li>
</ul>
<p>简单的 CopyOnWriteArrayList 的示例，<strong>这里只是说明 CopyOnWriteArrayList 怎么用，并且是线程安全的。这个场景并不适合使用 CopyOnWriteArrayList，因为写多读少</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">package</span> constxiong.concurrency.a026;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 copy-on-write</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ConstXiong</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCopyOnWrite</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">R</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;Integer&gt; cowList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// private static ArrayList&lt;Integer&gt; cowList = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> List&lt;Thread&gt; threadList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line"> <span class="comment">//启动 1000 个线程，向 cowList 添加 5 个随机整数</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">5</span>; j++) &#123;</span><br><span class="line"> <span class="comment">//休眠 10 毫秒，让线程同时向 cowList 添加整数，引出并发问题</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">10</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> cowList.add(R.nextInt(<span class="number">100</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;) ;</span><br><span class="line"> t.start();</span><br><span class="line"> threadList.add(t);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (Thread t : threadList) &#123;</span><br><span class="line"> t.join();</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(cowList.size());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码<span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>如果把</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;Integer&gt; cowList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; cowList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<p>打印结果就是小于 5000 的整数了</p>
<p><strong>注意：高并发情况下CopyOnWrite获取到的可能不是最新的值</strong>，具体可以参考下另外一篇文章<a href="CopyOnWriteArrayList%E7%9A%84%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%8F%96%E5%88%B0%E6%95%B0%E6%8D%AE%E6%98%AF%E6%9C%80%E6%96%B0%E7%9A%84%EF%BC%9F.md">《CopyOnWriteArrayList的机制如何保证读取到数据是最新的？》</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">hexo博客中插入图片失败--解决思路及个人最终解决办法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-21 00:41:46 / Modified: 01:43:28" itemprop="dateCreated datePublished" datetime="2023-05-21T00:41:46+08:00">2023-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">博客搭建</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天晚上花了大概2个小时在晚上搜寻各种hexo博客插入图片无法显示的解决办法，很多方法是重叠的，所以真正不同的解决方法并不多。</p>
<p>昨天晚上和今天晚上一共花了2个小时在网上找各种hexo博客插入图片无法显示的解决办法，很多方法是重叠的，且有的方法已经因为hexo版本升级而不可用，所以真正不同的解决方法并不多。其中很多博文的内容几乎一摸一样，没有实际的用处，且不考虑时间效应，直接复制粘贴，很浪费阅读者的时间。</p>
<p>本文的问题解决时间为2023-05-21，hexo版本为6.3.0。本回答受该博客启发较大，感谢各位先驱大佬的贡献。</p>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="创建图片资源文件夹"><a href="#创建图片资源文件夹" class="headerlink" title="创建图片资源文件夹"></a>创建图片资源文件夹</h3><p>网上有关的解决方式几乎很大一部分会提到这一点：<strong>将_config.yml 文件中的post_asset_folder 选项设为 true 来打开</strong>。事实上这正是hexo官方文档给出的解决方案之一中的一个步骤。仔细阅读后会发现如下几点：</p>
<p>该操作的作用就是在使用hexo new xxx指令新建博文时，在相同路径下同步创建一个xxx文件夹，而xxx文件夹的作用就是用来存放图片资源；那么直接新建xxx.md再新建xxx文件夹，这种操作的最终效果和使用hexo new xxx指令新建博文的效果一样吗？经过实测，是一样的。基于以上，直接总结一下：</p>
<p>新建博文可以不用hexo new xxx指令，我较为推荐直接新建文件和文件夹的方式，只要达到一个md文件，一个同名文件夹的效果即可；<strong>【将_config.yml 文件中的post_asset_folder 选项设为 true 】</strong>是必须的！理论上既然没用hexo new xxx指令，文件夹也是我自己新建的，这一步设置的意义似乎并不存在，但是后文介绍的插件必须在post_asset_folder 选项设为 true的情况下才能生效——本人亲测，大家记住这么设置即可！</p>
<h3 id="typora中图像设置"><a href="#typora中图像设置" class="headerlink" title="typora中图像设置"></a>typora中图像设置</h3><p>一般来说，大家会现在typora里写好md格式的博客，然后通过hexo clean、hexo g、hexo s进行一下本地测试，确认无误后再发布到远端。</p>
<p>暂且不说hexo博客的图片插入是个问题，我相信当初单纯利用typora做笔记时，图片文件的管理就让很多人头疼过，typora官方似乎也意识到这个问题，所以偏好设置中图像是专门的一项，提供了很多选择。</p>
<p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/20200707222506636.png" alt="typora插图"></p>
<p>我相信大多数同学写md时的图片很多可能是直接截图或者在其他地方copy的，然后在typora中直接粘贴就ok了。但是这么做之前最好把typora插入图片时采取何种操作配置好，否则md文件和图片相隔十万八千里，后续一旦移动md文件图片就识别不出来，相信大家用过typora都深有体会。</p>
<p>所以接下来讲一下typora如何设置。直接给结论：</p>
<p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/20200707224416296.png" alt="在这里插入图片描述">框里的路径是：.&#x2F;${filename}。.&#x2F;表示当前文件夹，${filename}表示当前文件名。这么设置的好处：</p>
<ul>
<li>图片资源文件夹有了；</li>
<li>而且是同名文件夹！（上面提到的需要创建的文件夹其实不用手动添加了）</li>
<li>这么设置的结果就是：想写篇博客，在source_posts文件夹下新建xxx.md文件，写着写着需要插一张图，从别处复制，然后在typora中直接粘贴，图片资源文件夹自动搞定，并不用关心什么文件夹，只管专注于md文件即可。</li>
</ul>
<h3 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h3><p>这个很多博客也有提到，插件的名字叫hexo-asset-image，相信在网上找了一波解决方案的同学一定对这个名字不陌生。</p>
<p>这个插件的不同版本可能会有不同的影响，我最终成功解决问题的版本是用如下命令下载的：</p>
<p><code>npm install hexo-asset-img --save</code></p>
<p>注意一定不要使用下面的这个，因为hexo版本已经变了，带入了日期参数，使用下面的这个会导致问题，具体原因分析如下。</p>
<p><code>npm install hexo-asset-image --save</code> <strong>不要用！！！</strong></p>
<p>为什么需要这么插件呢？</p>
<p>因为我们虽然在source_posts文件夹下写了md文件，也有了图片资源文件夹存了图片，但从我们前面typora中的设置不难知道，实际上md文件中的图片路径都是相对路径（.&#x2F;${filename}）。而实际网上看到的博文显然不是md文件，而是html文件，从md到html的转变就是hexo帮我们做的，还记得hexo g命令吗？就是干这个的。转换后的html文件在public目录下，路径是通过日期指示的。</p>
<p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/image-20230521010750761.png" alt="image-20230521010759555"></p>
<p>上图为md文件保存地址和对应图片的保存地址，下图为hexo g 之后生成的public地址</p>
<p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/image-20230521010918633.png" alt="image-20230521010918633"></p>
<p>大家如果了解过html的话，应该知道里面的图片应该是指定绝对路径的，大家可以打开上面第二张图的index.html，找到插入图片的地方，查看是否是可用的绝对路径，我的如下图。大家如果问题还没解决的话应该不是像我一样的日期+文件夹指明的绝对路径。<br>说到这儿，大家应该知道，理论上需要将md中图片的相对路径转换成html中的绝对路径，这样图片才能正常显示。因为我们图片资源也有了，显示不出来只能是路径不对（为验证，大家图片显示不对的话，打开index.html，插图片地方的路径肯定是一串不明所以的字母数字）。</p>
<p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/image-20230521011026522.png" alt="image-20230521011026522"></p>
<p>路径转换就是该节最开始提到的插件的作用：根据md图片的相对路径，给出html中图片的绝对路径。如果使用的插件是image的话，会生成错误的地址路径，日期和目录名重复，有兴趣的朋友可以试一下，这也是排错的一个思路。</p>
<p>路径：md文件名&#x2F;图片名，图片资源文件夹：自动生成且同名。这时如果用hexo clean、hexo g生成html文件，用Notepad++或其他工具打开index.html（路径见下方第一张图），找到插图片的地方，查看图片路径：发现图片路径似乎多了一串日期加目录信息，如果用hexo s在本地查看网页，会发现图片不显示，使用F12查看源码会发现图片位置提示404：</p>
<p><strong>既然是路径问题，那么是不是插件有问题？或者我们使用方法错了？</strong></p>
<p>找到插件安装位置（插件都在node_modules文件夹下），打开readme文件<br>readme如下：</p>
<p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/image-20230521011811207.png" alt="image-20230521011811207">瞬间发现别人的说明书讲得明明白白，言简意赅！我们的转化后路径不对正是因为我们md文件中图片的路径不对，图片名前面不能有其他东西！</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>找解决方案，断断续续找了2个多小时，写这篇博客又写了1个小时。感觉应该把整个过程讲得还算比较清楚了。</p>
<p>但是这种问题向来因人而异，同样的解决方法可能可以解决我的问题，但对另一个人无效。还是要多查找资料，多尝试，多思考。重要的是要<strong>锻炼自己定位问题的能力</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">EthanWhite-Chen</p>
  <div class="site-description" itemprop="description">不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ethanwhite-chen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ethanwhite-chen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ykchen998@foxmail.com" title="E-Mail → ykchen998@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EthanWhite-Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">152k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">4:36</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
