<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ethanwhite-chen.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
<meta property="og:type" content="website">
<meta property="og:title" content="ykchen的个人博客">
<meta property="og:url" content="https://ethanwhite-chen.github.io/index.html">
<meta property="og:site_name" content="ykchen的个人博客">
<meta property="og:description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="EthanWhite-Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ethanwhite-chen.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>ykchen的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ykchen的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到ykchen的技术总结分享博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ethanwhite-chen" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/06/02/Redis-Cluster%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/02/Redis-Cluster%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Redis Cluster架构详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-02 03:55:07 / Modified: 03:59:10" itemprop="dateCreated datePublished" datetime="2023-06-02T03:55:07+08:00">2023-06-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么有了主从架构后还需要Redis-Cluster架构"><a href="#为什么有了主从架构后还需要Redis-Cluster架构" class="headerlink" title="为什么有了主从架构后还需要Redis Cluster架构"></a>为什么有了主从架构后还需要Redis Cluster架构</h2><h3 id="主从架构的容量瓶颈"><a href="#主从架构的容量瓶颈" class="headerlink" title="主从架构的容量瓶颈"></a>主从架构的容量瓶颈</h3><p>我们回忆一下主从架构（一主多从）中，master节点负责写入数据，并同步给slave节点，然后slave节点负责处理读请求；可以通过slave节点的扩容，提高主从架构的读QPS；同时基于哨兵可以确保主从架构的高可用性。</p>
<p>可以说主从 + 哨兵的一套组合拳，既能抗住高并发的读请求，同时也可以实现高可用性；但是主从架构的数据来源其实是master，而主从架构中只有一个master节点，就导致了redis存储的数据容量是很有限的。在海量数据场景下，如果单单使用主从+哨兵的架构，肯定是不行的。</p>
<blockquote>
<p>这就是我们所说的主从架构容量瓶颈。</p>
</blockquote>
<p>所以我们需要一个新的架构来支撑海量数据。</p>
<p>读者可以先思考一下，单个master节点的数据容量是有限的，那么我们搞多个master节点，并且每个master节点中的数据都是不同的，这样不就可以支撑更大的数据量了吗？</p>
<p>再说，这个新的架构支撑了更多的数据量，同时你至少也需要支撑高可用吧，如果连高可用性都不能保障的话，要这么大的数据量有什么用，一旦某个master节点发生故障，那么整个架构就不可用了，这也太坑爹了吧。所以新的架构也要做到高可用。</p>
<p><strong>这个新的架构，也就是我们接下来要讲解的Redis Cluster。</strong></p>
<h2 id="Redis-Cluster原理"><a href="#Redis-Cluster原理" class="headerlink" title="Redis Cluster原理"></a>Redis Cluster原理</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li><p>Redis Cluster包含多个master节点，每个master节点挂在多个slave节点，多个master可以支撑更大的数据量</p>
<blockquote>
<p><strong>横向扩容支持更大数据量</strong>：如果我们需要支撑更多的数据量，那么添加新的master和slave节点就好了</p>
</blockquote>
</li>
<li><p>当master节点挂掉后，Redis Cluster会从master对应的slave节点中选举出一个新的master完成故障转移（<strong>高可用</strong>）</p>
</li>
<li><p>redis cluster默认是不支持slave节点读或者写的，slave节点更多是为了master发生故障时备用的节点</p>
</li>
</ul>
<h3 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h3><h4 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h4><h5 id="维护元信息的两种方式介绍"><a href="#维护元信息的两种方式介绍" class="headerlink" title="维护元信息的两种方式介绍"></a>维护元信息的两种方式介绍</h5><p>在分布式存储中需要提供维护<strong>节点元信息</strong>的机制，常见的元信息维护方式为：集中式和P2P。Redis Cluster使用的是P2P的<code>gossip</code>协议。</p>
<blockquote>
<p><strong>节点元信息主要包括：节点负责哪些数据、是否出现故障等状态信息。</strong></p>
</blockquote>
<p>我们来对比一下这两种维护元信息的方式。</p>
<p>集中式：将元信息集中存储在一个外部组件里，比如ZooKeeper</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/276c8fb74c54408181d0efb8efb7abec~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="集中式元信息存储">集中式元信息存储</p>
<blockquote>
<ul>
<li>集中式的优点在于元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的存储中，其他节点读取的时候立即就可以感知到;</li>
<li>缺点在于，所有的元数据的跟新压力全部集中在一个地方，可能会导致元数据的存储有压力。</li>
</ul>
</blockquote>
<p>gossip协议：</p>
<ul>
<li>好处：元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力</li>
<li>缺点：<strong>元数据更新有延时</strong>，可能导致集群的一些操作会有一些滞后</li>
</ul>
<h5 id="10000端口"><a href="#10000端口" class="headerlink" title="10000端口"></a>10000端口</h5><p>每个节点都有一个专门用于<strong>节点间通信的端口</strong>，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口</p>
<blockquote>
<p>每个节点隔一段时间都会往另外几个节点发送<code>ping</code>消息，同时其他几点接收到<code>ping</code>之后返回<code>pong</code></p>
</blockquote>
<h5 id="节点交换的信息"><a href="#节点交换的信息" class="headerlink" title="节点交换的信息"></a>节点交换的信息</h5><blockquote>
<p>包含故障信息，节点的增加和移除，<code>hash slot</code>信息等等</p>
</blockquote>
<h5 id="gossip协议详解"><a href="#gossip协议详解" class="headerlink" title="gossip协议详解"></a>gossip协议详解</h5><h6 id="gossip消息"><a href="#gossip消息" class="headerlink" title="gossip消息"></a><code>gossip</code>消息</h6><blockquote>
<p><code>gossip</code>协议包含多种消息，包括<code>ping</code>、<code>pong</code>、<code>meet</code>、<code>fail</code>等等。</p>
</blockquote>
<ul>
<li><p><code>meet</code>：某个节点发送<code>meet</code>消息给新加入的节点，让新节点加入到集群中，然后新节点就会与其他节点通信</p>
</li>
<li><p><code>ping</code>：每个节点每秒都会频繁给其他节点发送<code>ping</code>，其中包含自己的状态还有自己维护的集群元信息。（节点之间互相交换元信息）</p>
<blockquote>
<ul>
<li>节点之间互相通过<code>ping</code>交换元信息。</li>
<li>每个节点每秒都会频繁发送<code>ping</code>给其他的节点，频繁的互相之间交换数据，互相进行元数据的更新</li>
</ul>
</blockquote>
</li>
<li><p><code>pong</code>：返回<code>ping</code>和<code>meet</code>，包含自己的状态和其他信息，也可以用于信息广播和更新</p>
</li>
<li><p><code>fail</code>：<strong>某个节点判断另一个节点<code>fail</code>之后，就发送<code>fail</code>给其他节点，通知其他节点，指定的节点宕机了</strong></p>
</li>
</ul>
<blockquote>
<p><code>ping</code>消息的深入理解：</p>
<ul>
<li><p><code>ping</code>很频繁，而且要携带一些元数据，所以可能会加重网络负担</p>
<blockquote>
<ul>
<li>考虑到网络开销，每个节点每秒会执行10次<code>ping</code>时，每次会选择5个最久没有通信的其他节点</li>
<li>当然如果发现与某个节点通信延时达到了<code>cluster_node_timeout</code> &#x2F; 2，那么立即发送<code>ping</code>，避免数据交换延时过长，落后的时间太长了<ul>
<li>比如说，两个节点之间都10分钟没有交换数据了，那么整个集群处于<strong>严重的元数据不一致</strong>的情况，就会有问题；所以<code>cluster_node_timeout</code>可以调节，如果调节比较大，那么会降低发送的频率</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>每次<code>ping</code>，一个是带上自己节点的信息，还有就是带上<code>1/10</code>其他节点的信息，发送出去，进行数据交换</p>
</li>
</ul>
</blockquote>
<h3 id="高可用性与主备切换原理"><a href="#高可用性与主备切换原理" class="headerlink" title="高可用性与主备切换原理"></a>高可用性与主备切换原理</h3><blockquote>
<p>redis cluster的高可用的原理，几乎跟哨兵是类似的。</p>
</blockquote>
<h4 id="1-判断节点宕机"><a href="#1-判断节点宕机" class="headerlink" title="1. 判断节点宕机"></a>1. 判断节点宕机</h4><ul>
<li><p>如果一个节点认为另外一个节点宕机，那么就是<code>pfail</code>，主观宕机</p>
</li>
<li><p>如果多个节点都认为另外一个节点宕机了，那么就是<code>fail</code>，客观宕机</p>
<blockquote>
<p>可以类比到哨兵中的<code>sdown</code>、<code>odown</code></p>
</blockquote>
</li>
</ul>
<p>如果在<code>cluster-node-timeout</code>内，某个节点一直没有返回<code>pong</code>，那么就被认为<code>pfail</code>。</p>
<p>如果一个节点认为某个节点<code>pfail</code>了，那么会在gossip <code>ping</code>消息中，<code>ping</code>给其他节点，如果超过半数的节点都认为<code>pfail</code>了，那么就会变成<code>fail</code>（客观宕机）。</p>
<h4 id="2-从节点过滤"><a href="#2-从节点过滤" class="headerlink" title="2. 从节点过滤"></a>2. 从节点过滤</h4><ul>
<li>对宕机的master node，从其所有的slave node中，选择一个切换成master node</li>
<li>检查每个slave node与master node断开连接的时间，如果超过了<code>cluster-node-timeout</code> * <code>cluster-slave-validity-factor</code>，那么就没有资格切换成master</li>
</ul>
<h4 id="3-从节点选举"><a href="#3-从节点选举" class="headerlink" title="3. 从节点选举"></a>3. 从节点选举</h4><ol>
<li>每个从节点，都根据自己对master复制数据的<code>offset</code>，来设置一个选举时间，offset越大（复制数据越多）的从节点，选举时间越靠前，<strong>优先进行选举</strong>。</li>
<li>所有的master node开始slave选举投票，给要进行选举的slave进行投票，如果大部分master node（N&#x2F;2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成master。</li>
<li>从节点执行主备切换，从节点切换为主节点（故障转移）</li>
</ol>
<blockquote>
<p>哨兵的从节点选举：对所有从节点进行排序，slave <code>priority</code>，<code>offset</code>，<code>run id</code></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文先从主从架构的不足之处引出了Redis Cluster，然后介绍了Redis Cluster的原理，主要包含gossip协议以及高可用实现原理这两个点。本文并没有详细讲述Redis Cluster中比较重要的数据分片算法：hash slot算法，后面会专门写一篇文章讲述一下。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">深入解析 Redis 分布式锁原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-01 13:32:39" itemprop="dateCreated datePublished" datetime="2023-06-01T13:32:39+08:00">2023-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-02 03:47:48" itemprop="dateModified" datetime="2023-06-02T03:47:48+08:00">2023-06-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>15 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、实现原理"><a href="#一、实现原理" class="headerlink" title="一、实现原理"></a>一、实现原理</h2><h2 id="1-1-基本原理"><a href="#1-1-基本原理" class="headerlink" title="1.1 基本原理"></a>1.1 基本原理</h2><p>JDK 原生的锁可以让不同<strong>线程</strong>之间以互斥的方式来访问共享资源，但如果想要在不同<strong>进程</strong>之间以互斥的方式来访问共享资源，JDK 原生的锁就无能为力了。此时可以使用 Redis 来实现分布式锁。</p>
<p>Redis 实现分布式锁的核心命令如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure>

<p>SETNX 命令的作用是：如果指定的 key 不存在，则创建并为其设置值，然后返回状态码 1；如果指定的 key 存在，则直接返回 0。如果返回值为 1，代表获得该锁；此时其他进程再次尝试创建时，由于 key 已经存在，则都会返回 0 ，代表锁已经被占用。</p>
<p>当获得锁的进程处理完成业务后，再通过 del 命令将该 key 删除，其他进程就可以再次竞争性地进行创建，获得该锁。</p>
<p>通常为了避免死锁，我们会为锁设置一个超时时间，在 Redis 中可以通过 expire 命令来进行实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key seconds</span><br></pre></td></tr></table></figure>

<p>这里我们将两者结合起来，并使用 Jedis 客户端来进行实现，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> jedis.setnx(<span class="string">&quot;lockKey&quot;</span>, <span class="string">&quot;lockValue&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果此处程序被异常终止（如直接kill -9进程），则设置超时的操作就无法进行，该锁就会出现死锁</span></span><br><span class="line">    jedis.expire(<span class="string">&quot;lockKey&quot;</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码存在原子性问题，即 setnx + expire 操作是非原子性的，如果在设置超时时间前，程序被异常终止，则程序就会出现死锁。此时可以将 SETNX 和 EXPIRE 两个命令写在同一个 Lua 脚本中，然后通过调用 Jedis 的 eval() 方法来执行，并由 Redis 来保证整个 Lua 脚本操作的原子性。这种方式实现比较繁琐，因此官方文档中推荐了另外一种更加优雅的实现方法：</p>
<h2 id="1-2-官方推荐"><a href="#1-2-官方推荐" class="headerlink" title="1.2 官方推荐"></a>1.2 官方推荐</h2><p>[官方文档]( Distributed locks with Redis) 中推荐直接使用 set 命令来进行实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]</span><br></pre></td></tr></table></figure>

<p>这里我们主要关注以下四个参数：</p>
<ul>
<li><strong>EX</strong> ：设置超时时间，单位是秒；</li>
<li><strong>PX</strong> ：设置超时时间，单位是毫秒；</li>
<li><strong>NX</strong> ：当且仅当对应的 Key 不存在时才进行设置；</li>
<li><strong>XX</strong>：当且仅当对应的 Key 存在时才进行设置。</li>
</ul>
<p>这四个参数从 Redis 2.6.12 版本开始支持，因为当前大多数在用的 Redis 都已经高于这个版本，所以推荐直接使用该命令来实现分布式锁。对应的 Jedis 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;lockKey&quot;</span>, <span class="string">&quot;lockValue&quot;</span>, SetParams.setParams().nx().ex(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>此时一条命令就可以完成值和超时时间的设置，并且因为只有一条命令，因此其原子性也得到了保证。但因为引入了超时时间来避免死锁，同时也引出了其它两个问题：</p>
<img src="/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/v2-c2a257e6e20e01b93e012b5c8c710a95_720w.webp" class title="img">

<ul>
<li><strong>问题一</strong>：当业务处理的时间超过过期时间后（图中进程 A），由于锁已经被释放，此时其他进程就可以获得该锁（图中进程 B），这意味着有两个进程（A 和 B）同时进入了临界区，此时分布式锁就失效了；</li>
<li><strong>问题二</strong>：如上图所示，当进程 A 业务处理完成后，此时删除的是进程 B 的锁，进而导致分布式锁又一次失效，让进程 B 和 进程 C 同时进入了临界区。</li>
</ul>
<p>针对问题二，我们可以在创建锁时为其指定一个唯一的标识作为 Key 的 Value，这里假设我们采用 UUID + 线程ID 来作为唯一标识：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">identifier</span> <span class="operator">=</span> UUID.randomUUID() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">jedis.set(<span class="string">&quot;LockKey&quot;</span>, identifier, SetParams.setParams().nx().ex(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>然后在删除锁前，先将该唯一标识与锁的 Value 值进行比较，如果不相等，证明该锁不属于当前的操作对象，此时不执行删除操作。为保证判断操作和删除操作整体的原子性，这里需要使用 Lua 脚本来执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这段脚本的意思是如果 value 的值与给定的值相同，则执行删除命令，否则直接返回状态码 0 。对应使用 Jedis 实现的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">jedis.eval(script, </span><br><span class="line">           Collections.singletonList(<span class="string">&quot;LockKey&quot;</span>),  <span class="comment">// keys的集合</span></span><br><span class="line">           Collections.singletonList(identifier)  <span class="comment">// args的集合</span></span><br><span class="line">          );</span><br></pre></td></tr></table></figure>

<p>接着再看问题一，问题一最简单的解决方法是：你可以估计业务的最大处理时间，然后保证设置的过期时间大于最大处理时间。但是由于业务会面临各种复杂的情况，因此可能无法保证业务每一次都能在规定的过期时间内处理完成，此时可以使用延长锁时效的策略。</p>
<h2 id="1-3-延长锁时效"><a href="#1-3-延长锁时效" class="headerlink" title="1.3 延长锁时效"></a>1.3 延长锁时效</h2><p>延长锁时效的方案如下：假设锁超时时间是 30 秒，此时程序需要每隔一段时间去扫描一下该锁是否还存在，扫描时间需要小于超时时间，通常可以设置为超时时间的 1&#x2F;3，在这里也就是 10 秒扫描一次。如果锁还存在，则重置其超时时间恢复到 30 秒。通过这种方案，只要业务还没有处理完成，锁就会一直有效；而当业务一旦处理完成，程序也会马上删除该锁。</p>
<p>Redis 的 Java 客户端 Redisson 提供的分布式锁就支持类似的延长锁时效的策略，称为 WatchDog，直译过来就是 “看门狗” 机制。</p>
<p>以上讨论的都是单机环境下的 Redis 分布式锁，而想要保证 Redis 分布式锁是高可用，首先 Redis 得是高可用的，Redis 的高可用模式主要有两种：哨兵模式和集群模式。以下分别进行讨论：</p>
<h2 id="二、哨兵模式与分布式锁"><a href="#二、哨兵模式与分布式锁" class="headerlink" title="二、哨兵模式与分布式锁"></a>二、哨兵模式与分布式锁</h2><p>哨兵模式是主从模式的升级版，能够在故障发生时自动进行故障切换，选举出新的主节点。但由于 Redis 的复制机制是异步的，因此在哨兵模式下实现的分布式锁是不可靠的，原因如下：</p>
<ul>
<li>由于主从之间的复制操作是异步的，当主节点上创建好锁后，此时从节点上的锁可能尚未创建。而如果此时主节点发生了宕机，从节点上将不会创建该分布式锁；</li>
<li>从节点晋升为主节点后，其他进程（或线程）仍然可以在该新主节点创建分布式锁，此时就存在多个进程（或线程）同时进入了临界区，分布式锁就失效了。</li>
</ul>
<p>因此在哨兵模式下，无法避免锁失效的问题。因此想要实现高可用的分布式锁，可以采取 Redis 的另一个高可用方案 —— Redis 集群模式。</p>
<h2 id="三、集群模式与分布式锁"><a href="#三、集群模式与分布式锁" class="headerlink" title="三、集群模式与分布式锁"></a>三、集群模式与分布式锁</h2><h2 id="3-1-RedLock-方案"><a href="#3-1-RedLock-方案" class="headerlink" title="3.1 RedLock 方案"></a>3.1 RedLock 方案</h2><p>想要在集群模式下实现分布式锁，Redis 提供了一种称为 RedLock 的方案，假设我们有 N 个 Redis 实例，此时客户端的执行过程如下：</p>
<ul>
<li>以毫秒为单位记录当前的时间，作为开始时间；</li>
<li>接着采用和单机版相同的方式，依次尝试在每个实例上创建锁。为了避免客户端长时间与某个故障的 Redis 节点通讯而导致阻塞，这里采用快速轮询的方式：假设创建锁时设置的超时时间为 10 秒，则访问每个 Redis 实例的超时时间可能在 5 到 50 毫秒之间，如果在这个时间内还没有建立通信，则尝试连接下一个实例；</li>
<li>如果在至少 N&#x2F;2+1 个实例上都成功创建了锁。并且 当前时间 - 开始时间 &lt; 锁的超时时间 ，则认为已经获取了锁，锁的有效时间等于 超时时间 - 花费时间（如果考虑不同 Redis 实例所在服务器的时钟漂移，则还需要减去时钟漂移）；</li>
<li>如果少于 N&#x2F;2+1 个实例，则认为创建分布式锁失败，此时需要删除这些实例上已创建的锁，以便其他客户端进行创建。</li>
<li>该客户端在失败后，可以等待一个随机的时间后，再次进行重试。</li>
</ul>
<p>以上就是 RedLock 的实现方案，可以看到主要是由客户端来实现的，并不真正涉及到 Redis 集群相关的功能。因此这里的 N 个 Redis 实例并不要求是一个真正的 Redis 集群，它们彼此之间可以是完全独立的，但由于只需要半数节点获得锁就能真正获得锁，因此其仍然具备容错性和高可用性。后面使用 Redisson 来演示 RedLock 时会再次验证这一点。</p>
<h2 id="3-2-低延迟通讯"><a href="#3-2-低延迟通讯" class="headerlink" title="3.2 低延迟通讯"></a>3.2 低延迟通讯</h2><p>另外实现 RedLock 方案的客户端与所有 Redis 实例进行通讯时，必须要保证低延迟，而且最好能使用多路复用技术来保证一次性将 SET 命令发送到所有 Redis 节点上，并获取到对应的执行结果。如果网络延迟较高，假设客户端 A 和 B 都在尝试创建锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET key 随机数A EX <span class="number">3</span> NX  #A客户端</span><br><span class="line">SET key 随机数B EX <span class="number">3</span> NX  #B客户端</span><br></pre></td></tr></table></figure>

<p>此时可能客户端 A 在一半节点上创建了锁，而客户端 B 在另外一半节点上创建了锁，那么两个客户端都将无法获取到锁。如果并发很高，则可能存在多个客户端分别在部分节点上创建了锁，而没有一个客户端的数量超过 N&#x2F;2+1。这也就是上面过程的最后一步中，强调一旦客户端失败后，需要等待一个随机时间后再进行重试的原因，如果是一个固定时间，则所有失败的客户端又同时发起重试，情况就还是一样。</p>
<p>因此最佳的实现就是客户端的 SET 命令能几乎同时到达所有节点，并几乎同时接受到所有执行结果。 想要保证这一点，低延迟的网络通信极为关键，下文介绍的 Redisson 就采用 Netty 框架来保证这一功能的实现。</p>
<h2 id="3-3-持久化与高可用"><a href="#3-3-持久化与高可用" class="headerlink" title="3.3 持久化与高可用"></a>3.3 持久化与高可用</h2><p>为了保证高可用，所有 Redis 节点还需要开启持久化。假设不开启持久化，假设进程 A 获得锁后正在处理业务逻辑，此时节点宕机重启，因为锁数据丢失了，其他进程便可以再次创建该锁，因此所有 Redis 节点都需要开启 AOF 的持久化方式。</p>
<p>AOF 默认的同步机制为 everysec，即每秒进程一次持久化，此时能够兼顾性能与数据安全，发生意外宕机的时，最多会丢失一秒的数据。但如果碰巧就是在这一秒的时间内进程 A 创建了锁，并由于宕机而导致数据丢失。此时其他进程还可以创建该锁，锁的互斥性也就失效了。想要解决这个问题有两种方式：</p>
<ul>
<li><strong>方式一</strong>：修改 Redis.conf 中 appendfsync 的值为 always，即每次命令后都进行持久化，此时会降低 Redis 性能，进而也会降低分布式锁的性能，但锁的互斥性得到了绝对的保证；</li>
<li><strong>方式二</strong>：一旦节点宕机了，需要等到锁的超时时间过了之后才进行重启，此时相当于原有锁自然失效（但你首先需要保证业务能在设定的超时时间内完成），这种方案也称为延时重启。</li>
</ul>
<h2 id="四、Redisson"><a href="#四、Redisson" class="headerlink" title="四、Redisson"></a>四、Redisson</h2><p>Redisson 是 Redis 的 Java 客户端，它提供了各种的 Redis 分布式锁的实现，如可重入锁、公平锁、RedLock、读写锁等等，并且在实现上考虑得也更加全面，适用于生产环境下使用。</p>
<h2 id="4-1-分布式锁"><a href="#4-1-分布式锁" class="headerlink" title="4.1 分布式锁"></a>4.1 分布式锁</h2><p>使用 Redisson 来创建单机版本分布式锁非常简单，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建RedissonClient,如果与spring集成，可以将RedissonClient声明为Bean,在使用时注入即可</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.100:6379&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建锁实例</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//3.尝试获取分布式锁，第一个参数为等待时间，第二个参数为锁过期时间</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">10</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">// 4.模拟业务处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;处理业务逻辑&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">20</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//5.释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">redissonClient.shutdown();</span><br></pre></td></tr></table></figure>

<p>此时对应在 Redis 中的数据结构如下：</p>
<img src="/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/v2-28d9e979f9f7a695267e7ac8c77e01c2_720w.webp" class title="img">



<p>可以看到 key 就是代码中设置的锁名，而 value 值的类型是 hash，其中键 9280e909-c86b-43ec-b11d-6e5a7745e2e9:13 的格式为 UUID + 线程ID ；键对应的值为 1，代表加锁的次数。之所以要采用 hash 这种格式，主要是因为 Redisson 创建的锁是具有重入性的，即你可以多次进行加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isLock1</span> <span class="operator">=</span> lock.tryLock(<span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLock2</span> <span class="operator">=</span> lock.tryLock(<span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>此时对应的值就会变成 2，代表加了两次锁：</p>
<img src="/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/v2-90d0663d51c8fca4d8e2a9035406c186_720w.webp" class title="img">





<p>当然和其他重入锁一样，需要保证解锁的次数和加锁的次数一样，才能完全解锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock.unlock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<h2 id="4-2-RedLock"><a href="#4-2-RedLock" class="headerlink" title="4.2 RedLock"></a>4.2 RedLock</h2><p>Redisson 也实现了 Redis 官方推荐的 RedLock 方案，这里我们启动三个 Redis 实例进行演示，它们彼此之间可以是完全独立的，并不需要进行集群的相关配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-server ../redis.conf</span><br><span class="line">$ ./redis-server ../redis.conf --port <span class="number">6380</span></span><br><span class="line">$ ./redis-server ../redis.conf --port <span class="number">6381</span></span><br></pre></td></tr></table></figure>

<p>对应的代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建RedissonClient</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config01.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.100:6379&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient01</span> <span class="operator">=</span> Redisson.create(config01);</span><br><span class="line"><span class="type">Config</span> <span class="variable">config02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config02.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.100:6380&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient02</span> <span class="operator">=</span> Redisson.create(config02);</span><br><span class="line"><span class="type">Config</span> <span class="variable">config03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config03.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.100:6381&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient03</span> <span class="operator">=</span> Redisson.create(config03);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建锁实例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lockName</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock01</span> <span class="operator">=</span> redissonClient01.getLock(lockName);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock02</span> <span class="operator">=</span> redissonClient02.getLock(lockName);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock03</span> <span class="operator">=</span> redissonClient03.getLock(lockName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 RedissonRedLock</span></span><br><span class="line"><span class="type">RedissonRedLock</span> <span class="variable">redLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonRedLock</span>(lock01, lock02, lock03);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redLock.tryLock(<span class="number">10</span>, <span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">// 4.模拟业务处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;处理业务逻辑&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">200</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//5.释放锁</span></span><br><span class="line">    redLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redissonClient01.shutdown();</span><br><span class="line">redissonClient02.shutdown();</span><br><span class="line">redissonClient03.shutdown();</span><br></pre></td></tr></table></figure>

<p>此时每个 Redis 实例上锁的情况如下：</p>
<img src="/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/v2-27d8b6a263203ca7996d7d1f839009d5_720w.webp" class title="img">





<p>可以看到每个实例上都获得了锁。</p>
<h2 id="4-3-延长锁时效"><a href="#4-3-延长锁时效" class="headerlink" title="4.3 延长锁时效"></a>4.3 延长锁时效</h2><p>最后，介绍一下 Redisson 的 WatchDog 机制，它可以用来延长锁时效，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line"><span class="comment">// 1.设置WatchdogTimeout</span></span><br><span class="line">config.setLockWatchdogTimeout(<span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.100:6379&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建锁实例</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//3.尝试获取分布式锁，第一个参数为等待时间</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">// 4.模拟业务处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;处理业务逻辑&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;锁剩余的生存时间：&quot;</span> + lock.remainTimeToLive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//5.释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">redissonClient.shutdown();</span><br></pre></td></tr></table></figure>

<p>首先 Redisson 的 WatchDog 机制只会对那些没有设置锁超时时间的锁生效，所以我们这里调用的是两个参数的 tryLock() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<p>而不是包含超时时间的三个参数的 tryLock() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>其次我们通过 config.setLockWatchdogTimeout(30 * 1000) 将 lockWatchdogTimeout 的值设置为 30000 毫秒（默认值也是 30000 毫秒）。此时 Redisson 的 WatchDog 机制会以 lockWatchdogTimeout 的 1&#x2F;3 时长为周期（在这里就是 10 秒）对所有未设置超时时间的锁进行检查，如果业务尚未处理完成（也就是锁还没有被程序主动删除），Redisson 就会将锁的超时时间重置为 lockWatchdogTimeout 指定的值（在这里就是设置的 30 秒），直到锁被程序主动删除位置。因此在上面的例子中可以看到，不论将模拟业务的睡眠时间设置为多长，其锁都会存在一定的剩余生存时间，直至业务处理完成。</p>
<p>反之，如果明确的指定了锁的超时时间 leaseTime，则以 leaseTime 的时间为准，因为 WatchDog 机制对明确指定超时时间的锁不会生效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/06/01/MyBatis-Plus%E7%9A%84BaseMapper%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/01/MyBatis-Plus%E7%9A%84BaseMapper%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">MyBatis-Plus的BaseMapper实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-01 13:12:56 / Modified: 13:24:38" itemprop="dateCreated datePublished" datetime="2023-06-01T13:12:56+08:00">2023-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>19 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Mybatis-plus为我们提供了一些通用mapper方法，比如insert，update，selectById等等，我们通过让自己的mapper继承BaseMapper这个类就可以不用自己写sql就能直接调用一些基础的sql方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但是在使用过程中还是发现这里面提供的方法有点少，当我们想要添加自己的通用sql方法的时候，可以通过官方文档描述的 <a href="https://link.juejin.cn/?target=https://mp.baomidou.com/guide/sql-injector.html">Sql 注入器</a> 来实现。比我们我们自己定义一个saveBatch方法，用来批量的插入数据。</p>
<h2 id="BaseMapper自定义扩展"><a href="#BaseMapper自定义扩展" class="headerlink" title="BaseMapper自定义扩展"></a>BaseMapper自定义扩展</h2><p>mybatis-plus提供了<code>ISqlInjector</code>接口，以及<code>AbstractSqlInjector</code>抽象类。我们通过实现该接口，或者继承抽象类的方式注入我们自已定义的SQL逻辑，然后继承BaseMapper添加我们需要的方法就可以添加自定义的mapper方法。</p>
<p>在这2个接口之外，mybatis-plus其实为我们提供了一个默认实现：<code>DefaultSqlInjector</code>，这里面已经包含了一些mybatis-plus已经封装好的BaseMapper里面的方法，我们想要扩展的话，可以直接继承这个类来进行扩展添加我们的方法。</p>
<p>这里我们希望在BaseMapper之外添加一个saveBatch方法，用来可以批量的插入数据：</p>
<ol>
<li>实现<code>DefaultSqlInjector</code>类，我们可以看到<strong>需要实现<code>getMethodList</code>方法</strong>，这个方法参数是mapper接口的class类，返回值是一个List<AbstractMethod>。所以我们自定义的方法是需要实现<code>AbstractMethod</code>。可以参考mybatis-plus中已经实现了一些<code>AbstractMethod</code>方法，我们仿造写一个SaveBatch类。</AbstractMethod></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomSqlInjector</span> <span class="keyword">extends</span> <span class="title class_">DefaultSqlInjector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title function_">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> &#123;</span><br><span class="line">      	<span class="comment">// 父类的list已经包含了BaseMapper的基础方法。</span></span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="built_in">super</span>.getMethodList(mapperClass);</span><br><span class="line">        <span class="comment">// 添加我们需要增加的自定义方法。</span></span><br><span class="line">        methodList.add(<span class="keyword">new</span> <span class="title class_">SaveBatch</span>());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>实现SaveBatch类的逻辑（这是官方的samples）。我们可以看到，这里的逻辑主要就是为了<strong>生成MappedStatement对象</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaveBatch</span> <span class="keyword">extends</span> <span class="title class_">AbstractMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MappedStatement <span class="title function_">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;&lt;script&gt;insert into %s %s values %s&lt;/script&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fieldSql</span> <span class="operator">=</span> prepareFieldSql(tableInfo);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">valueSql</span> <span class="operator">=</span> prepareValuesSqlForMysqlBatch(tableInfo);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sqlResult</span> <span class="operator">=</span> String.format(sql, tableInfo.getTableName(), fieldSql, valueSql);</span><br><span class="line">        <span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> languageDriver.createSqlSource(configuration, sqlResult, modelClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.addInsertMappedStatement(mapperClass, modelClass, <span class="string">&quot;saveBatch&quot;</span>, sqlSource, <span class="keyword">new</span> <span class="title class_">NoKeyGenerator</span>(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">prepareFieldSql</span><span class="params">(TableInfo tableInfo)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">fieldSql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        fieldSql.append(tableInfo.getKeyColumn()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        tableInfo.getFieldList().forEach(x -&gt; &#123;</span><br><span class="line">            fieldSql.append(x.getColumn()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        fieldSql.delete(fieldSql.length() - <span class="number">1</span>, fieldSql.length());</span><br><span class="line">        fieldSql.insert(<span class="number">0</span>, <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        fieldSql.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fieldSql.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">prepareValuesSqlForMysqlBatch</span><span class="params">(TableInfo tableInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">valueSql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        valueSql.append(<span class="string">&quot;&lt;foreach collection=\&quot;list\&quot; item=\&quot;item\&quot; index=\&quot;index\&quot; open=\&quot;(\&quot; separator=\&quot;),(\&quot; close=\&quot;)\&quot;&gt;&quot;</span>);</span><br><span class="line">        valueSql.append(<span class="string">&quot;#&#123;item.&quot;</span>).append(tableInfo.getKeyProperty()).append(<span class="string">&quot;&#125;,&quot;</span>);</span><br><span class="line">        tableInfo.getFieldList().forEach(x -&gt; valueSql.append(<span class="string">&quot;#&#123;item.&quot;</span>).append(x.getProperty()).append(<span class="string">&quot;&#125;,&quot;</span>));</span><br><span class="line">        valueSql.delete(valueSql.length() - <span class="number">1</span>, valueSql.length());</span><br><span class="line">        valueSql.append(<span class="string">&quot;&lt;/foreach&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> valueSql.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>最后我们需要将我们的Injector注入Spring容器中，替换默认的Injector。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CustomSqlInjector <span class="title function_">myLogicSqlInjector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomSqlInjector</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>验证：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TB3Mapper</span> <span class="keyword">extends</span> <span class="title class_">MyBaseMapper</span>&lt;Tb3&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Tb3&gt; tb3s = Arrays.asList(Tb3.getInstance(), Tb3.getInstance());</span><br><span class="line">    tb3Mapper.saveBatch(tb3s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output log</span></span><br><span class="line">==&gt;  Preparing: insert into <span class="title function_">tb3</span> <span class="params">(id,f1,f2,f3)</span> values ( ?,?,?,? ),( ?,?,?,? )</span><br><span class="line">==&gt; Parameters: <span class="number">38</span>(Integer), <span class="number">62</span>(Integer), -<span class="number">1546785812</span>(Integer), -<span class="number">16950756</span>(Integer), <span class="number">24</span>(Integer), <span class="number">17</span>(Integer), -<span class="number">1871764773</span>(Integer), <span class="number">169785869</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>首先简单说下mybatis-plus，我只是简单翻了下源码，mybatis-plus的工作原理就是：全面再次代理了mybatis的一些东西。比如自动配置转用了MybatisPlusAutoConfiguration，SqlSessionFactoryBean转用了MybatisSqlSessionFactoryBean等等，这些mybatis的核心部件，全部都被mybatis-plus给替换了，用成了它自己的，然后它就在自己的里面定制了自己的逻辑。</p>
<p>我只分析下BaseMapper的实现原理，当初在文档中没有看到这块，自己手写了一版自定义的逻辑，跟踪了这块代码。在这之前还是简单阐述下mybatis的一些核心的原理，如果没有看过mybatis源码的话，知道这些也应该能看懂。</p>
<p><strong>mybatis的整体逻辑可以分为2块</strong>：</p>
<ol>
<li>配置文件解析：这过程包括解析我们config的配置，以及mapper.xml文件。最终配置都会被解析到一个Configuration对象里面，后面的每个SqlSession也都会包含一个该Configuration对象实例的引用。这个Configuration里面最重要的有2个东西：</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72e6daf364f4649894a9cf26eeb2708~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210830223002642.png"></p>
<ul>
<li>mappedStatements：存放mapper对应的sql信息</li>
<li>mybatisMapperRegistry.knownMappers：存放mapper接口对应的代理类</li>
</ul>
<p>这2个东西贯穿了mybatis的接口到sql的执行逻辑。</p>
<ol>
<li>接口的调用：我们接口调用的其实是代理的包装类，这个类也是上图mybatisMapperRegistry.knownMappers里面展示的MybatisMapperProxyFactory（mybatis是MapperProxyFactory）的getObject返回的代理MybatisMapperProxy对象。这个代理类里面的主要逻辑就是拿着该类的全限定类名，指定某个方法的时候，去Configuration的mappedStatements里面去找到对应的sql。</li>
</ol>
<p>所以知道了mybatis的大概逻辑了，我们可以猜到：<strong>在Configuration加载的时候，一定有地方将我们BaseMapper的默认方法对应的SQL的信息给装载到mappedStatements这个map里面去。我们就需要去跟踪，在哪里我们将这些默认的基础方法的MappedStatement对象进行构建，并插入到configuration中的。</strong></p>
<p>debug跟踪可以发现：</p>
<p>第一步，肯定是自动配置要加载SqlSessionFactory，这个方法主要是构建MybatisSqlSessionFactoryBean对象，然后调用getObject方法，我们跟进<code>MybatisSqlSessionFactoryBean.getObject()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    notNull(dataSource, <span class="string">&quot;Property &#x27;dataSource&#x27; is required&quot;</span>);</span><br><span class="line">    state((configuration == <span class="literal">null</span> &amp;&amp; configLocation == <span class="literal">null</span>) || !(configuration != <span class="literal">null</span> &amp;&amp; configLocation != <span class="literal">null</span>),</span><br><span class="line">        <span class="string">&quot;Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together&quot;</span>);</span><br><span class="line">  	<span class="comment">// 这里才是开始构建SqlSessionFactory的</span></span><br><span class="line">    <span class="built_in">this</span>.sqlSessionFactory = buildSqlSessionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终会执行到buildSqlSessionFactory()。这块方法的主要逻辑就是解析XML配置来创建Configuration对象。我们可以在最下面发现解析我们mapper.xml文件的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Resource mapperLocation : <span class="built_in">this</span>.mapperLocations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapperLocation == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 对每一个mapper.xml文件进行解析</span></span><br><span class="line">                <span class="type">XMLMapperBuilder</span> <span class="variable">xmlMapperBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(mapperLocation.getInputStream(),</span><br><span class="line">                    targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                xmlMapperBuilder.parse();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ErrorContext.instance().reset();</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(() -&gt; <span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初步猜测：sql信息就是在这里面被装载进去的，重点看看<code>xmlMapperBuilder.parse();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">// debug发现，Configuration中mappedStatements在执行该方法之后，mapper方法数量就变多了。</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>bindMapperForNamespace</code>里面，是在执行<code>configuration.addMapper(boundType);</code>之后方法变多的。这个方法最终调用的是<code>MybatisMapperRegistry.addMapper()</code>，这个方法里面最终会转去调用<code>MybatisMapperAnnotationBuilder.parse()</code>方法，将mapper的方法加入到mappedStatements中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  	......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// https://github.com/baomidou/mybatis-plus/issues/3038</span></span><br><span class="line">            <span class="keyword">if</span> (GlobalConfigUtils.isSupperMapperChildren(configuration, type)) &#123;</span><br><span class="line">              	<span class="comment">// 执行该步骤之后，新增了mappestatment</span></span><br><span class="line">                parserInjector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteMethod(<span class="keyword">new</span> <span class="title class_">InjectorResolver</span>(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parserInjector方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">parserInjector</span><span class="params">()</span> &#123;</span><br><span class="line">    GlobalConfigUtils.getSqlInjector(configuration).inspectInject(assistant, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GlobalConfigUtils.getSqlInjector</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ISqlInjector <span class="title function_">getSqlInjector</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getGlobalConfig(configuration).getSqlInjector();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//getSqlInjector()</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ISqlInjector</span> <span class="variable">sqlInjector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlInjector</span>();</span><br><span class="line"><span class="comment">//MybatisPlusAutoConfiguration.sqlSessionFactory#sqlInjector</span></span><br><span class="line"><span class="built_in">this</span>.getBeanThen(ISqlInjector.class, globalConfig::setSqlInjector);</span><br></pre></td></tr></table></figure>

<p>我们可以看到，通过一连串的方法拿到ISqlInjector实现类。默认是DefaultSqlInjector，但是如果Spring中被手动注入了该实现类的话，就会在自动配置的时候，修改为我们自定义的SqlInjector。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab28d15821f34d3d834ade63a0b01501~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210830230401071.png"></p>
<p>这里就会转到我们自定义的逻辑了，但是我们这里CustomSqlInjector是extends DefaultSqlInjector的，所以逻辑还是在DefaultSqlInjector里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSqlInjector</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title function_">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Insert</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Delete</span>(),</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    ).collect(toList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractSqlInjector</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; modelClass = extractModelClass(mapperClass);</span><br><span class="line">    <span class="keyword">if</span> (modelClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> mapperClass.toString();</span><br><span class="line">        Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">        <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">          	<span class="comment">// 可以看到这里拿取我们CustomSqlInjector返回的AbstractMethod list，然后循环调用inject</span></span><br><span class="line">            List&lt;AbstractMethod&gt; methodList = <span class="built_in">this</span>.getMethodList(mapperClass);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                <span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">                <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(mapperClass.toString() + <span class="string">&quot;, No effective injection method was found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mapperRegistryCache.add(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractMethod</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.configuration = builderAssistant.getConfiguration();</span><br><span class="line">    <span class="built_in">this</span>.builderAssistant = builderAssistant;</span><br><span class="line">    <span class="built_in">this</span>.languageDriver = configuration.getDefaultScriptingLanguageInstance();</span><br><span class="line">    <span class="comment">/* 注入自定义方法 */</span></span><br><span class="line">    injectMappedStatement(mapperClass, modelClass, tableInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就很清楚了，这里面一系列的模板方法模式的类，预留了钩子让子类去实现。</p>
<p><code>DefaultSqlInjector</code>这个类只是为了提供哪些方法需要被注入到mappedStatements中，这个list将被抽象类<code>AbstractSqlInjector</code>钩子调用。</p>
<p><code>AbstractSqlInjector</code>主要就是循环<code>getMethodList</code>返回的AbstractMethod组成的List，然后调用inject方法。</p>
<p><code>AbstractMethod</code>的<code>inject</code>也就是我们自己定义的逻辑。</p>
<p><code>SaveBatch</code>在构建好一个MappedStatement对象需要的元素后，调用<code>addInsertMappedStatement</code>将插入到Configuration的mappedStatements中。</p>
<p>分析完毕。</p>
<h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>mybatis-plus除了BaseMapper之外，还有一些公共的方法，是放在一个 <code>ServiceImpl</code>的类中的，很多人在service层继承这个类来获取这些功能，我一直很不喜欢这种方式：</p>
<ul>
<li>在Service层继承这个东西，感觉像是把Dao的功能迁移到了Service层面了，层次结构有点不舒服（当然实际使用没什么影响）。</li>
<li>这个ServiceImpl里面很多方法被强制加了是事务注解，我们都无法改变！这个比较糟糕，多数据源的时候这些事务注解会导致数据源切换失败。</li>
</ul>
<p>我的想法是这些方法能不能再落到BaseMapper层？经过这次分析发现，确实不太合适：BaseMapper里面的基础方法一般都对应这一条SQL，这条SQL是能被完整构建的。</p>
<p>但是在ServiceImpl里面的方法，很多其实都是打包多条SQL然后统一提交进行flush操作的，甚至一写比如saveOrUpdate方法都是执行查询，然后处理后再更新或者插入。这些都不是单个SQL能完成的任务，因此mybatis-plus将这些逻辑只能放在ServiceImpl中。</p>
<p>如果想将这些方法，还是放在BaseMapper中，那么可能就需要去特别的修改MapperProxy代理类了。相较而言，放在ServiceImpl还是不错的选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/" class="post-title-link" itemprop="url">如何保障缓存和数据库的一致性（超详细案例）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-24 20:53:24 / Modified: 23:10:37" itemprop="dateCreated datePublished" datetime="2023-05-24T20:53:24+08:00">2023-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>今天给大家分享一道大厂面试的常见题目，高并发下如何保障缓存和数据库的一致性，本文内容源于我在工作中的大量实际项目实践和思考。</p>
<p>本文内容有视频版本，喜欢看视频的同学可以直接通过下面的二维码观看。如果你对文章的内容有疑惑，有可以先看视频的对应内容，视频可能讲的会更细一点。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>该问题提出之前，面试官可能会先跟你聊一些其他的缓存知识点，然后通过一些场景题逐渐引导到该题目，例如更新数据库成功，删除Redis失败，Redis是脏数据，如何处理？等等之类的。</p>
<p>接着我们来看现在主流的有哪些方案，最后我会分享我自己的最终方案。</p>
<h2 id="方案1：同步删除"><a href="#方案1：同步删除" class="headerlink" title="方案1：同步删除"></a><strong>方案1：同步删除</strong></h2><h3 id="核心流程："><a href="#核心流程：" class="headerlink" title="核心流程："></a><strong>核心流程：</strong></h3><ol>
<li>先更新数据库数据</li>
<li>然后删除缓存数据</li>
</ol>
<h3 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h3><p><strong>1）删除缓存失败存在脏数据</strong></p>
<p><strong>2）难以收拢所有更新数据库入口</strong></p>
<p>使用同步删除方案，你必须在所有更新数据库的地方都进行缓存的删除操作，如果你有一个地方漏掉了，对应的缓存就相当于没有删除了，就会导致脏数据问题。</p>
<p>还有就是如果我们通过命令行直接来更新数据库的数据，或者通过公司提供的数据库管理平台来更新数据库数据，这个时候你就没法删除了，因为你的同步删除其实只是写在你的代码里面，这个时候也就导致脏数据问题了，这也是为什么说同步删除很难覆盖所有的入口，同时存在很大的风险。</p>
<p><strong>3）并发场景下存在脏数据</strong></p>
<p>我们看一个例子：</p>
<p>例子：表A存在数据 a&#x3D;1，并发情况下可能有以下流程：</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-192ff9ff327e6c9cd69ac53d7dbb9357_720w.webp" class title="img">

<p>该例子中，由于线程2在查询完数据库数据之后，写入缓存之前，数据库的数据被线程1更新并且执行完同步删除操作了，所以最终导致脏数据问题，并且脏数据可能会持续很久。</p>
<p>当然，由于更新数据库操作耗时一般比写缓存更久，所以该例子发生的概率并不会太大，但还是有可能的。</p>
<p>最典型的场景就是，线程2查询完数据库之后，写缓存之前，线程2所在服务器发生了YGC，这个时候线程2可能就需要等待几十毫秒才能执行写缓存操作，这种情况就很容易出现上面这个例子了。</p>
<p><strong>小结：由于难以收拢所有更新数据库入口，同时可能存在长期的脏数据问题，该方案一般不会被单独使用，但是可以作为一个补充，下面的方案会提到。</strong></p>
<h2 id="方案2：延迟双删"><a href="#方案2：延迟双删" class="headerlink" title="方案2：延迟双删"></a><strong>方案2：延迟双删</strong></h2><h3 id="核心流程：-1"><a href="#核心流程：-1" class="headerlink" title="核心流程："></a><strong>核心流程：</strong></h3><ol>
<li>删除缓存数据</li>
<li>更新数据库数据</li>
<li>等待一小段时间</li>
<li>再次删除缓存数据</li>
</ol>
<h3 id="存在的问题：-1"><a href="#存在的问题：-1" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h3><p><strong>1）延迟时间难以确认</strong></p>
<p>到底是延迟一秒或者是几秒，这个其实很难确认，你总不能延迟几分钟吧，因为你如果延迟几分钟，那这几分钟可能就存在脏数据了，所以这个时间很难确定。</p>
<p><strong>2）无法绝对保障数据的一致性</strong></p>
<p>我们看下面这个例子：</p>
<p>例子：表A存在数据 a&#x3D;1，并发情况下可能有以下流程</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-6f5ab13cc2164dc7600fbcbdc9b94c92_720w.webp" class title="img">

<p>该例子中，由于数据库主从同步完成之间，存在并发的请求，从而导致脏数据问题，并且脏数据可能会持续很久。</p>
<p>可能有的同学觉得稍微调大点延迟时间就可以解决这个问题，但是其实主库在写压力比较大的时候，主从之间的同步延迟甚至可能是分钟级的。</p>
<p>因此，该方案整体来说还是有明显的问题，所以说一般也不会使用这个方案。</p>
<p><strong>小结：由于延迟时间难以确认，同时无法绝对保障数据的一致性，该方案一般不会使用。</strong></p>
<h2 id="方案3：异步监听binlog删除-重试"><a href="#方案3：异步监听binlog删除-重试" class="headerlink" title="方案3：异步监听binlog删除 + 重试"></a><strong>方案3：异步监听binlog删除 + 重试</strong></h2><h3 id="核心流程：-2"><a href="#核心流程：-2" class="headerlink" title="核心流程："></a><strong>核心流程：</strong></h3><ol>
<li>更新数据库</li>
<li>监听binlog删除缓存</li>
<li>缓存删除失败则通过MQ不断重试，直至删除成功</li>
</ol>
<p>整体流程图如下：</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-bb6f95453ac4ff102e292816d0b956af_720w.webp" class title="img">

<p>该方案是当前的主流方案，整体上没太大的问题，但是极端场景下可能还是有一些小问题。</p>
<h3 id="存在的问题：-2"><a href="#存在的问题：-2" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h3><p><strong>1）脏数据时间窗口“较大”</strong></p>
<p>这个脏数据时间窗口较大，是相对同步删除来说。在你收到binlog之前，他中间要经过：binlog从主库同步到从库、binlog从库到binlog监听组件、binlog从监听组件发送到MQ、消费MQ消息，这些操作每个都是有一定的耗时的，可能是几十毫秒甚至几百毫秒，所以说它其实整体是有一个脏数据的时间窗口。</p>
<p>而同步删除是在更新完数据库后马上删除，时间窗口大概也就是1毫秒左右，所以说binlog的方式相对于同步删除，可能存在的脏数据窗口会稍微大一点。</p>
<p><strong>2）极端场景下存在长期脏数据问题</strong></p>
<ul>
<li>binlog抓取组件宕机导致脏数据。该方案强依赖于监听binlog的组件，如果监听binlog组件出现宕机，则会导致大量脏数据。</li>
<li>拆库拆表流程中可能存在并发脏数据</li>
</ul>
<p><strong>拆库拆表流程中并发脏数据问题</strong></p>
<p>我们来看下面这个例子：</p>
<p>表A正在进行数据库拆分，当前进行到灰度切读流量阶段：部分读新库，部分读老库</p>
<p>数据库拆分大致流程：增量数据同步（双写）、全量数据迁移、数据一致性校验、灰度切读、切读完毕后停写老库。</p>
<p>此时表A存在数据 a&#x3D;1，并发情况下可能有以下流程</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-d032690f6a50cd0993eade0268429281_720w.webp" class title="img">

<p>该例子中，灰度切读阶段中，我们还是优先保障老库的流程，因此还是先写老库，由于写新库和写老库之间存在时间间隔，导致线程2并发查询到新库的老数据，同时在监听binlog删除缓存流程之后将老数据写入缓存，从而导致脏数据问题，并且脏数据可能会持续很久。</p>
<p>双写的方式有很多种，我们使用的是通过公司的中间件直接将老库数据通过binlog的方式同步到新库，该方案通过监控发现在写压力较大的情况下，延迟可能会达到几秒，因此出现了上述问题。</p>
<p>而如果是使用代码进行同步双写，双写之间的时间间隔会较小，该问题出现的概率会相对低很多，但是还是无法保障绝对不会出现，就像上面提过的，写老库和写新库2个操作之间如果发生了YGC或者FGC，就可能导致这两个操作之间的时间间隔比较大，从而可能发生上面的案例。</p>
<p>还有就是代码双写的方式必须收敛所有的写入口，上文提到过的，通过命令行或者数据库管理平台的方式修改的数据，代码双写也是无法覆盖的，需要执行者在新老库都执行一遍，如果遗漏了新库，则可能导致数据问题。</p>
<p><strong>小结：该方案在大多数场景下没有太大问题，业务比较小的场景可以使用，或者在其基础上进行适当补充。</strong></p>
<h2 id="最终方案：缓存三重删除-数据一致性校验-更新流程禁用缓存-强制读Redis主节点"><a href="#最终方案：缓存三重删除-数据一致性校验-更新流程禁用缓存-强制读Redis主节点" class="headerlink" title="最终方案：缓存三重删除 + 数据一致性校验 + 更新流程禁用缓存 + 强制读Redis主节点"></a><strong>最终方案：缓存三重删除 + 数据一致性校验 + 更新流程禁用缓存 + 强制读Redis主节点</strong></h2><p>这个方案也是我现在在我们项目中里面使用的方案，这里面有很多很多的思考，踩了各种坑之后不断优化而来的方案。该方案整体以方案3作为主体，然后增加了各种优化。</p>
<h3 id="整体方案如下："><a href="#整体方案如下：" class="headerlink" title="整体方案如下："></a><strong>整体方案如下：</strong></h3><ul>
<li><p>更新数据库同步删除缓存</p>
</li>
<li><p>监听数据库的binlog异步删除缓存：带重试，保障一定会最终删除成功</p>
</li>
<li><p>缓存数据带过期时间，过期后自动删除，越近更新的数据过期时间越短</p>
</li>
<li><ul>
<li>主要用于进一步防止并发下的脏数据问题</li>
<li>解决一些由于未知情况，导致需要更换缓存结构的问题</li>
</ul>
</li>
<li><p>监听数据库的binlog延迟N秒后进行数据一致性校验</p>
</li>
<li><ul>
<li>解决一些极端场景下的脏数据问题</li>
</ul>
</li>
<li><p>存在数据库更新的链路禁用对应缓存</p>
</li>
<li><ul>
<li>防止并发下短期内的脏数据影响到更新流程</li>
</ul>
</li>
<li><p>强制读Redis主节点</p>
</li>
<li><p>查询异步数据一致性校验、灰度放量</p>
</li>
</ul>
<p><strong>整体流程图</strong></p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-763c24d16aaf83bfa3725b33bf4fd1f4_720w.webp" class title="img">

<p>下面我们来细说各个方案点的设计初衷。</p>
<p><strong>1）更新数据库后同步删除缓存</strong></p>
<p>这个同步删除缓存其实是为了解决我们上面说的那个异步binlog删除不一致时间窗口比较大的问题。更新完数据之后，我们马上进行一次同步删除，不一致的时间窗口非常小。</p>
<p><strong>2）监听数据库的binlog异步删除缓存</strong></p>
<p>该步骤是整个方案的核心，也就是方案3，因为binlog理论上是绝对不会丢的，他不像同步删除存在无法收敛入口的问题。因此，我们会保障该步骤一定能删除成功，如果出现失败，则通过MQ不断重试。</p>
<p>通过前面两个方案点，我们其实已经保障了绝大多数场景下数据是正确的。</p>
<p><strong>3）缓存数据带过期时间，过期后自动删除，越近更新的数据过期时间越短</strong></p>
<p>该策略的设计初衷是因为我们前面讲的那些并发问题其实都是在存在并发更新跟一些并发查询的场景下出现的，因此最近刚刚更新过的数据，他出现不一致的概率相对于那种很久没更新过的数据来说会大很多。</p>
<p>例如最近一个小时内更新的数据，我可能给他设计的过期时间很短，当然这个过期时间很多是相对于其他数据而言，绝对时间还是比较长的，例如我们使用的是一个小时。</p>
<p>这边是因为我们整体的请求量和数据量太大，如果使用的过期时间太短，会导致写缓存流量特别大，导致缓存集群压力很大。</p>
<p>因此，如果使用该策略，建议过期时间一开始可以设置大一点，然后逐渐往下调，同时观察缓存集群的压力情况。</p>
<p>该方案可以进一步保证我们数据的一个最终一致性。</p>
<p>同时带过期时间可以解决另一个问题，如果你在缓存上线后发现缓存数据结构设计不合理，你想把该缓存替换掉。如果该缓存有过期时间，你不需要处理存量数据，让他到期自动删除就行了。如果该缓存没有过期时间，则你需要将存量数据进行删除，不然可能会占用大量空间。</p>
<p><strong>4）监听数据库的binlog延迟N秒后进行数据一致性校验</strong></p>
<p>这个操作也是非常关键，方案3存在的问题就可以通过这个操作来解决掉。就如上面提过的，脏数据都是在更新操作之后的很短时间内触发的。</p>
<p>因此，我们对每一个更新操作，都在延迟一段时间后去校验其缓存数据是否正确，如果不正确，则进行修复，这样就保障了绝大多数并发导致的脏数据问题。</p>
<p>至于延迟多久，我个人建议是延迟几分钟，不能延迟太短，否则起不到兜底的效果。</p>
<p><strong>5）存在数据库更新的链路禁用对应缓存</strong></p>
<p>在数据库更新的场景里面，我们可能会有一些查询操作。例如我更新完这个数据之后，我马上又查了一下。这个时候其实如果你去走缓存，很有可能是会存在脏数据。因为他更新完之后，马上读取这个间隔是非常短的。你的缓存其实可能还没有删除完，或者存在短期内的不一致，我们还没有修复。</p>
<p>但是这种更新场景他对数据的一致性要求一般是比较高的。因为更新完之后，他要拿这个查询出来的数据去做一些其他操作。例如记录数据变更的操作日志。</p>
<p>我把一个数据从a&#x3D;1改成a&#x3D;2，我在更新之前，我先查出来a&#x3D;1，更新完之后我立马就去查出来a&#x3D;2，这个时候我就记录一条操作日志，内容是a从1变成2。</p>
<p>这种情况下，如果你在更新完之后的这个查询去走缓存，就有很大的概率查到a&#x3D;1，这时候你的操作日志就变成a从1变成1，导致操作日志是错的。</p>
<p>所以说这种更新后的查询，我们一般会让他不走缓存，因为他这个时效性就是太快了，缓存流程可能还没处理完成。</p>
<p>这个方案点其实是借鉴了MySQL事务的设计思想，MySQL中，事务对于自己更新过的内容都是实时可见的。因此，我们这边也做了一个类似的设计。</p>
<p><strong>6）强制读Redis主节点</strong></p>
<p>Redis跟MySQL一样，也会有主从副本，也会有主从延迟。当你将数据写入Redis后，马上去查Redis，可能由于查询从副本，导致读取到的是老数据，因此我们可以通过直接强制读主节点来解决这个问题，进一步增加数据的准确性。</p>
<p>Redis 不像 MySQL 有主节点压力过大的问题，Redis 是分布式的，可以将16384个槽分摊到多个分片上，每个分片的主节点部署在不同的机器上，这样强制读主时，流量也会分摊到多个机器上，不会存在MySQL的单节点压力过大问题。</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-02aad86db8c81c74b9d08764d0436191_720w.webp" class title="img">

<p><strong>7）查询异步数据一致性校验、灰度放量</strong></p>
<p>这一步是缓存功能使用前的一些保障措施，保障缓存数据是准确的。</p>
<p>对于查询异步数据一致性校验，我们一般在查询完数据库之后，通过线程池异步的再查询一次缓存，然后把这个缓存的数据跟刚才数据库查出来的数据进行比较，然后将结果进行打点统计。</p>
<p>然后查看数据一致性校验的一致率有多少，如果不一致的概率超过了1%，那可能说明我们的流程还是有问题，我们需要分析不一致的例子，找出原因，进行优化。</p>
<p>如果不一致的概率低于0.01%，那说明整个流程可能基本上已经没啥问题了。这边理论上一定会存在一些不一致的数据，因为我们查询数据库和缓存之间还是有一定的时间间隔的，可能是1毫秒这样，在高并发下，可能这个间隔之间数据已经被修改过了，所以你拿到的缓存数据和数据库数据可能其实不是一个版本，这种情况下的不一致是正常的。</p>
<p>对于灰度放量，其实就是保护我们自己的一个措施。因为缓存流程毕竟还没经过线上的验证，我们一下全切到缓存，如果万一有问题，那可能就导致大量问题，从而可能导致线上事故。</p>
<p>如果我们一开始只是使用几个门店来进行灰度，如果有问题，影响其实很小，可能是一个简单的事件，对我们基本没影响。</p>
<p>在有类似比较大的改造时，通过灰度放量的方式来逐渐上线，是一种比较安全的措施，也是比较规范的措施。</p>
<p><strong>小结：该方案的链路确实比较长，但是高并发下确实会有很多问题，因此我们需要有很多措施去保障。当然，这个方案也不是一下子就是这样的，也是通过不断的实践和采坑才逐渐演进而来的。目前该方案在我们线上环境使用了挺长一段时间了，基本没有什么问题，整体还是比较完善的。</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>缓存和数据库一致性保障方案，目前网上的资料大多是类似于方案3，如果你能在面试中说出我给的这个方案，相信可以让面试官眼前一亮，这其实就是你的加分项，可以帮助你从众多候选人之中脱颖而出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/" class="post-title-link" itemprop="url">如何保证 redis 的高并发和高可用？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-24 20:20:25 / Modified: 23:10:40" itemprop="dateCreated datePublished" datetime="2023-05-24T20:20:25+08:00">2023-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>41 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果你用 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/crs?from=20065&from_column=20065">redis</a> 缓存技术的话，肯定要考虑如何用 redis 来加多台机器，保证 redis 是高并发的，还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，即 redis 高可用。</p>
<p>由于此节内容较多，因此，会分为两个小节进行讲解。</p>
<ul>
<li>redis 主从架构</li>
<li>redis 基于哨兵实现高可用</li>
</ul>
<p>Redis 主从架构</p>
<p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/j5hcino47d.png" class title="img">

<p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<h2 id="redis-replication-的核心机制"><a href="#redis-replication-的核心机制" class="headerlink" title="redis replication 的核心机制"></a>redis replication 的核心机制</h2><ul>
<li>redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<h2 id="redis-主从复制的核心原理"><a href="#redis-主从复制的核心原理" class="headerlink" title="redis 主从复制的核心原理"></a>redis 主从复制的核心原理</h2><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p>
<p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/j1tiqlu8f3.png" class title="img">

<h3 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h3><p>从 redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p>
<p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code>。</p>
<blockquote>
<p>如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。</p>
</blockquote>
<h3 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h3><p>master 在内存中直接创建 <code>RDB</code>，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync yes</span><br><span class="line"># 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span><br><span class="line">repl-diskless-sync-delay <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<h3 id="过期-key-处理"><a href="#过期-key-处理" class="headerlink" title="过期 key 处理"></a>过期 key 处理</h3><p>slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</p>
<h2 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a>复制的完整流程</h2><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的<code>host</code>和<code>ip</code>，但是复制流程没开始。</p>
<p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node 第一次执行全量复制，将所有数据发给slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/vhgsx88g20.png" class title="img">

<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ul>
<li>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</li>
<li>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</li>
<li>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</li>
<li>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<ul>
<li>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时基于旧的数据版本对外提供服务。</li>
<li>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。</li>
</ul>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><ul>
<li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</li>
<li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是1MB。</li>
<li>msater就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</li>
</ul>
<h3 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h3><p>主从节点互相都会发送 heartbeat 信息。</p>
<p>master 默认每隔 10秒 发送一次 heartbeat，slave node 每隔 1秒 发送一个 heartbeat。</p>
<h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。</p>
<h2 id="redis-如何才能做到高可用"><a href="#redis-如何才能做到高可用" class="headerlink" title="redis 如何才能做到高可用"></a>redis 如何才能做到高可用</h2><p>如果系统在 365 天内，有 99.99% 的时间，都是可以哗哗对外提供服务的，那么就说系统是高可用的。</p>
<p>一个 slave 挂掉了，是不会影响可用性的，还有其它的 slave 在提供相同数据下的相同的对外的查询服务。</p>
<p>但是，如果 master node 死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node 还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了。</p>
<p>redis 的高可用架构，叫做 <code>failover</code> 故障转移，也可以叫做主备切换。</p>
<p>master node 在故障时，自动检测，并且将某个 slave node 自动切换位 master node的过程，叫做主备切换。这个过程，实现了 redis 的主从架构下的高可用。</p>
<p>后面会详细说明 redis 基于哨兵的高可用性。</p>
<p>redis 实现高并发主要依靠主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。</p>
<p>如果想要在实现高并发的同时，容纳大量的数据，那么就需要 redis 集群，使用 redis 集群之后，可以提供每秒几十万的读写并发。</p>
<p>redis 高可用，如果是做主从架构部署，那么加上哨兵就可以了，就可以实现，任何一个实例宕机，可以进行主备切换。</p>
<h2 id="Redis基于哨兵模式实现高可用"><a href="#Redis基于哨兵模式实现高可用" class="headerlink" title="Redis基于哨兵模式实现高可用"></a>Redis基于哨兵模式实现高可用</h2><p>在开始本章的讲解之前，我们首先从宏观角度回顾一下 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/crs?from=20065&from_column=20065">Redis</a> 实现高可用相关的技术。它们包括：持久化、复制、哨兵和集群，在本系列的前篇文章介绍了持久化以及复制的原理以及实现。本文将对剩下的两种高可用技术哨兵、集群进行讲解，讲一讲它们是如何进一步提高系统的高可用性？</p>
<p>Redis 的主从复制模式下，一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点，同时还要通知客户端更新主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制来解决这个问题。</p>
<p>在 Redis 3.0 之前，使用哨兵（sentinel）机制来监控各个节点之间的状态。Redis Cluster 是 Redis 的分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 在分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用 Cluster 架构方案达到<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/clb?from=20065&from_column=20065">负载均衡</a>的目的。</p>
<h2 id="Redis-HA-实践（Redis-Sentinel）"><a href="#Redis-HA-实践（Redis-Sentinel）" class="headerlink" title="Redis HA 实践（Redis Sentinel）"></a><strong>Redis HA 实践（Redis Sentinel）</strong></h2><h3 id="Redis-Sentinel-概述"><a href="#Redis-Sentinel-概述" class="headerlink" title="Redis Sentinel 概述"></a><strong>Redis Sentinel 概述</strong></h3><p>Sentinel（哨岗、哨兵）是 Redis 的高可用（high availability）解决方案：由一个或多个 Sentinel 实例（instance）组成的 Sentinel 系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/dy25zd7xc0.png" class title="img">

<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/uo069eiopx.png" class title="img">

<p>当 server1 的下线时长超过用户设定的下线时长上限时，Sentinel 系统就会对 server1 执行故障转移操作：</p>
<ul>
<li>首先，Sentinel 系统会挑选 server1 属下的其中一个从服务器，并将这个被选中的从服务升级为新的主服务器。</li>
<li>之后，Sentinel 系统会向 server1 属下的所有从服务器发送新的复制指令，让他们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li>
<li>另外，Sentinel 还会继续监视已下线的 server1，并在它重新上线时，将它设置为新的主服务器的从服务器。</li>
</ul>
<p>Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p>
<ul>
<li>监控（Monitoring）：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒（Notification）：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<h3 id="Redis-Sentinel-重点总结"><a href="#Redis-Sentinel-重点总结" class="headerlink" title="Redis Sentinel 重点总结"></a><strong>Redis Sentinel 重点总结</strong></h3><ul>
<li>Sentinel 只是一个运行在特殊模式下的 Redis 服务器，因此初始化服务器时将普通 Redis 服务器使用的代码替换成 Sentinel 专门代码，它使用了和普通模式不同的命令表，所以 Sentinel 模式能够使用的命令和普通 Redis 服务器能够使用的命令不同。</li>
<li>Sentinel 会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，其中命令连接用于向主服务器发送命令请求，而订阅连接则用于接收指定频道的消息。</li>
<li>Sentinel 通过主服务器发送 INFO 命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。在一般情况下，Sentinel 以每十秒一次的频率向被监视的主服务器和从服务器发送 INFO 命令，当主服务器处于下线状态，或者 Sentinel 正在对主服务器进行故障转移操作时，Sentinel 向从服务器发送 INFO 命令的频率会改为每秒一次。</li>
<li>对于监视同一个主服务器和从服务器的多个 Sentinel 来说，它们会以每两秒一次的频率，通过向被监视服务器的 <em>sentinel</em>:hello 频道发送消息来向其他 Sentinel 宣告自己的存在。每个 Sentinel 也会从 <em>sentinel</em>:hello 频道中接收其他 Sentinel 发来的消息，并根据这些消息为其他 Sentinel 创建相应的实例结构以及命令连接。Sentinel 只会与主服务器和从服务器创建命令连接和订阅连接，Sentinel 与 Sentinel 之间则只创建命令连接。</li>
<li>Sentinel 以每秒一次的频率向实例（包括主服务器、从服务器、其他 Sentinel）发送 PING 命令，并根据实例对 PING 命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向 Sentinel 发送无效回复时，Sentinel 会将这个实例判断为主观下线。</li>
<li>当 Sentinel 将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其它 Sentinel 进行询问，看它们是否同意这个主服务器已经进入主观下线状态。当 Sentinel 收集到足够多的的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。</li>
<li>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel[1]，并由领头 Sentinel 对下线主服务器进行故障转移操作。</li>
</ul>
<h3 id="Redis-Sentinel-搭建"><a href="#Redis-Sentinel-搭建" class="headerlink" title="Redis Sentinel 搭建"></a><strong>Redis Sentinel 搭建</strong></h3><h4 id="Redis-Sentinel-部署技巧及其环境"><a href="#Redis-Sentinel-部署技巧及其环境" class="headerlink" title="Redis Sentinel 部署技巧及其环境"></a><strong>Redis Sentinel 部署技巧及其环境</strong></h4><ul>
<li>一个健壮的部署至少需要三个哨兵实例，并且使用奇数个 Sentinel。</li>
<li>三个哨兵实例应该放置在客户使用独立方式确认故障的计算机或虚拟机中，例如不同的物理机或不同可用区域的虚拟机。</li>
<li>哨兵配置文件中只需要配置主从复制中的主副本 ip 和端口即可，当主从进行切换时哨兵会自动修改哨兵配置文件中的主副本 ip 为新在主副本 ip。</li>
</ul>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/49c37tz8j9.png" class title="img">

<p>由于本人没有这么多服务器，因此在一台机器上模拟一个 Redis Sentinel 集群。</p>
<table>
<thead>
<tr>
<th align="left">角色</th>
<th align="left">IP 地址</th>
<th align="left">端口号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Redis Master</td>
<td align="left">127.0.0.1</td>
<td align="left">6380</td>
</tr>
<tr>
<td align="left">Redis Slave-01</td>
<td align="left">127.0.0.1</td>
<td align="left">6381</td>
</tr>
<tr>
<td align="left">Redis Slave-02</td>
<td align="left">127.0.0.1</td>
<td align="left">6382</td>
</tr>
<tr>
<td align="left">Redis Slave-03</td>
<td align="left">127.0.0.1</td>
<td align="left">6383</td>
</tr>
<tr>
<td align="left">Redis Sentinel-01</td>
<td align="left">127.0.0.1</td>
<td align="left">26381</td>
</tr>
<tr>
<td align="left">Redis Sentinel-02</td>
<td align="left">127.0.0.1</td>
<td align="left">26382</td>
</tr>
<tr>
<td align="left">Redis Sentinel-03</td>
<td align="left">127.0.0.1</td>
<td align="left">26383</td>
</tr>
</tbody></table>
<h4 id="Redis-Sentinel-安装指南"><a href="#Redis-Sentinel-安装指南" class="headerlink" title="Redis Sentinel 安装指南"></a><strong>Redis Sentinel 安装指南</strong></h4><p>1、下载 Redis 服务软件包到服务器，解压后并编译安装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# mkdir /usr/local/redis</span><br><span class="line">[root@VM_24_98_centos ~]# wget <span class="attr">http</span>:<span class="comment">//download.redis.io/releases/redis-5.0.6.tar.gz</span></span><br><span class="line">[root@VM_24_98_centos ~]# tar -zvxf redis-<span class="number">5.0</span><span class="number">.6</span>.<span class="property">tar</span>.<span class="property">gz</span> -C /usr/local/redis</span><br><span class="line">[root@VM_24_98_centos ~]# cd /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/</span><br><span class="line">[root@VM_24_98_centos redis-<span class="number">5.0</span><span class="number">.6</span>]# make <span class="variable constant_">PREFIX</span>=<span class="regexp">/usr/</span>local/redis install</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>2、设置 Redis 主服务器</p>
<p>a. 创建目录以及复制配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/local/redis/redis-master/redis-<span class="number">6380</span></span><br><span class="line">[root@VM_24_98_centos redis-master]# cp -r /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/redis.<span class="property">conf</span> /usr/local/redis/redis-master/redis-<span class="number">6380</span>/</span><br><span class="line">[root@VM_24_98_centos redis-master]# vim /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">conf</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>b. 设置 Redis Master 主服务器配置环境</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 开启远程连接</span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"># 端口号</span><br><span class="line">port <span class="number">6380</span></span><br><span class="line"># 守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 进程文件</span><br><span class="line">pidfile /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">pid</span></span><br><span class="line"># 日志文件</span><br><span class="line">logfile /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">log</span></span><br><span class="line"># 工作目录</span><br><span class="line">dir /usr/local/redis/redis-master/redis-<span class="number">6380</span>/</span><br><span class="line"># 主服务器密码</span><br><span class="line">masterauth foobared</span><br><span class="line"># 认证密码</span><br><span class="line">requirepass foobared</span><br><span class="line"># 开启 <span class="variable constant_">AOF</span> 持久化</span><br><span class="line">appendonly yes</span><br><span class="line"># 每秒调用一次 fsync</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>c. 启动 Redis Master 主服务器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis-<span class="number">6380</span>]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">conf</span></span><br><span class="line">[root@VM_24_98_centos redis-<span class="number">6380</span>]# ps -ef |grep redis</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>d. 客户端测试连接</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6380</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">REPLICATION</span></span><br><span class="line"># <span class="title class_">Replication</span></span><br><span class="line"><span class="attr">role</span>:master</span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">master_replid</span>:5c1034ac4dec31d6a4ae883e1eaacca3a78bc3b6</span><br><span class="line"><span class="attr">master_replid2</span>:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:-<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="number">1048576</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>3、设置 Redis 从服务器</p>
<p>a. 创建目录以及复制配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/local/redis/redis-slave/redis-<span class="number">6381</span></span><br><span class="line">[root@VM_24_98_centos redis-slave]# cp -r /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/redis.<span class="property">conf</span> /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/</span><br><span class="line">[root@VM_24_98_centos redis-slave]# vim /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/redis.<span class="property">conf</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>b. 设置 Redis Slave 从服务器配置环境</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 开启远程连接</span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"># 端口号</span><br><span class="line">port <span class="number">6381</span></span><br><span class="line"># 守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 进程文件</span><br><span class="line">pidfile /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/redis.<span class="property">pid</span></span><br><span class="line"># 日志文件</span><br><span class="line">logfile /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/redis.<span class="property">log</span></span><br><span class="line"># 工作目录</span><br><span class="line">dir /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/</span><br><span class="line"># 主从复制 <span class="title class_">Master</span> 节点地址 + 端口</span><br><span class="line">replicaof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6380</span></span><br><span class="line"># 主服务器密码</span><br><span class="line">masterauth foobared</span><br><span class="line"># 认证密码</span><br><span class="line">requirepass foobared</span><br><span class="line"># 开启 <span class="variable constant_">AOF</span> 持久化</span><br><span class="line">appendonly yes</span><br><span class="line"># 每秒调用一次 fsync</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>c. 启动 Redis Slave 从服务器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis-<span class="number">6381</span>]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/redis.<span class="property">conf</span></span><br><span class="line">[root@VM_24_98_centos redis-<span class="number">6381</span>]# ps -ef |grep redis</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>d. 客户端测试连接</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/redis.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6381</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6381</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">REPLICATION</span></span><br><span class="line"># <span class="title class_">Replication</span></span><br><span class="line"><span class="attr">role</span>:slave</span><br><span class="line"><span class="attr">master_host</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">master_port</span>:<span class="number">6380</span></span><br><span class="line"><span class="attr">master_link_status</span>:up</span><br><span class="line"><span class="attr">master_last_io_seconds_ago</span>:<span class="number">5</span></span><br><span class="line"><span class="attr">master_sync_in_progress</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">slave_repl_offset</span>:<span class="number">14</span></span><br><span class="line"><span class="attr">slave_priority</span>:<span class="number">100</span></span><br><span class="line"><span class="attr">slave_read_only</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">master_replid</span>:8ecb8d89dba51e54aabb1c7feeda42fe6e6a8dc0</span><br><span class="line"><span class="attr">master_replid2</span>:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="number">14</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:-<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="number">1048576</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>e. 同理，从服务器 redis-6382、redis-6383 按照上面的步骤部署。</p>
<p>4、Redis Sentinel 部署</p>
<p>a. 创建目录以及复制配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span></span><br><span class="line">[root@VM_24_98_centos redis-sentinel]# cp -r /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/sentinel.<span class="property">conf</span> /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/</span><br><span class="line">[root@VM_24_98_centos redis-sentinel]# vim /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/sentinel.<span class="property">conf</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>b. 设置 Redis Sentinel 哨兵服务器配置环境</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 端口号</span><br><span class="line">port <span class="number">26381</span></span><br><span class="line"># 守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 进程文件</span><br><span class="line">pidfile /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/redis.<span class="property">pid</span></span><br><span class="line"># 日志文件</span><br><span class="line">logfile /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/redis.<span class="property">log</span></span><br><span class="line"># 工作目录</span><br><span class="line">dir /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/</span><br><span class="line"># 指定监控 master&#123;<span class="number">2</span> 表示多少个 sentinel 同意&#125;</span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6380</span> <span class="number">2</span></span><br><span class="line"># 安全信息</span><br><span class="line">sentinel auth-pass mymaster foobared</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>c. 启动 Redis Sentinel 哨兵服务器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis-<span class="number">26381</span>]# /usr/local/redis/bin/redis-sentinel /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/sentinel.<span class="property">conf</span></span><br><span class="line">[root@VM_24_98_centos redis-<span class="number">26381</span>]# ps -ef |grep redis</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>d. 客户端测试连接</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">26381</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">26381</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">SENTINEL</span></span><br><span class="line"># <span class="title class_">Sentinel</span></span><br><span class="line"><span class="attr">sentinel_masters</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">sentinel_tilt</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_running_scripts</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_scripts_queue_length</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_simulate_failure_flags</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">master0</span>:name=mymaster,status=ok,address=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>,slaves=<span class="number">3</span>,sentinels=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>e. 同理，哨兵服务器 redis-26382、redis-26383 按照上面的步骤部署</p>
<p>f. 查看 Redis Master 主服务器连接状况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6380</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">REPLICATION</span></span><br><span class="line"># <span class="title class_">Replication</span></span><br><span class="line"><span class="attr">role</span>:master</span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="number">3</span></span><br><span class="line"><span class="attr">slave0</span>:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">6383</span>,state=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line"><span class="attr">slave1</span>:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">6381</span>,state=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line"><span class="attr">slave2</span>:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">6382</span>,state=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line"><span class="attr">master_replid</span>:cc8ef3fe2e51a714f5b73b2fbe3bd697cacbc453</span><br><span class="line"><span class="attr">master_replid2</span>:8ecb8d89dba51e54aabb1c7feeda42fe6e6a8dc0</span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="number">20836</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:<span class="number">1522</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="number">1048576</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="number">20836</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<h3 id="Redis-Sentinel-场景测试"><a href="#Redis-Sentinel-场景测试" class="headerlink" title="Redis Sentinel 场景测试"></a><strong>Redis Sentinel 场景测试</strong></h3><p>模拟场景：Redis Master 节点挂掉，查看 Redis 集群状态。</p>
<p>Step1、关掉 Master 节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6380</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; <span class="variable constant_">SHUTDOWN</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>Step2、通过哨兵查看集群状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">26381</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">26381</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">SENTINEL</span></span><br><span class="line"># <span class="title class_">Sentinel</span></span><br><span class="line"><span class="attr">sentinel_masters</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">sentinel_tilt</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_running_scripts</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_scripts_queue_length</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_simulate_failure_flags</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">master0</span>:name=mymaster,status=ok,address=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6381</span>,slaves=<span class="number">3</span>,sentinels=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>通过 Sentinel 信息可以看到，Master 节点已经自动切换到 6381 端口了，说明主节点挂掉后，6381 Slave 节点自动升级成为了 Master 节点。</p>
<p>通过 Sentinel 日志文件显示了 failover 的过程：</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/it3cdc8xvp.png" class title="img">

<p>Step3、启动 6380 Redis 服务，然后查看节点角色，此时 6380 变成了 Slave，6381 为 Master 节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6380</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">REPLICATION</span></span><br><span class="line"># <span class="title class_">Replication</span></span><br><span class="line"><span class="attr">role</span>:slave</span><br><span class="line"><span class="attr">master_host</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">master_port</span>:<span class="number">6381</span></span><br><span class="line"><span class="attr">master_link_status</span>:up</span><br><span class="line"><span class="attr">master_last_io_seconds_ago</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">master_sync_in_progress</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">slave_repl_offset</span>:<span class="number">782228</span></span><br><span class="line"><span class="attr">slave_priority</span>:<span class="number">100</span></span><br><span class="line"><span class="attr">slave_read_only</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">master_replid</span>:84aa69ee0b191bba31162c26c4ddb1c87a705f7e</span><br><span class="line"><span class="attr">master_replid2</span>:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="number">782228</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:-<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="number">1048576</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="number">777789</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="number">4440</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<h2 id="Redis-HA-实践（Redis-Cluster）"><a href="#Redis-HA-实践（Redis-Cluster）" class="headerlink" title="Redis HA 实践（Redis Cluster）"></a><strong>Redis HA 实践（Redis Cluster）</strong></h2><h3 id="Redis-Cluster-概述"><a href="#Redis-Cluster-概述" class="headerlink" title="Redis Cluster 概述"></a><strong>Redis Cluster 概述</strong></h3><p>Redis 集群是 Redis 提供的分布式<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/database?from=20065&from_column=20065">数据库</a>方案，集群通过分片（sharding）而非一致性哈希（consistency hashing）来进行数据分享，并提供复制和故障转移功能。Redis Cluster，主要是针对海量数据 + 高并发 + 高可用的场景。Redis Cluster 支撑 N 个 Redis Master Node，每个 Master Node 都可以挂载多个 Slave Node。Redis Cluster 节点间采用 Gossip 协议[2]进行通信。</p>
<p>节点：一个 Redis 集群通常由多个节点（node）组成，连接各个节点的工作可以使用 CLUSTER MEET <ip> <port> 命令来完成，将各个独立的节点连接起来，构成一个包含多个节点的集群。向一个节点 node 发送 CLUSTER MEET 命令，可以让 node 节点与 ip 和 port 所指定的节点进行握手（handshake），当握手成功时，node 节点就会将 ip 和 port 所指定的节点添加到 node 节点当前所在的集群中。</port></ip></p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/7eyyyn1obp.png" class title="img">

<p><strong>槽指派</strong>：Redis 集群通过分片的方式来保存数据库中的键值对，集群的整数据库被分为 16384 个槽（slot），数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。Redis 集群有固定的 16384 个 hash slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/808e3izvdh.png" class title="img">

<h3 id="Redis-Cluster-重点总结"><a href="#Redis-Cluster-重点总结" class="headerlink" title="Redis Cluster 重点总结"></a><strong>Redis Cluster 重点总结</strong></h3><ul>
<li>节点通过握手来将其他节点添加到自己所处的集群当中。</li>
<li>集群中的 16384（2的14次方）个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给其他节点。</li>
<li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</li>
<li>对 Redis 集群的重新分片工作是由 redis-trib 负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另外一个节点。重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</li>
<li>如果节点 A 正在迁移槽 i 至节点 B，那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时，节点 A 会向客户端返回一个 ASK 错误，指引客户端到节点 B 继续查找指定的数据库键。</li>
<li>MOVED 错误表示槽的负责权已经从一个节点转移到了另外一个节点，而 ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。</li>
<li>Redis 集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</li>
<li>集群中的节点通过发送和接收消息来进行通信，常见的消息包括 MEET、PING、PONG、PUBLISH、FAIL 五种。</li>
</ul>
<h3 id="Redis-Cluster-与-Redis-Sentinel-区别"><a href="#Redis-Cluster-与-Redis-Sentinel-区别" class="headerlink" title="Redis Cluster 与 Redis Sentinel 区别"></a><strong>Redis Cluster 与 Redis Sentinel 区别</strong></h3><ul>
<li>哨兵模式监控权交给了哨兵系统，集群模式中是工作节点自己做监控。</li>
<li>哨兵模式发起选举是选举一个 leader 哨兵节点来处理故障转移，集群模式是在从节点中选举一个新的主节点，来处理故障的转移。</li>
</ul>
<h3 id="Redis-Cluster-搭建"><a href="#Redis-Cluster-搭建" class="headerlink" title="Redis Cluster 搭建"></a><strong>Redis Cluster 搭建</strong></h3><h4 id="Redis-Cluster-部署技巧及其环境"><a href="#Redis-Cluster-部署技巧及其环境" class="headerlink" title="Redis Cluster 部署技巧及其环境"></a><strong>Redis Cluster 部署技巧及其环境</strong></h4><ul>
<li>Redis 集群至少需要 3 个节点，因为投票容错机制要求超过半数节点认为某个节点挂了该节点才是挂了，所以 2 个节点无法构成集群。</li>
<li>要保证集群的高可用，需要每个节点都有从节点，也就是备份节点，即三主三从，所以 Redis 集群至少需要 6 台服务器。</li>
<li>Redis 5.0 开始不再使用 Ruby 搭建集群，而是直接使用客户端命令 redis-cli 来创建。</li>
<li>不支持多数据库空间，集群模式下只能使用 db0 空间。</li>
</ul>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/k8zcq5yvs2.png" class title="img">

<p>由于资源有限，因此在一台机器上模拟一个 Redis Cluster。</p>
<table>
<thead>
<tr>
<th align="left">角色</th>
<th align="left">IP 地址</th>
<th align="left">端口号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Redis Cluster-Master-01-6391</td>
<td align="left">127.0.0.1</td>
<td align="left">6391</td>
</tr>
<tr>
<td align="left">Redis Cluster-Master-02-6393</td>
<td align="left">127.0.0.1</td>
<td align="left">6393</td>
</tr>
<tr>
<td align="left">Redis Cluster-Master-02-6395</td>
<td align="left">127.0.0.1</td>
<td align="left">6395</td>
</tr>
<tr>
<td align="left">Redis Cluster-Slave-01-6394</td>
<td align="left">127.0.0.1</td>
<td align="left">6394</td>
</tr>
<tr>
<td align="left">Redis Cluster-Slave-02-6396</td>
<td align="left">127.0.0.1</td>
<td align="left">6396</td>
</tr>
<tr>
<td align="left">Redis Cluster-Slave-03-6392</td>
<td align="left">127.0.0.1</td>
<td align="left">6392</td>
</tr>
</tbody></table>
<h4 id="Redis-Cluster-安装指南"><a href="#Redis-Cluster-安装指南" class="headerlink" title="Redis Cluster 安装指南"></a><strong>Redis Cluster 安装指南</strong></h4><p>1、下载 Redis 服务软件包到服务器，解压后并编译安装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# mkdir /usr/local/redis</span><br><span class="line">[root@VM_24_98_centos ~]# wget <span class="attr">http</span>:<span class="comment">//download.redis.io/releases/redis-5.0.6.tar.gz</span></span><br><span class="line">[root@VM_24_98_centos ~]# tar -zvxf redis-<span class="number">5.0</span><span class="number">.6</span>.<span class="property">tar</span>.<span class="property">gz</span> -C /usr/local/redis</span><br><span class="line">[root@VM_24_98_centos ~]# cd /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/</span><br><span class="line">[root@VM_24_98_centos redis-<span class="number">5.0</span><span class="number">.6</span>]# make <span class="variable constant_">PREFIX</span>=<span class="regexp">/usr/</span>local/redis install</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>2、设置 Redis Cluster 服务器</p>
<p>a. 创建目录以及复制配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# mkdir -p /usr/local/redis/redis-cluster/redis-<span class="number">6391</span></span><br><span class="line">[root@VM_24_98_centos ~]# cp -r /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/redis.<span class="property">conf</span> /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/</span><br><span class="line">[root@VM_24_98_centos ~]# vim /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">conf</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>b. 设置 Redis Cluster 服务器配置环境</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 开启远程连接</span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"># </span><br><span class="line">protected-mode no</span><br><span class="line"># 端口号</span><br><span class="line">port <span class="number">6391</span></span><br><span class="line"># 守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 进程文件</span><br><span class="line">pidfile /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">pid</span></span><br><span class="line"># 日志文件</span><br><span class="line">logfile /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">log</span></span><br><span class="line"># 工作目录</span><br><span class="line">dir /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/</span><br><span class="line"># 主服务器密码</span><br><span class="line">masterauth foobared</span><br><span class="line"># 认证密码</span><br><span class="line">requirepass foobared</span><br><span class="line"># 开启 <span class="variable constant_">AOF</span> 持久化</span><br><span class="line">appendonly yes</span><br><span class="line"># 每秒调用一次 fsync</span><br><span class="line">appendfsync everysec</span><br><span class="line"># 开启集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 集群的配置文件，首次启动会自动创建</span><br><span class="line">cluster-config-file nodes.<span class="property">conf</span></span><br><span class="line"># 集群节点连接超时时间，<span class="number">15</span>秒</span><br><span class="line">cluster-node-timeout <span class="number">15000</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>c. 启动 Redis Cluster 服务器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">conf</span></span><br><span class="line">[root@VM_24_98_centos ~]# ps -ef |grep redis</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>d. 客户端测试连接</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">INFO</span></span><br><span class="line"><span class="attr">cluster_state</span>:fail</span><br><span class="line"><span class="attr">cluster_slots_assigned</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_slots_ok</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_slots_pfail</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_slots_fail</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_known_nodes</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">cluster_size</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_current_epoch</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_my_epoch</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_stats_messages_sent</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_stats_messages_received</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>e. 同理，集群服务器 redis-6392、redis-6393 、redis-6394、redis-6395、redis-6396 按照上面的步骤部署</p>
<p>3、Redis 5.0 开始不再使用 ruby 搭建集群，而是直接使用客户端命令 redis-cli 来创建。</p>
<p>a. 创建顺序三主三从，前面三个是主后面三个是从。由于我们设置了redis集群的密码，所以要带上密码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli --cluster create <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6395</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6392</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6394</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6396</span> --cluster-replicas <span class="number">1</span> -a foobared</span><br></pre></td></tr></table></figure>

<p>复制</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/9n5cusr6j9.png" class title="img">

<p>b. 客户端测试连接</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">INFO</span></span><br><span class="line"><span class="attr">cluster_state</span>:ok</span><br><span class="line"><span class="attr">cluster_slots_assigned</span>:<span class="number">16384</span></span><br><span class="line"><span class="attr">cluster_slots_ok</span>:<span class="number">16384</span></span><br><span class="line"><span class="attr">cluster_slots_pfail</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_slots_fail</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_known_nodes</span>:<span class="number">6</span></span><br><span class="line"><span class="attr">cluster_size</span>:<span class="number">3</span></span><br><span class="line"><span class="attr">cluster_current_epoch</span>:<span class="number">6</span></span><br><span class="line"><span class="attr">cluster_my_epoch</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">cluster_stats_messages_ping_sent</span>:<span class="number">1153</span></span><br><span class="line"><span class="attr">cluster_stats_messages_pong_sent</span>:<span class="number">1241</span></span><br><span class="line"><span class="attr">cluster_stats_messages_sent</span>:<span class="number">2394</span></span><br><span class="line"><span class="attr">cluster_stats_messages_ping_received</span>:<span class="number">1236</span></span><br><span class="line"><span class="attr">cluster_stats_messages_pong_received</span>:<span class="number">1153</span></span><br><span class="line"><span class="attr">cluster_stats_messages_meet_received</span>:<span class="number">5</span></span><br><span class="line"><span class="attr">cluster_stats_messages_received</span>:<span class="number">2394</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">NODES</span></span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6394</span>@<span class="number">16394</span> slave c54ebef126b30b5bd9cb157ccc0b6ddb952a1f50 <span class="number">0</span> <span class="number">1574234724000</span> <span class="number">5</span> connected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span>@<span class="number">16393</span> master - <span class="number">0</span> <span class="number">1574234725711</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line">43c325955c74f0ed79de6850dca8a509195acb13 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6392</span>@<span class="number">16392</span> slave 718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">0</span> <span class="number">1574234724000</span> <span class="number">4</span> connected</span><br><span class="line">3a32043079bf6af3723230ee3e6412e84dd66180 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574234724708</span> <span class="number">6</span> connected</span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb952a1f50 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>@<span class="number">16391</span> myself,master - <span class="number">0</span> <span class="number">1574234725000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line">718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6395</span>@<span class="number">16395</span> master - <span class="number">0</span> <span class="number">1574234723000</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p><strong>Redis Cluster 场景测试</strong></p>
<p>（1）模拟场景：Redis Cluster 中 某个 Master 节点挂掉，查看 Redis Cluster 状态。</p>
<p>Step1、关掉 Cluster-Master-6391 节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">SHUTDOWN</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>Step2、查看集群状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6393</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">NODES</span></span><br><span class="line">43c325955c74f0ed79de6850dca8a509195acb13 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6392</span>@<span class="number">16392</span> slave 718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">0</span> <span class="number">1574236204772</span> <span class="number">4</span> connected</span><br><span class="line">3a32043079bf6af3723230ee3e6412e84dd66180 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574236206778</span> <span class="number">6</span> connected</span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6394</span>@<span class="number">16394</span> master - <span class="number">0</span> <span class="number">1574236201000</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line">718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6395</span>@<span class="number">16395</span> master - <span class="number">0</span> <span class="number">1574236206000</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb952a1f50 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>@<span class="number">16391</span> master,fail - <span class="number">1574236049092</span> <span class="number">1574236047289</span> <span class="number">1</span> disconnected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span>@<span class="number">16393</span> myself,master - <span class="number">0</span> <span class="number">1574236204000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>通过 CLUSTER NODES 信息可以看到，Cluster-Master-01-6391 主节点处于下线状态（fail），其 Cluster-Master-01-6391 节点的从节点 Cluster-Slave-01-6394 变为主节点；说明主节点挂掉后，6394 Slave 节点自动升级成为了 Master 节点。</p>
<p>Step3、启动 6391 Redis 服务，然后查看节点角色，此时 6391 变成了 Slave，6394 为 Master 节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">NODES</span></span><br><span class="line">43c325955c74f0ed79de6850dca8a509195acb13 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6392</span>@<span class="number">16392</span> slave 718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">0</span> <span class="number">1574238264397</span> <span class="number">4</span> connected</span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb952a1f50 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>@<span class="number">16391</span> myself,slave cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">0</span> <span class="number">1574238261000</span> <span class="number">1</span> connected</span><br><span class="line">3a32043079bf6af3723230ee3e6412e84dd66180 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574238265400</span> <span class="number">6</span> connected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span>@<span class="number">16393</span> master - <span class="number">0</span> <span class="number">1574238263000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line">718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6395</span>@<span class="number">16395</span> master - <span class="number">0</span> <span class="number">1574238263000</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6394</span>@<span class="number">16394</span> master - <span class="number">0</span> <span class="number">1574238264000</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>（2）模拟场景：为 Redis Cluster 添加一个新主（master）节点</p>
<p>Step1、按照上面的步骤新增一 Redis Cluster 服务器 Cluster-Master-04-6397</p>
<p>Step2、将 Cluster-Master-04-6397 节点加入 Redis Cluster 中（127.0.0.1:6391 为集群中任意可用的节点）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli --cluster add-node <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6397</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>  -a foobared</span><br></pre></td></tr></table></figure>

<p>复制</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/n11rtq4vp6.png" class title="img">

<p><strong>Step3、为节点 Cluster-Master-04-6397 分配 slots（127.0.0.1:6391 为集群中任意可用的节点）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis-cluster]# /usr/local/redis/bin/redis-cli --cluster reshard <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span> -a foobared</span><br></pre></td></tr></table></figure>

<p>复制</p>
<img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/lj99ax1xuh.png" class title="img">

<p>（3）模拟场景：为 Redis Cluster 某个 Master 节点添加 一个新从（slave）节点</p>
<p>Step1、按照上面的步骤新增一 Redis Cluster 服务器 Cluster-Slave-04-6398</p>
<p>Step2、将 Cluster-Slave-04-6398 节点加入 Redis Cluster 中（127.0.0.1:6391 为集群中任意可用的节点）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种方法随机为 6398 指定一个 master</span></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli --cluster add-node <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6398</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span> --cluster-slave -a foobared</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方式将为 6398 指定某个 master-id</span></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli --cluster add-node <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6398</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span> --cluster-slave --cluster-master-id 5cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c -a foobared</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>Step3、查看集群状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">NODES</span></span><br><span class="line">5cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6397</span>@<span class="number">16397</span> master - <span class="number">0</span> <span class="number">1574243297701</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">1364</span> <span class="number">5461</span>-<span class="number">6826</span> <span class="number">10923</span>-<span class="number">12287</span></span><br><span class="line">207628f6fb8b3bb9a22db757507350fb880d4990 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6396</span>@<span class="number">16396</span> slave 94af5d349465be57400b6a4a1d770d56ad3d94ce <span class="number">0</span> <span class="number">1574243294000</span> <span class="number">6</span> connected</span><br><span class="line">94af5d349465be57400b6a4a1d770d56ad3d94ce <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span>@<span class="number">16393</span> master - <span class="number">0</span> <span class="number">1574243296700</span> <span class="number">2</span> connected <span class="number">6827</span>-<span class="number">10922</span></span><br><span class="line">2e0134b0a87a73903d4774b6b37dd43e78e93733 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>@<span class="number">16391</span> myself,master - <span class="number">0</span> <span class="number">1574243292000</span> <span class="number">1</span> connected <span class="number">1365</span>-<span class="number">5460</span></span><br><span class="line">21a288afc7b6addebcd943ca606dd34f6b9c99db <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6398</span>@<span class="number">16398</span> slave 5cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c <span class="number">0</span> <span class="number">1574243295697</span> <span class="number">7</span> connected</span><br><span class="line">63bc9da88066b475bd878a56a11dd18023b211b6 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6394</span>@<span class="number">16394</span> slave 2e0134b0a87a73903d4774b6b37dd43e78e93733 <span class="number">0</span> <span class="number">1574243295000</span> <span class="number">5</span> connected</span><br><span class="line">c3d20b7f2df806ec87f3d45a7e334b5a2d3abe5b <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6395</span>@<span class="number">16395</span> master - <span class="number">0</span> <span class="number">1574243296000</span> <span class="number">3</span> connected <span class="number">12288</span>-<span class="number">16383</span></span><br><span class="line">f6a7c788d9e5d40bc62a3723ba02c25607cc2825 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6392</span>@<span class="number">16392</span> slave c3d20b7f2df806ec87f3d45a7e33</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">Redis教程：Redis 持久化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-24 20:04:55 / Modified: 20:45:46" itemprop="dateCreated datePublished" datetime="2023-05-24T20:04:55+08:00">2023-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis 持久化方式</p>
<hr>
<h1 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h1><p>概述</p>
<p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。</p>
<p>你也可以通过调用 SAVE或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。 比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集:</p>
<p>save 60 1000</p>
<p>这种持久化方式被称为快照 snapshotting.</p>
<h2 id="何时执行快照"><a href="#何时执行快照" class="headerlink" title="何时执行快照"></a><strong>何时执行快照</strong></h2><p>出现下面的情况redis会快照内存里的数据</p>
<ul>
<li>用户发送bgsave命令(此时redis会fork一个子进程,子进程负责生成硬盘文件,父进程负责继续接受命令)</li>
<li>用户发送save命令(和bgsave命令不同,发送save命令后,到系统创建快照完成之前系统不会再接收新的命令,换 句话说save命令会阻塞后面的命令,而bgsave不会)</li>
<li>用户在配置文件了配置了类似这样的命令 save 60 1000</li>
<li>这个的意思是说,自从上次快照成功算起,如果满足”60秒内有1000次写入”这个条件,系统就自动调用bgsave,如 果配置文件里有多个save命令,只有满足一个就调用bgsave命令</li>
<li>用户发送shutdown,系统会先执行save命令阻塞客户端,然后关闭服务器</li>
<li>当有主从架构时,从服务器向主服务器发送sync命令来执行复制操作时,只有主服务器当时没有进行bgsave操 作,那么主服务器就会执行bgsave操作。</li>
</ul>
<h2 id="快照的配置信息"><a href="#快照的配置信息" class="headerlink" title="快照的配置信息"></a><strong>快照的配置信息</strong></h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br><span class="line">stop-writes-on-bgsave-error no rdbcompression yes</span><br><span class="line">dbﬁlename dump.rdb</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure>

<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a><strong>工作方式</strong></h2><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作: Redis 调用forks. 同时拥有父进程和子进程。</p>
<p>子进程将数据集写入到一个临时 RDB 文件中。</p>
<p>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p>
<h1 id="只追加操作的文件（Append-only-ﬁle，AOF"><a href="#只追加操作的文件（Append-only-ﬁle，AOF" class="headerlink" title="只追加操作的文件（Append-only ﬁle，AOF)"></a>只追加操作的文件（Append-only ﬁle，AOF)</h1><p>概述</p>
<p>快照功能并不是非常耐久（dura ble）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p>
<p>你可以在配置文件中打开AOF方式:</p>
<p>appendonly yes</p>
<p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p>
<h2 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a><strong>日志重写</strong></h2><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p>
<p>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建</p>
<p>（rebuild）。执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件。</p>
<h2 id="AOF有多耐用"><a href="#AOF有多耐用" class="headerlink" title="AOF有多耐用"></a><strong>AOF有多耐用</strong></h2><p>你可以配置 Redis 多久才将数据 fsync (从缓存区输入)到磁盘一次。有三种方式：</p>
<p>每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全</p>
<p>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。</p>
<p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p>
<p><strong>如果AOF文件损坏了怎么办？</strong></p>
<p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</p>
<ol>
<li>为现有的 AOF 文件创建一个备份。</li>
<li>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复: redis-check-aof –ﬁx</li>
<li>（可选）使用 diﬀ -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。</li>
<li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</li>
</ol>
<p><strong>AOP重写原理</strong></p>
<p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制: redis 执行 fork() ，现在同时拥有父进程和子进程。</p>
<p>子进程开始将新 AOF 文件的内容写入到临时文件。</p>
<p>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</p>
<p>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据 追加到新 AOF 文件的末尾。</p>
<p>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</p>
<p><strong>怎样从RDB方式切换为AOF方式</strong></p>
<p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换到 AOF ： 为最新的 dump.rdb 文件创建一个备份。</p>
<p>将备份放到一个安全的地方。</p>
<p>执行以下两条命令:</p>
<p>-redis-cli conﬁg set appendonly yes redis-cli conﬁg set save “”</p>
<p>确保写命令会被正确地追加到 AOF 文件的末尾。</p>
<p>执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。</p>
<p>执行的第二条命令用于关闭 RDB 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 RDB 和 AOF 这两种持久化功能。</p>
<p>重要:别忘了在 redis.conf 中打开 AOF 功能！ 否则的话， 服务器重启之后， 之前通过 CONFIG SET 设置的配置就会被遗忘， 程序会按原来的配置来启动服务器。</p>
<p><strong>AOF和RDB之间的相互作用</strong></p>
<p>在版本号大于等于 2.4 的 Redis 中， BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE。这可以防止两个 Redis 后台进程同时对磁盘进行大量的I&#x2F;O 操作。</p>
<p>如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户， BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。 当Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为AOF 文件所保存的数据通常是最完整的。</p>
<p><strong>AOF VS RDB</strong></p>
<p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p>
<p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数 据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF</p>
<p>文件的体积不至于过大.</p>
<p>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p>
<p>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p>
<p>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始:</p>
<p><strong>RDB的优缺点</strong></p>
<p>优点</p>
<p>RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个 小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需 求恢复到不同版本的数据集.</p>
<p>RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用 于灾难恢复.</p>
<p>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父 进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能.</p>
<p>与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些.</p>
<p>缺点</p>
<p>如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽 然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存 整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕 机,你可能会丢失几分钟的数据.</p>
<p>RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这 种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度.</p>
<p><strong>AOF 优缺点</strong></p>
<p>优点 -</p>
<p>使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync. 使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户 端请求),一旦出现故障，你最多丢失1秒的数据.</p>
<p>AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过 程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题.</p>
<p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>
<p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到FLUSHALL 执行之前的状态。</p>
<p>缺点 -</p>
<p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</p>
<p>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</p>
<p><strong>备份redis数据</strong></p>
<p>在阅读这个小节前， 请牢记下面这句话: 确保你的数据由完整的备份. 磁盘故障， 节点失效， 诸如此类的问题都可能让你的数据消失不见， 不进行备份是非常危险的。</p>
<p>Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。</p>
<p>这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。</p>
<p>创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。</p>
<p>确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 ﬁnd 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。</p>
<p>至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">PATH=/usr/local/bin:$PATH</span><br><span class="line">redis-cli SAVE</span><br><span class="line">date=$(date +&quot;%Y%m%d&quot;)</span><br><span class="line">cp /var/lib/redis/6379/dump.rdb /data01/cache_backup/$date.rdb</span><br><span class="line">echo &quot;done!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>容灾备份</strong></p>
<p>Redis 的容灾备份基本上就是对数据进行备份， 并将这些备份传送到多个不同的外部数据中心。容灾备份可以在</p>
<p>Redis 运行并产生快照的主数据中心发生严重的问题时， 仍然让数据处于安全状态。</p>
<p>因为很多 Redis 用户都是创业者， 他们没有大把大把的钱可以浪费， 所以下面介绍的都是一些实用又便宜的容灾备份方法：</p>
<p>Amazon S3 ，以及其他类似 S3 的服务，是一个构建灾难备份系统的好地方。 最简单的方法就是将你的每小时或者每日 RDB 备份加密并传送到 S3 。 对数据的加密可以通过 gpg -c 命令来完成（对称加密模式）。 记得把你的密码放到几个不同的、安全的地方去（比如你可以把密码复制给你组织里最重要的人物）。 同时使用多个储存服务来保存数据文件，可以提升数据的安全性。</p>
<p>传送快照可以使用 SCP 来完成（SSH 的组件）。 以下是简单并且安全的传送方法： 买一个离你的数据中心非常远的 VPS ， 装上 SSH ， 创建一个无口令的 SSH 客户端 key ， 并将这个 key 添加到 VPS 的authorized_keys 文件中， 这样就可以向这个 VPS 传送快照备份文件了。 为了达到最好的数据安全性， 至少要从两个不同的提供商那里各购买一个 VPS 来进行数据容灾备份。</p>
<p>需要注意的是， 这类容灾系统如果没有小心地进行处理的话， 是很容易失效的。最低限度下， 你应该在文件传送完毕之后， 检查所传送备份文件的体积和原始快照文件的体积是否相同。 如果你使用的是VPS ， 那么还可以通过比对文件的 SHA1 校验和来确认文件是否传送完整。</p>
<p>另外， 你还需要一个独立的警报系统， 让它在负责传送备份文件的传送器（transfer）失灵时通知你。</p>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF<strong>重写</strong></h2><p>很多软件，都会对日志下手，因为，日志的优点保住，还是不错的，就是可以尽量不丢失数据，并且，同时克服一下它的缺点，就是把体量变小，恢复变快。所以，redis 的也采取了一定的做法：在 4.0 以前，有一个机制叫做重写。比如，回到之前的例子，不断创建 key，删除 key；那么，你可以发现，这样的操作，都可以抵消，对不对。再比如，假设有一个 list，你不断往里面 push 1W 个 v，那么，是不是就可以只写一条 push 语句，然后让它执行 1W 次就 ok？所以，总结一下，就是：<strong>删除抵消的，合并重复的。</strong></p>
<p>现在也知道了，最终得到的也是一个纯指令的 AOF 文件虽然指令被削减了一部分，但是纯指令，还是得一条条去恢复，所以效率还是有些低的。所以，后来，redis 偷偷地学习了 hdfs 的优点，就是，从 4.0 版本开始，AOF 会包含 RDB 全量，然后追加新的写操作。<br>而包含一个 RDB 全量之后，就可以直接把数据给导入内存即可，不用一步一步的操作。而追加的一部分写操作，又可以保证数据的全。在重写的时候，会先把老的数据，以 RDB 的形式，存到 AOF 文件中，然后，再把增量的，以指令的方式存入 AOF。AOF 就会包含二进制数据和增量的日志，于是就成了一个混合体。于是，这么改进，AOF 就把两个优点都占有了：既有 RDB 的快；又有 AOF 的全。fsync的间隔这样，明白了 AOF 之后，我们继续回头。redis 既然是一个内存级 kv 数据库，那么，这时写操作就会触发 I&#x2F;O，<br>那这样的话，就会影响 redis 的写速度，就会变慢。</p>
<p>redis 给了 3 个级别：</p>
<p><strong>NO</strong><br>        <strong>ALWAYS</strong><br><strong>everysec</strong><br>首先，如果你还不知道 fsync 是什么，那我得先简单描述一下：<br>传统的 UNIX 实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘 I&#x2F;O 都通过缓冲进行。<br>当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的 I&#x2F;O 操作。<br>这种输出方式被称为延迟写（delayed write）</p>
<p>延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，于是，就可能使得写到文件中的数据在一段时间内并没有写到磁盘上。这样，当系统发生故障时，这种延迟可能造成文件更新内容的丢失。所以，redis 给出的三个级别，就是让我们在数据可能丢失的数量、和性能之间，做出一个权衡。假设，我们采用 NO，从不手动将数据刷入磁盘，无疑，由于不用一直写磁盘，所以 redis 的性能，一定是最高的。但是，这样，就只有在缓冲区满了的时候，才会刷数据到磁盘。于是，在宕机的时候，会丢失的数据，则会有很多。假设，我们采用 ALWAYS，每次写，都将指令追加到 AOF。这样，我们最多最多，丢失一条数据（就是最后哪一条还没来得及写进磁盘的时候）。但是，由于每笔操作都往磁盘刷写，那性能一定是会受到很大的影响。所以，很多时候，会倾向于使用 everysec，每秒。<br>这样的话，由于不会次次写磁盘，所以对性能的影响还不至于那么大，而且，时间间隔也只有一秒，即使丢失，影响也不会太大。<br>所以，这往往作为一个折中方案。</p>
<h2 id="AOF-重写控制与详解"><a href="#AOF-重写控制与详解" class="headerlink" title="AOF 重写控制与详解"></a>AOF 重写控制与详解</h2><p>描述：Redis 生成新的 AOF 文件来代替旧 AOF 文件，这个新的 AOF 文件包含重建当前数据集所需的最少命令。具体过程是遍历所有数据库的所有键，从数据库读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。</p>
<p>命令：有两个 Redis 命令可以用于触发 AOF 重写，一个是 BGREWRITEAOF 、另一个是 REWRITEAOF 命令；</p>
<p>开启：AOF 重写由两个参数共同控制，auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size，同时满足这两个条件，则触发 AOF 后台重写 BGREWRITEAOF。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前AOF文件比上次重写后的AOF文件大小的增长比例超过100 </span><br><span class="line">auto-aof-rewrite-percentage 100  </span><br><span class="line">// 当前AOF文件的文件大小大于64MB </span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>



<p>关闭：auto-aof-rewrite-percentage 0，指定0的百分比，以禁用自动AOF重写功能。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 0</span><br></pre></td></tr></table></figure>



<p>REWRITEAOF：进行 AOF 重写，但是会阻塞主进程，服务器将无法处理客户端发来的命令请求，通常不会直接使用该命令。</p>
<p>BGREWRITEAOF：fork 子进程来进行 AOF 重写，阻塞只会发生在 fork 子进程的时候，之后主进程可以正常处理请求。</p>
<p>REWRITEAOF 和 BGREWRITEAOF 的关系与 SAVE 和 BGSAVE 的关系类似。</p>
<p>相关源码在 aof.c，核心方法是：rewriteAppendOnlyFile</p>
<h2 id="AOF-后台重写存在的问题"><a href="#AOF-后台重写存在的问题" class="headerlink" title="AOF 后台重写存在的问题"></a>AOF 后台重写存在的问题</h2><p>AOF 后台重写使用子进程进行从写，解决了主进程阻塞的问题，但是仍然存在另一个问题：子进程在进行 AOF 重写期间，服务器主进程还需要继续处理命令请求，新的命令可能会对现有的数据库状态进行修改，从而使得当前的数据库状态和重写后的 AOF 文件保存的数据库状态不一致。</p>
<h2 id="如何解决-AOF-后台重写存在的数据不一致问题"><a href="#如何解决-AOF-后台重写存在的数据不一致问题" class="headerlink" title="如何解决 AOF 后台重写存在的数据不一致问题"></a>如何解决 AOF 后台重写存在的数据不一致问题</h2><p>为了解决上述问题，Redis 引入了 AOF 重写缓冲区（aof_rewrite_buf_blocks），这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个写命令之后，它会同时将这个写命令追加到 AOF 缓冲区和 AOF 重写缓冲区。</p>
<p>这样一来可以保证：</p>
<p>1、现有 AOF 文件的处理工作会如常进行。这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</p>
<p>2、从创建子进程开始，也就是 AOF 重写开始，服务器执行的所有写命令会被记录到 AOF 重写缓冲区里面。</p>
<p>这样，当子进程完成 AOF 重写工作后，父进程会在 serverCron 中检测到子进程已经重写结束，则会执行以下工作：</p>
<p>1、将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中，这时新 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致。</p>
<p>2、对新的 AOF 文件进行改名，原子的覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。</p>
<p>之后，父进程就可以继续像往常一样接受命令请求了。</p>
<p>相关源码在 aof.c，核心方法是：rewriteAppendOnlyFileBackground</p>
<h2 id="AOF-重写缓冲区内容过多怎么办"><a href="#AOF-重写缓冲区内容过多怎么办" class="headerlink" title="AOF 重写缓冲区内容过多怎么办"></a>AOF 重写缓冲区内容过多怎么办</h2><p>将 AOF 重写缓冲区的内容追加到新 AOF 文件的工作是由主进程完成的，所以这一过程会导致主进程无法处理请求，如果内容过多，可能会使得阻塞时间过长，显然是无法接受的。</p>
<p>Redis 中已经针对这种情况进行了优化：</p>
<p>1、在进行 AOF 后台重写时，Redis 会创建一组用于父子进程间通信的管道，同时会新增一个文件事件，该文件事件会将写入 AOF 重写缓冲区的内容通过该管道发送到子进程。</p>
<p>2、在重写结束后，子进程会通过该管道尽量从父进程读取更多的数据，每次等待可读取事件1ms，如果一直能读取到数据，则这个过程最多执行1000次，也就是1秒。如果连续20次没有读取到数据，则结束这个过程。</p>
<p>通过这些优化，Redis 尽量让 AOF 重写缓冲区的内容更少，以减少主进程阻塞的时间。</p>
<p>到此，AOF 后台重写的核心内容基本告一段落，通过一张图来看下其完整流程。</p>
<img src="/2023/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/v2-c860405f0c426655102ad1294caebbc2_720w.webp" class title="img">



<p>相关源码在 aof.c，核心方法是：aofCreatePipes、aofChildWriteDiffData、rewriteAppendOnlyFile</p>
<h2 id="RDB、AOF、混合持久，我应该用哪一个？"><a href="#RDB、AOF、混合持久，我应该用哪一个？" class="headerlink" title="RDB、AOF、混合持久，我应该用哪一个？"></a>RDB、AOF、混合持久，我应该用哪一个？</h2><p>一般来说， 如果想尽量保证数据安全性， 你应该同时使用 RDB 和 AOF 持久化功能，同时可以开启混合持久化。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
<p>如果你的数据是可以丢失的，则可以关闭持久化功能，在这种情况下，Redis 的性能是最高的。</p>
<p>使用 Redis 通常都是为了提升性能，而如果为了不丢失数据而将 appendfsync 设置为 always 级别时，对 Redis 的性能影响是很大的，在这种不能接受数据丢失的场景，其实可以考虑直接选择 MySQL 等类似的数据库。</p>
<h2 id="服务启动时如何加载持久化数据"><a href="#服务启动时如何加载持久化数据" class="headerlink" title="服务启动时如何加载持久化数据"></a>服务启动时如何加载持久化数据</h2><p>简单来说，如果同时启用了 AOF 和 RDB，Redis 重新启动时，会使用 AOF 文件来重建数据集，因为通常来说， AOF 的数据会更完整。</p>
<p>而在引入了混合持久化之后，使用 AOF 重建数据集时，会通过文件开头是否为“REDIS”来判断是否为混合持久化。</p>
<p>完整流程如下图所示：</p>
<img src="/2023/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/v2-fc88a7b32d3394a14a0d50a72318694e_720w.webp" class title="img">



<p>相关源码在 server.c，核心方法是：loadDataFromDisk</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/24/MQ%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B8%89%E8%BF%9E%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%E3%80%81%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E7%A7%AF%E5%8E%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/MQ%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B8%89%E8%BF%9E%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%E3%80%81%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E7%A7%AF%E5%8E%8B%EF%BC%9F/" class="post-title-link" itemprop="url">MQ面试问题三连：如何解决消息不丢失、重复消费、积压？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-24 14:20:15 / Modified: 20:04:35" itemprop="dateCreated datePublished" datetime="2023-05-24T14:20:15+08:00">2023-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MQ面试问题三连：如何解决消息不丢失、重复消费、积压？"><a href="#MQ面试问题三连：如何解决消息不丢失、重复消费、积压？" class="headerlink" title="MQ面试问题三连：如何解决消息不丢失、重复消费、积压？"></a>MQ面试问题三连：如何解决消息不丢失、重复消费、积压？</h1><h1 id="如何确保消息不丢失"><a href="#如何确保消息不丢失" class="headerlink" title="如何确保消息不丢失?"></a>如何确保消息不丢失?</h1><h2 id="为什么消息会丢失"><a href="#为什么消息会丢失" class="headerlink" title="为什么消息会丢失?"></a>为什么消息会丢失?</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1088cf1322414c1c8ae2f65d75baae2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<h5 id="整个消息从生产到消费，哪些地方可能导致丢消息？"><a href="#整个消息从生产到消费，哪些地方可能导致丢消息？" class="headerlink" title="整个消息从生产到消费，哪些地方可能导致丢消息？"></a>整个消息从生产到消费，哪些地方可能导致丢消息？</h5><p>生产阶段：消息在Producer中被创建，<strong>网络传输</strong>到Broker。</p>
<p>存储阶段：消息在Broker<strong>存储</strong>，若是集群，消息会被<strong>复制</strong>到其他副本上。</p>
<p>消费阶段：Consumer从Broker拉取消息，<strong>网络传输</strong>到Consumer上。</p>
<p>总结下来有以下可靠性问题：</p>
<ol>
<li>网络传输时的可靠性问题</li>
<li>存储时的可靠性问题</li>
</ol>
<p>在主流的消息队列产品中都提供了非常完成的消息可靠性保证机制，确保消息的可靠传递，不丢失消息。</p>
<h2 id="你怎么知道消息丢没丢？"><a href="#你怎么知道消息丢没丢？" class="headerlink" title="你怎么知道消息丢没丢？"></a>你怎么知道消息丢没丢？</h2><p>首当其冲的问题其实不是如何保证消息传递的可靠性，而是应该考虑如何知道消息是否丢失。</p>
<p>答案是<strong>有序性</strong>。</p>
<p>原理很简单：</p>
<ol>
<li>在Producer端，每个发送的消息添加一个<strong>连续递增</strong>的序号。</li>
<li>在Consumer端，若检测到消息<strong>序号不连续</strong>了，则丢消息了，还可以确定丢的是那一条数据。</li>
</ol>
<h3 id="分布式提升了消息丢失检查方法的复杂度"><a href="#分布式提升了消息丢失检查方法的复杂度" class="headerlink" title="分布式提升了消息丢失检查方法的复杂度"></a>分布式提升了消息丢失检查方法的复杂度</h3><p>在Kafka和RocketMQ中，为了提升并发程度，降低了有序性。从Topic级有序降到了分区级有序。</p>
<p><strong>因此由原来的每个Topic检测消息序号的连续性，降为每个分区单独检测消息序号的连续性。</strong></p>
<p>因此我们要注意：</p>
<p><strong>在Producer端</strong></p>
<ol>
<li>我们要指定发送消息的分区</li>
<li>若有多个Producer实例，每个Producer分别生成各自的消息序号，且附加上Producer标识。</li>
</ol>
<p><strong>在Consumer端</strong></p>
<ol>
<li>按照Producer分表来检测序号的连续性。</li>
<li>Consumer实例数最好和分区数一致，一一对应可以方便Consumer检测序号的连续性。</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ae5a38dfe04972bb6916688e9a5c7a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<h2 id="怎么确保消息不丢失？"><a href="#怎么确保消息不丢失？" class="headerlink" title="怎么确保消息不丢失？"></a>怎么确保消息不丢失？</h2><h3 id="请求确认机制（ACK）解决网络传输时的可靠性问题"><a href="#请求确认机制（ACK）解决网络传输时的可靠性问题" class="headerlink" title="请求确认机制（ACK）解决网络传输时的可靠性问题"></a>请求确认机制（ACK）解决网络传输时的可靠性问题</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c0bd35a65be4e41a2b2a895b0b8fd55~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p><strong>请求确认机制原理</strong></p>
<ol>
<li>Producer告诉Broker我消息发给你了，你收到了告诉我一声。</li>
<li>Broker收到消息之后给Producer发送，我收到了。</li>
</ol>
<h3 id="生产阶段和消费阶段发送ACK的时机不同"><a href="#生产阶段和消费阶段发送ACK的时机不同" class="headerlink" title="生产阶段和消费阶段发送ACK的时机不同"></a>生产阶段和消费阶段发送ACK的时机不同</h3><p>生产阶段：</p>
<ol>
<li>若存储阶段为单机，则Broker将消息写入硬盘之后，再返回ACK。</li>
<li>若存储阶段为集群，则将消息发送到Broker两个以上节点，再返回ACK。 消费阶段：</li>
</ol>
<p>Consumer消费掉消息之后，再返回ACK。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c054816f808f4983a99f0fc2e70258d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<h1 id="为什么会有重复消息？"><a href="#为什么会有重复消息？" class="headerlink" title="为什么会有重复消息？"></a>为什么会有重复消息？</h1><p>我们可以从业务和技术角度切入。</p>
<h2 id="业务角度"><a href="#业务角度" class="headerlink" title="业务角度"></a>业务角度</h2><ol>
<li>前端重复提交表单</li>
<li>用户恶意进行刷单</li>
</ol>
<h2 id="技术角度"><a href="#技术角度" class="headerlink" title="技术角度"></a>技术角度</h2><p>MQTT协议中对<strong>传递消息时的服务质量</strong>进行了分类，虽然由MQTT协议定义但是在所有消息传递场景都适用。</p>
<p><strong>At most once</strong>:最多分发一次。也就是说不保证消息可靠性，允许丢消息。</p>
<p><strong>At least once</strong>:至少分发一次。也就是说保证消息可靠性，允许重复消息。</p>
<p><strong>Exactly once</strong>:只分发一次。这是最高级别的消息传递，消息丢失和重复都是不可接受的，使用这个服务质量等级会有额外的开销。</p>
<p>消息队列传递消息时的服务质量通常是<strong>At least once</strong>，因为保证消息的可靠性符合大部分业务的需求。</p>
<blockquote>
<p>At least once-&gt;保证消息可靠性-&gt;同一条消息会被重复发送-&gt;重复消费问题</p>
</blockquote>
<h1 id="怎么解决消息被重复消费的问题？"><a href="#怎么解决消息被重复消费的问题？" class="headerlink" title="怎么解决消息被重复消费的问题？"></a>怎么解决消息被重复消费的问题？</h1><p>因为消息队列的服务质量是<strong>At least once</strong> ，因此消息队列<strong>无法保证消息不重复</strong>，因此消费重复的问题得由<strong>Consumer端</strong>来解决。</p>
<p>一般采用<strong>幂等性解决重复消息问题</strong>。</p>
<h2 id="什么是幂等？"><a href="#什么是幂等？" class="headerlink" title="什么是幂等？"></a>什么是幂等？</h2><p>幂等操作的特点：<strong>任意多次执行所产生的影响均与一次执行的影响相同</strong>。</p>
<p>举个栗子：</p>
<p>幂等操作：“将某账户余额设置为100元”，这个操作执行多次之后账户余额始终是100元，因此这个操作是幂等的。</p>
<p>不幂等操作：“将某账户余额增加100元”，每次一执行，余额都会增加100元，因此这个操作是不幂等的。</p>
<h2 id="在Restful中哪些操作需要考虑幂等？"><a href="#在Restful中哪些操作需要考虑幂等？" class="headerlink" title="在Restful中哪些操作需要考虑幂等？"></a>在Restful中哪些操作需要考虑幂等？</h2><p>现在流行的 Restful 推荐的几种 HTTP 接口方法中，分别存在幂等行与不能保证幂等的方法，如下：</p>
<ol>
<li><code>√ </code>满足幂等</li>
<li><code>x</code> 不满足幂等</li>
<li><code>-</code> 可能满足也可能不满足幂等，根据实际业务逻辑有关</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad4808e71f4f49a9a90a3ad46b3eef2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<h2 id="如何实现幂等？"><a href="#如何实现幂等？" class="headerlink" title="如何实现幂等？"></a>如何实现幂等？</h2><p>实现幂等的最好方式是<strong>从业务逻辑设计上入手，将消费的业务逻辑设计成具备幂等性的操作。</strong></p>
<h3 id="利用数据库的唯一约束实现幂等"><a href="#利用数据库的唯一约束实现幂等" class="headerlink" title="利用数据库的唯一约束实现幂等"></a>利用数据库的唯一约束实现幂等</h3><p>举个栗子：改造“将某账户余额增加100元”的业务逻辑。</p>
<p>1.增加限定，每个转账单每个账户只可以执行一次变更操作。具体实现：在数据库中建一张转账流水表，表包含字段转账单ID、账户ID、变更金额，对（转账单ID、账户ID）创建唯一键约束。</p>
<p>2.“将某账户余额增加100元”的业务逻辑变为：“在转账流水表中增加一条转账记录，然后再根据转账记录，异步操作更新用户余额”。</p>
<p>如果重复消费，就回触发唯一键约束，从而实现了操作的幂等性。</p>
<h3 id="为更新的数据设置前置条件"><a href="#为更新的数据设置前置条件" class="headerlink" title="为更新的数据设置前置条件"></a>为更新的数据设置前置条件</h3><p>核心思想：<strong>乐观锁</strong></p>
<p>举个栗子：改造“将某账户余额增加100元”的业务逻辑。</p>
<p>为“将某账户余额增加100元”添加前置条件，变为：“如果某账户余额版本为2，则将账户X的余额增加100元”。</p>
<p>每次更新时，若数据中的版本号和消息中的版本号一直，则更新数据并且版本号+1，否则拒绝更新，从而实现了操作的幂等性。</p>
<h3 id="记录并检查操作（也叫Token机制或GUID机制）"><a href="#记录并检查操作（也叫Token机制或GUID机制）" class="headerlink" title="记录并检查操作（也叫Token机制或GUID机制）"></a>记录并检查操作（也叫Token机制或GUID机制）</h3><p>基本思路：在执行数据更新操作之前，先检查一下是否执行过这个更新操作。</p>
<p>举个栗子：改造“将某账户余额增加100元”的业务逻辑。</p>
<p>给“将某账户余额增加100元”生成全局唯一ID，存入Redis中，假设Redis中存在全局唯一ID则消息没有被消费，否则消息已经被消费。</p>
<p>消费时，第一步，先到Redis检查全局唯一ID是否存在，第二步，存在则消费，第三步，消费完成之后，到Redis删除全局唯一ID。</p>
<p>该方法需要<strong>保证消费时三步操作的原子性</strong>，才能实现幂等，否则会出现Bug。具体原子性的实现可以是分布式事务，也可以是分布式锁。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbf84739a84d49d083304b5867842fa8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<h1 id="什么是消息积压？"><a href="#什么是消息积压？" class="headerlink" title="什么是消息积压？"></a>什么是消息积压？</h1><p>大量消息被堆积在broker端，没有被消费。</p>
<h1 id="为什么会消息积压？"><a href="#为什么会消息积压？" class="headerlink" title="为什么会消息积压？"></a>为什么会消息积压？</h1><p>宏观角度主要原因是：<strong>producer端生产速度 &gt; consumer端消费速度</strong>。</p>
<p>导致<strong>producer端生产速度 &gt; consumer端消费速度</strong>的情况有多种：</p>
<ol>
<li>设计的时候就没有考虑消费速度要大于生产速度，这种情况最不应该。</li>
<li>某一时刻消息积压上涨<ol>
<li>比如说抢购，导致生产端一下子并发量飙升，考虑水平扩容或者服务降级。</li>
<li>消费端有很多消费失败，导致消费性能下降</li>
</ol>
</li>
</ol>
<h1 id="消息积压了该怎么办？"><a href="#消息积压了该怎么办？" class="headerlink" title="消息积压了该怎么办？"></a>消息积压了该怎么办？</h1><p>这里首先得有一个认识：<strong>消息队列本身的处理能力要远大于业务系统的处理能力。因此主要考虑业务逻辑中的性能优化。</strong></p>
<h2 id="紧急处理"><a href="#紧急处理" class="headerlink" title="紧急处理"></a>紧急处理</h2><p>问题的根在于consumer端消费速度慢导致的，最直接的方法就是<strong>水平扩容</strong>，增加消费端的并发数，来提升总体的消费性能。</p>
<p>需要注意的是：在Kafka或RocketMQ中 <strong>在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。</strong> 否则水平扩容之后也是没有效果的。</p>
<p>具体需要怎么进行紧急扩容，可以参考另外一篇文章，消息队列已经挤压了百万条，需要怎么进行紧急补救</p>
<h2 id="紧急处理之后进行Consumer端优化"><a href="#紧急处理之后进行Consumer端优化" class="headerlink" title="紧急处理之后进行Consumer端优化"></a>紧急处理之后进行Consumer端优化</h2><p>只要针对consumer端的业务逻辑进行优化。</p>
<h1 id="我们的业务代码怎么和消息队列配合，达到一个最佳的性能？"><a href="#我们的业务代码怎么和消息队列配合，达到一个最佳的性能？" class="headerlink" title="我们的业务代码怎么和消息队列配合，达到一个最佳的性能？"></a>我们的业务代码怎么和消息队列配合，达到一个最佳的性能？</h1><h2 id="producer端"><a href="#producer端" class="headerlink" title="producer端"></a>producer端</h2><p>发送端性能上不去，你需要优先检查一下，<strong>是不是发消息之前的业务逻辑耗时太多导致的。</strong></p>
<p>提升发送性能的方法：<strong>设置合适的并发和批量大小。</strong></p>
<p>Producer 发消息给 Broker，Broker 收到消息后返回确认响应，这是一次完整的交互。</p>
<p>提升发送性能就是为了在<strong>单位时间内增加交互的消息量</strong>。</p>
<p>并发方式：对于响应时间短的友好</p>
<p>批量方式：对吞吐量大的友好</p>
<h3 id="耗时分析"><a href="#耗时分析" class="headerlink" title="耗时分析"></a>耗时分析</h3><ul>
<li>1.准备发送：发送端准备数据、序列化消息、构造请求等逻辑的时间</li>
<li>2.消息从producer端网络传输到broker端</li>
<li>3.broker端处理消息</li>
<li>4.消息响应从broker端网络传输到producer端</li>
</ul>
<h2 id="broker端"><a href="#broker端" class="headerlink" title="broker端"></a>broker端</h2><p>刚才已经提过了，消费队列性能远大于业务系统的处理能力，所以broker端的性能不用考虑，要考虑也可以通过水平扩容broker达到很好的效果。</p>
<h2 id="consumer端"><a href="#consumer端" class="headerlink" title="consumer端"></a>consumer端</h2><p>如上，只要针对consumer端的业务逻辑进行优化，或者进行水平扩容，且在broker增加分区。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" class="post-title-link" itemprop="url">一文彻底明白Spring的循环依赖</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-23 23:05:07 / Modified: 23:18:21" itemprop="dateCreated datePublished" datetime="2023-05-23T23:05:07+08:00">2023-05-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>27 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Spring</strong>的循环依赖，也就是两个<strong>bean</strong>之间产生了互相依赖，那么引出的问题就是如何顺利的将两个<strong>bean</strong>创建出来并注册到容器中。更有甚者，产生了循环依赖的<strong>bean</strong>还需要生成动态代理对象，这种情况则比普通的循环依赖更为复杂。</p>
<p>本篇文章将对<strong>Spring</strong>中的循环依赖进行详细分析，结合<strong>示例工程</strong>，<strong>流程图示</strong>和<strong>源码</strong>，力求一文阐释清楚<strong>Spring</strong>中的循环依赖问题以及如何解决，并会在最后给出<strong>Spring</strong>中的三个缓存的具体作用。</p>
<p>在开始本文的分析前，有如下几点概念说明。</p>
<ol>
<li><strong>bean</strong>的实例化，就是将<strong>bean</strong>的对象<strong>new</strong>出来，称为<strong>bean</strong>的原始对象，原始对象没有完成属性注入，不能称为<strong>bean</strong>；</li>
<li><strong>bean</strong>的属性注入，就是为<strong>bean</strong>的原始对象注入其它<strong>bean</strong>即依赖注入，完成依赖注入的原始对象，此时可以作为<strong>bean</strong>放入容器；</li>
<li><strong>bean</strong>的初始化可以理解为：<strong>bean</strong>实例化 + <strong>bean</strong>属性注入。</li>
</ol>
<p><strong>Spring</strong>版本：<strong>5.3.2</strong></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一-循环依赖的产生"><a href="#一-循环依赖的产生" class="headerlink" title="一. 循环依赖的产生"></a>一. 循环依赖的产生</h3><p>如果有两个业务类实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceB myServiceB;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceA myServiceA;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么<strong>Spring</strong>在初始化<strong>MyServiceA</strong>的<strong>bean</strong>时候，会为<strong>MyServiceA</strong>的原始对象注入<strong>MyServiceB</strong>的<strong>bean</strong>，此时由于容器中没有<strong>MyServiceB</strong>的<strong>bean</strong>，所以<strong>Spring</strong>又会去初始化<strong>MyServiceB</strong>的<strong>bean</strong>，初始化<strong>MyServiceB</strong>的bean的时候，会为<strong>MyServiceB</strong>的原始对象注入<strong>MyServiceA</strong>的<strong>bean</strong>，此时就发生了循环依赖。</p>
<p>后续都将<strong>MyServiceA</strong>简称为<strong>A</strong>，将<strong>MyServiceB</strong>简称为<strong>B</strong>。</p>
<h3 id="二-循环依赖的解决"><a href="#二-循环依赖的解决" class="headerlink" title="二. 循环依赖的解决"></a>二. 循环依赖的解决</h3><p>如下是循环依赖中最复杂的一种情况，即两个需要生成动态代理的<strong>bean</strong>之间形成了循环依赖。</p>
<p>业务类如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceA</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String initMessage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceB myServiceB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyService A execute.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        initMessage = <span class="string">&quot;MyService A.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceB</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String initMessage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceA myServiceA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyService B execute.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        initMessage = <span class="string">&quot;MyService B.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在业务类中使用了@<strong>MyAnnotation</strong>注解来修饰方法，该注解是自定义注解，没有任何含义，仅为了帮助在<strong>SpringAOP</strong>中进行切点声明，@<strong>MyAnnotation</strong>注解定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切面如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.leanr.spring.ioc.mytest.MyAnnotation)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">allMethodPointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;allMethodPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeBeforeMethod</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyAspect execute.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.leanr.spring.ioc.mytest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>测试类如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span></span><br><span class="line">                <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么针对上面这种需要生成动态代理的<strong>bean</strong>之间存在循环依赖的情况，整个解决流程如下所示。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847dddf8699b423eba9cc3841135bb24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Spring-循环依赖示意图"></p>
<p>上述流程图中，出现了<strong>一级缓存</strong>，<strong>二级缓存</strong>和<strong>三级缓存</strong>，如果对这三个缓存没有概念，那么就暂时不要去深究，就当这三个缓存是三个<strong>Map</strong>，在下面的章节，会结合源码，具体分析其作用。</p>
<h3 id="三-源码分析"><a href="#三-源码分析" class="headerlink" title="三. 源码分析"></a>三. 源码分析</h3><p>在<strong>Spring</strong>中，如果基于<strong>XML</strong>配置<strong>bean</strong>，那么使用的容器为<strong>ClassPathXmlApplicationContext</strong>，如果是基于注解配置<strong>bean</strong>，则使用的容器为<strong>AnnotationConfigApplicationContext</strong>。以<strong>AnnotationConfigApplicationContext</strong>为例，其构造函数如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">// 初始化容器</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>AnnotationConfigApplicationContext</strong>的构造函数中会调用到<strong>AbstractApplicationContext</strong>的<strong>refresh()</strong> 方法，实际上无论是基于<strong>XML</strong>配置<strong>bean</strong>，还是基于注解配置<strong>bean</strong>，亦或者是<strong>Springboot</strong>中，在初始化容器时都会调用到<strong>AbstractApplicationContext</strong>的<strong>refresh()</strong> 方法中。下面看一下<strong>refresh()</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化所有非延时加载的单例bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关心<strong>refresh()</strong> 方法中调用的<strong>finishBeanFactoryInitialization()</strong> 方法，该方法会初始化所有非延时加载的单例<strong>bean</strong>，其实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有非延时加载的单例bean</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>finishBeanFactoryInitialization()</strong> 方法中会调用到<strong>DefaultListableBeanFactory</strong>的<strong>preInstantiateSingletons()</strong> 方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个循环中通过getBean()方法初始化bean</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是FactoryBean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不是FactoryBean，则通过getBean()方法来初始化bean</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这里需要注意，<strong>Spring</strong>中初始化<strong>bean</strong>，是通过调用容器的<strong>getBean()</strong> 方法来完成，在<strong>getBean()</strong> 方法中如果获取不到<strong>bean</strong>，此时就会初始化这个<strong>bean</strong>，<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法的实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">0public Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 有三种情况会调用到这里</span></span><br><span class="line">    <span class="comment">// 1. 容器启动的时候初始化A，所以调用到这里以进行A的初始化</span></span><br><span class="line">    <span class="comment">// 2. 初始化A的时候要属性注入B，所以调用到这里以进行B的初始化</span></span><br><span class="line">    <span class="comment">// 3. 初始化B的时候要属性注入A，所以调用到这里以获取A的bean</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">        String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object beanInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1和情况2：去一级缓存中获取bean，是获取不到的</span></span><br><span class="line">    <span class="comment">// 情况3：依次去一级缓存，二级缓存和三级缓存中获取A的bean</span></span><br><span class="line">    <span class="comment">// 情况3：在本示例中，最终会在三级缓存中获取到A原始对象对应的ObjectFactory</span></span><br><span class="line">    <span class="comment">// 情况3：然后通过A原始对象对应的ObjectFactory获取A原始对象（的代理对象）</span></span><br><span class="line">    <span class="comment">// 情况3：获取到A原始对象（的代理对象）后，会将其放入二级缓存</span></span><br><span class="line">    <span class="comment">// 情况3：然后将A原始对象对应的ObjectFactory从三级缓存删除</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非单例bean是无法支持循环依赖的，所以这里判断是否是非单例bean的循环依赖场景，如果是则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况1和情况2都会执行到这里</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 在上面的getSingleton()方法中会调用到createBean()方法</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            beanCreation.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际会有三种情况调用到<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法，总结如下。</p>
<ol>
<li>容器初始化的时候，初始化<strong>A</strong>，这种情况，是无法从一级缓存中获取到<strong>A</strong>的<strong>bean</strong>（或者代理<strong>bean</strong>）的，所以调用<strong>getSingleton(String)</strong> 方法会返回<strong>null</strong>，然后调用<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;<strong>?**&gt;)方法来获取（初始化）</strong>A**；</li>
<li>初始化<strong>A</strong>的时候，会属性注入<strong>B</strong>，此时会调用到<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法来初始化<strong>B</strong>，这种情况的逻辑同上；</li>
<li>初始化<strong>B</strong>的时候，会属性注入<strong>A</strong>，此时会调用到<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法来获取<strong>A</strong>的<strong>bean</strong>（或者代理<strong>bean</strong>），并且能够在<strong>getSingleton(String)</strong> 方法中获取到<strong>A</strong>的原始对象对应的<strong>ObjectFactory</strong>，然后通过<strong>A</strong>的原始对象对应的<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法获取到<strong>A</strong>的原始对象（的代理对象），并将其放入二级缓存，最后将<strong>A</strong>的原始对象对应的<strong>ObjectFactory</strong>从三级缓存中删除。</li>
</ol>
<p>上述的情况1和情况2，在<strong>getSingleton(String)</strong> 方法中只会去一级缓存获取，而情况三会依次去一级缓存，二级缓存和三级缓存中获取，这是因为有一个叫做<strong>singletonsCurrentlyInCreation</strong>的集合会对即将实例化并执行初始化逻辑的<strong>bean</strong>进行标记，那么在情况1和情况2中，<strong>singletonsCurrentlyInCreation</strong>中都是没有<strong>A</strong>或<strong>B</strong>的标记的，只有情况3的<strong>singletonsCurrentlyInCreation</strong>中有<strong>A</strong>的标记，如果有标记，表明这时发生了循环依赖，所以需要去到二级缓存或者三级缓存中获取到提前暴露出来的对象。</p>
<p>如果是情况1或者情况2，那么就会调用到<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;<strong>?**&gt;)方法来初始化</strong>A<strong>或者</strong>B<strong>，这里传入的</strong>ObjectFactory**&lt;<strong>?**&gt;实际是一个</strong>Lambdas<strong>表达式，所以调用</strong>ObjectFactory<strong>的</strong>getObject()** 方法，就会调用到<strong>createBean()</strong> 方法。下面继续看<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;**?**&gt;)方法的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向singletonsCurrentlyInCreation集合中添加beanName</span></span><br><span class="line">            <span class="comment">// 标记beanName对应的bean正在初始化，这里就是标记A或者B正在初始化</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用getObject()方法，实际就是调用之前的createBean()方法</span></span><br><span class="line">                <span class="comment">// 这里得到的singletonObject就是初始化后得到的bean（或者代理bean）</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 移除A或者B正在初始化的标记</span></span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">// 将A或者B的bean放入一级缓存</span></span><br><span class="line">                <span class="comment">// 删除A或者B在二级缓存中的原始对象（的代理对象）</span></span><br><span class="line">                <span class="comment">// 删除A或者B在三级缓存中的ObjectFactory</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DefaultSingletonBeanRegistry</strong>的<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;<strong>?**&gt;)方法中首先会标记</strong>A<strong>或者</strong>B<strong>正在初始化，然后调用到</strong>AbstractAutowireCapableBeanFactory<strong>的</strong>createBean()** 方法，在<strong>createBean()</strong> 方法中会真正的把对象<strong>new</strong>出来以得到原始对象，然后为原始对象属性注入其它<strong>bean</strong>（循环依赖就是在这里发生）和执行初始化逻辑，在<strong>createBean()</strong> 方法执行完后，就会得到真正可用的<strong>bean</strong>（或代理<strong>bean</strong>），之后就从<strong>singletonsCurrentlyInCreation</strong>中移除正在初始化的标记，然后将<strong>bean</strong>（或者代理<strong>bean</strong>）放入一级缓存，然后删除在二级缓存中的原始对象（的代理对象），删除在三级缓存中的<strong>ObjectFactory</strong>。那么重点就是<strong>createBean()</strong> 方法，其实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到BeanDefinition</span></span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化在这里</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进<strong>doCreateBean()</strong> 方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把A或者B的对象new出来，称作原始对象</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的bean就是A或者B的原始对象，此时没有被属性注入，也没有执行初始化逻辑</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里计算结果为true，目的是提前将A或B的原始对象对应的ObjectFactory放到三级缓存中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将A或者B的原始对象对应的ObjectFactory放到三级缓存中</span></span><br><span class="line">        <span class="comment">// 那么ObjectFactory的getObejct()方法实际就会调用到getEarlyBeanReference()方法</span></span><br><span class="line">        <span class="comment">// 如果需要动态代理，getEarlyBeanReference()方法会返回原始对象的代理对象</span></span><br><span class="line">        <span class="comment">// 如果不需要动态代理，getEarlyBeanReference()方法会返回原始对象</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里为A或者B的原始对象进行属性注入</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 调用initializeBean()方法来为A或者B的原始对象执行初始化的逻辑</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 这里会从二级缓存中将A或者B的原始对象（的代理对象）获取出来</span></span><br><span class="line">        <span class="comment">// 如果是初始化A的时候调用到这里，那么能够获取出来A的原始对象（的代理对象）</span></span><br><span class="line">        <span class="comment">// 如果是初始化B的时候调用到这里，那么不能够获取出来B的原始对象（的代理对象）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">// 只有A能进到这里</span></span><br><span class="line">                <span class="comment">// 将A的原始对象（的代理对象）替换A的原始对象</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原始对象（的代理对象）返回</span></span><br><span class="line">    <span class="comment">// 其实这里的对象已经是可以使用的bean了</span></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>doCreateBean()</strong> 方法可以概括如下。</p>
<ol>
<li><strong>new</strong>出对象以得到<strong>A</strong>或<strong>B</strong>的原始对象，然后将<strong>A</strong>或<strong>B</strong>的原始对象对应的<strong>ObjectFactory</strong>放入三级缓存（提前暴露原始对象的<strong>ObjectFactory</strong>到三级缓存中，以使得发生循环依赖的时候能够在三级缓存中通过原始对象的<strong>ObjectFactory</strong>获得原始对象或者原始对象的代理对象）；</li>
<li>为原始对象进行属性注入，这里就分为两种情况。<ol>
<li>为<strong>A</strong>原始对象属性注入<strong>B</strong>的<strong>bean</strong>，那么就触发了初始化<strong>B</strong>的逻辑；</li>
<li>为<strong>B</strong>原始对象属性注入<strong>A</strong>的<strong>bean</strong>，那么在这里，就会使用到<strong>A</strong>提前暴露到三级缓存中的<strong>ObjectFactory</strong>来获取<strong>A</strong>的原始对象（的代理对象），由前面的分析可知，通过<strong>A</strong>的<strong>ObjectFactory</strong>来获取到<strong>A</strong>的原始对象（的代理对象）后，会将其放入二级缓存，所以这个时候二级缓存中存在<strong>A</strong>的原始对象（的代理对象）。</li>
</ol>
</li>
<li>调用initializeBean()方法来为A或者B的原始对象执行初始化的逻辑，initializeBean()方法中有一个和循环依赖密切相关的执行步骤就是在后置处理器中为需要动态代理的对象生成代理对象，那么这里又有两种情况。<ol>
<li>初始化<strong>A</strong>的时候执行到这里，说明<strong>B</strong>的初始化已经执行完毕了（因为<strong>A</strong>的属性注入已经结束了），所以<strong>A</strong>原始对象的代理对象就已经生成并且注入到了<strong>B</strong>的<strong>bean</strong>（或者代理<strong>bean</strong>）中，所以这里<strong>A</strong>就不能再在<strong>initializeBean()</strong> 方法的后置处理器中再生成一个代理对象，如果生成就出现了两个代理对象违反了单例；</li>
<li>初始化<strong>B</strong>的时候执行到这里，<strong>B</strong>原始对象的代理对象还没有在任何一个地方有生成，所以需要在<strong>initializeBean()</strong> 方法的后置处理器中生成一个代理对象，并将这个代理对象返回。同时，在前面的分析中已知，只有通过调用<strong>ObjectFactory</strong>来获取原始对象（的代理对象）的时候，才会将原始对象（的代理对象）放入二级缓存，所以<strong>B</strong>的原始对象（的代理对象）是没有被放入到二级缓存中去的。</li>
</ol>
</li>
<li>由于doCreateBean()方法是需要返回可用的bean，所以在A和B都需要动态代理的情况下，还需要为属性注入和执行了初始化逻辑之后的对象再最后做一步操作，那就是将A和B的动态代理对象获取到并返回。<ol>
<li>对于<strong>A</strong>，<strong>A</strong>的动态代理对象在二级缓存中，所以调用<strong>getSingleton()</strong> 方法从二级缓存中获取并返回；</li>
<li>对于<strong>B</strong>，<strong>B</strong>的动态代理对象不存在于二级缓存中，但是当前<strong>B</strong>的对象已经是在后置处理器中生成的动态代理对象，所以直接返回。</li>
</ol>
</li>
</ol>
<p>那么到这里，<strong>Spring</strong>使用三级缓存来解决循环依赖的问题就基本分析完毕，建议结合第二节中的流程图一起阅读。</p>
<h3 id="四-一级缓存作用"><a href="#四-一级缓存作用" class="headerlink" title="四. 一级缓存作用"></a>四. 一级缓存作用</h3><p>一级缓存的定义在<strong>DefaultSingletonBeanRegistry</strong>中，定义如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>

<p>一级缓存用于存放容器中可以使用的<strong>bean</strong>或者代理<strong>bean</strong>，像例子中的<strong>A</strong>和<strong>B</strong>，由于它们都需要生成动态代理对象，所以它们在一级缓存中存放的就是它们的代理<strong>bean</strong>，后续容器中任何地方使用<strong>A</strong>和<strong>B</strong>，都是使用的一级缓存中它们的代理<strong>bean</strong>。</p>
<h3 id="五-二级缓存作用"><a href="#五-二级缓存作用" class="headerlink" title="五. 二级缓存作用"></a>五. 二级缓存作用</h3><p>二级缓存的定义在<strong>DefaultSingletonBeanRegistry</strong>中，定义如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>二级缓存用于存放原始对象（的代理对象），以让在有多重循环依赖的时候其它对象都从二级缓存中拿到同一个当前原始对象（的代理对象），并且只有在调用了三级缓存中的<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法获取原始对象（的代理对象）时，才会将原始对象（的代理对象）放入二级缓存，而调用三级缓存中的<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法获取原始对象（的代理对象）这种情况只会发生在有循环依赖的时候，所以，**<code>二级缓存在没有循环依赖的情况下不会被使用到</code>**。</p>
<h3 id="六-三级缓存作用"><a href="#六-三级缓存作用" class="headerlink" title="六. 三级缓存作用"></a>六. 三级缓存作用</h3><p>三级缓存的定义在<strong>DefaultSingletonBeanRegistry</strong>中，定义如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>三级缓存用于存放原始对象对应的<strong>ObjectFactory</strong>，每生成一个原始对象，都会将这个原始对象对应的<strong>ObjectFactory</strong>放到三级缓存中，通过调用<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法，就能够在需要动态代理的情况下为原始对象生成代理对象并返回，否则返回原始对象，以此来处理循环依赖时还需要动态代理的情况。</p>
<p>为什么会存在三级缓存，主要原因就是：**<code>延迟代理对象的创建</code><strong>。设想一下，如果在创建出一个原始对象的时候，就直接将这个原始对象的代理对象创建出来（如果需要创建的话），然后就放在二级缓存中，似乎感觉三级缓存就没有存在的必要了对吧，但是请打住，这里存在的问题就是，如果真这么做了，那么每一个对象在创建出原始对象后，就都会去创建代理对象，而</strong>Spring<strong>的原始设计中，代理对象的创建应该是由</strong>AnnotationAwareAspectJAutoProxyCreator<strong>这个后置处理器的</strong>postProcessAfterInitialization()** 来完成，也就是：**<code>在对象初始化完毕后，再去创建代理对象</code><strong>。如果真的只用两个缓存来解决循环依赖，那么就会打破</strong>Spring<strong>对</strong>AOP**的一个设计思想。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Spring</strong>中发生循环依赖，简单讲就是<strong>A</strong>的<strong>bean</strong>依赖<strong>B</strong>的<strong>bean</strong>，<strong>B</strong>的<strong>bean</strong>又依赖<strong>A</strong>的<strong>bean</strong>。</p>
<p><strong>Spring</strong>解决循环依赖的思路就是，当<strong>A</strong>的<strong>bean</strong>需要<strong>B</strong>的<strong>bean</strong>的时候，提前将<strong>A</strong>的<strong>bean</strong>放在缓存中（实际是将<strong>A</strong>的<strong>ObjectFactory</strong>放到三级缓存），然后再去创建<strong>B</strong>的<strong>bean</strong>，但是<strong>B</strong>的<strong>bean</strong>也需要<strong>A</strong>的<strong>bean</strong>，那么这个时候就去缓存中拿<strong>A</strong>的<strong>bean</strong>，<strong>B</strong>的<strong>bean</strong>创建完毕后，再回来继续创建<strong>A</strong>的<strong>bean</strong>，最终完成循环依赖的解决。</p>
<p>那么有几个问题需要结合整篇文章的讨论，进行一个总结。</p>
<p><strong>1. 为什么不直接使用一级缓存来解决循环依赖</strong></p>
<p>一级缓存中预期存放的是一个正常完整的<strong>bean</strong>，而如果只用一级缓存来解决循环依赖，那么一级缓存中会在某个时间段存在不完整的<strong>bean</strong>，这是不安全的。</p>
<p><strong>2. 为什么不直接使用一级缓存和二级缓存解决循环依赖</strong></p>
<p>这个问题需要结合为什么引入三级缓存来分析。引用第六节的论述，使用一级缓存和二级缓存确实可以解决循环依赖，但是这要求每个原始对象创建出来后就立即生成动态代理对象（如果有的话），然后将这个动态代理对象放入二级缓存，这就打破了<strong>Spring</strong>对<strong>AOP</strong>的设计原则，即：**<code>在对象初始化完毕后，再去创建代理对象</code><strong>。所以引入三级缓存，并且在三级缓存中存放一个对象的</strong>ObjectFactory<strong>，目的就是：</strong><code>延迟代理对象的创建</code>**，这里延迟到啥时候创建呢，有两种情况：第一种就是确实存在循环依赖，那么没办法，只能在需要的时候就创建出来代理对象然后放到二级缓存中，第二种就是不存在循环依赖，那就是正常的在初始化的后置处理器中创建。</p>
<p>因此不直接使用一级缓存和二级缓存来解决循环依赖的原因就是：**<code>希望在不存在循环依赖的情况下不破坏Spring对AOP的设计原则</code>**。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">了解@Enable* 原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-23 22:33:35" itemprop="dateCreated datePublished" datetime="2023-05-23T22:33:35+08:00">2023-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-25 13:52:34" itemprop="dateModified" datetime="2023-05-25T13:52:34+08:00">2023-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>24 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Spring 和 SpringBoot 中有很多这样的注解，例如常见的：<code>@EnableAsync</code>、 <code>@EnableCaching</code> 、<code>@EnableConfigurationProperties</code>。</p>
<p>每引用一个starer 几乎都有一个 <strong>@Enable</strong>*相关的注解。</p>
<p>这一注解的作用：就是用来启用某一个功能的配置。启用某一功能，仅需要加上一个注解即可生效，可以使组建之间的相互依赖降低了耦合性。</p>
<hr>
<p>例如：<code>@EnableAsync</code> 注解启用异步功能，在SpringBoot中如果没有启用这个注解，直接在使用 <code>@Async</code> 是没法起到异步执行的作用的。所有使用这个功能，就先启用 <code>@EnableAsync</code>,不然他的相关配置不生效，也就是配置了@Async 注解，也没有人来管它。</p>
<p>一个简单的注解，能带动一个某一个功能模块甚至带动一整个框架的，比如：@SpringBootApplication。来分析一下这个 @Enable*注解的原理。</p>
<p>其实 <strong>@Enable*注解很简单，随便找一个注解，点进去一看就能恍然大悟，它的所有核心 都在* *@Import 注解当中。 所有真正核心的 是</strong> @Import**注解，由它去加载它自己对应的配置类，然后启动他的功能。</p>
<p>所以 <strong>@Enbale *注解就是没有啥用的，就是营造一种* *高大上的、又神奇装牛X的 感觉。所以它有啥用？其实它没有用。你看既然 使用</strong> @Import注解就可以了<strong>，还要它干嘛，我直接使用</strong> @Import注解去加载就好了**，这不是多此一举吗？</p>
<p><strong>真的没有用吗？</strong> <strong>有用的！！ 存在即合理</strong></p>
<p>举个例子：**<code>@EnableAutoConfiguration</code>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、除了桥梁的作用，它还可以携带上一些参数：在解析处理这个 注解的时候，可以从这里拿到一些 自定义配置的参数，去做相关的操作。</p>
<p>2、除了 <strong>@Import</strong> 注解还有其它的注解 <strong>@AutoConfigurationPackage</strong> ，它可以组合多个注解放到一起。</p>
<p>3、高大上又神秘高级，又方面你开发者去使用。假如：启用这个功能可能需要更多的 类加载，还有要其它注解去配和，如果不将其包装到 <strong>@Enable</strong>*中，那对开发者来说，配置起来又相对麻烦了许多，将其包装到一起，只需要记住使用这一功能记住这个注解即可。极大的方面！！。</p>
<p>4、将功能做组建抽离开来，降低耦合性。</p>
<p>所以此重点就不再是 <strong>@Enable* 注解了</strong>，而是 <strong><code>@Import</code><strong>注解了，</strong>挂羊头卖狗肉！</strong></p>
<h1 id="1、-Import-注解的作用"><a href="#1、-Import-注解的作用" class="headerlink" title="1、@Import 注解的作用"></a>1、@Import 注解的作用</h1><p>我们看一下这个注解的源码解释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> Configuration</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> ImportSelector</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> ImportResource</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span></span><br><span class="line"><span class="comment">     * or regular component classes to import.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  这个value值 有三种类型：</span></span><br><span class="line"><span class="comment">     *      -   其它的常规类型，就相当于Configuration配置累解析</span></span><br><span class="line"><span class="comment">     *      -   ImportSelector</span></span><br><span class="line"><span class="comment">     *      -   ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Import 注解导入的类 有三种，分别是：ImportSelector、 ImportBeanDefinitionRegistrar、一种是普通各类，会当作为配置类去处理。</p>
<p>@Import 注解的作用可以用来将 JavaBean 注入到IOC容器中。</p>
<p>1、比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;UserService.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p>注入一个JavaBean到 IOC容器中。</p>
<p>2、又比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;XXConfig.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p>导入一个配置类，然后继续扩展解析这个配置类。</p>
<p>3、又比如： <code>@Import(&#123;XXImportSelector.class&#125;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-09-27 13:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata)</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; zClass = <span class="literal">null</span>;</span><br><span class="line">        Set&lt;String&gt; annotationTypes = importingClassMetadata.getAnnotationTypes();</span><br><span class="line">        Iterator&lt;String&gt; zClasses = annotationTypes.iterator();</span><br><span class="line">        <span class="keyword">while</span> (zClasses.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> zClasses.next();</span><br><span class="line">            <span class="keyword">if</span> (type.equals(EnableConfig.class.getName()))</span><br><span class="line">            &#123;</span><br><span class="line">                Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(EnableConfig.class.getName());</span><br><span class="line">                zClass = (Class&lt;?&gt;) annotationAttributes.get(<span class="string">&quot;zClass&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;zClass.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导入实现ImportSelector的类，这个实现可以拿到许多相关注解，然后可以取对应注解上的值，进行你所想要的操作。</p>
<p>4、还比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;XXBeanDefinitionRegistry.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p>导入 BeanDefinitionRegistry 的实现类。该接口是Spring中定义的bean的注册类。所以的Bean注册都会走这个类。所以导入一个BeanDefinitionRegistry的实现类，可以自定义实现动态注册 bean的操作。</p>
<h1 id="源码了解"><a href="#源码了解" class="headerlink" title="源码了解"></a>源码了解</h1><p>如下是处理 @Import注解的的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理 @Import 注解，加载某个类，将其假如IOC容器中 擦数： 当前的配置类，当前的源码类，导入的类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">            Collection&lt;SourceClass&gt; importCandidates, <span class="type">boolean</span> checkForCircularImports)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// @Import 注解 可以配置多个类没循环遍历</span></span><br><span class="line">                <span class="comment">// 该注解上面说了 有三种类型，遍历做分支处理</span></span><br><span class="line">                <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 三种类行，做分支判断</span></span><br><span class="line">                    <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">                        <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">                        Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                        <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line"></span><br><span class="line">                        ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                                selector, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//延迟导入处理</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.deferredImportSelectors != <span class="literal">null</span> &amp;&amp; selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">this</span>.deferredImportSelectors.add(</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorHolder</span>(configClass, (DeferredImportSelector) selector));</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 执行 ImportSelector 接口的方法，实现了该ImportSelector的方法，拿到要注入的类全名</span></span><br><span class="line">                            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 返回来的转为一个配置类去加载</span></span><br><span class="line">                            Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 继续递归检查</span></span><br><span class="line">                            processImports(configClass, currentSourceClass, importSourceClasses, <span class="literal">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">                      <span class="comment">// 处理 ImportBeanDefinitionRegistrar 的实现类</span></span><br><span class="line">            <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">                        <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">                        Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line"></span><br><span class="line">                        <span class="type">ImportBeanDefinitionRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span></span><br><span class="line">                                BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);</span><br><span class="line"></span><br><span class="line">                        ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                                registrar, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">                        <span class="comment">// process it as an @Configuration class</span></span><br><span class="line">                        <span class="comment">// 当作配置类解析</span></span><br><span class="line">                        <span class="built_in">this</span>.importStack.registerImport(</span><br><span class="line">                                currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">                        processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                        <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">                        configClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个源码了解就到这里。</p>
<h1 id="利用-Enable-自己也装一次高大上。"><a href="#利用-Enable-自己也装一次高大上。" class="headerlink" title="利用 @Enable* 自己也装一次高大上。"></a>利用 @Enable* 自己也装一次高大上。</h1><p>我们来写一个启用切面打印日志功能。</p>
<p>我们新建一个项目，作为一个starter , 一个jar包。 然后其他项目引入这个 jar启用日志打印的操作。</p>
<p>项目如下：</p>
<img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-a228903e207405c3b19863254a231f42_720w.webp" class title="img">



<p><strong>1、EnablePrintRequestLog.java</strong></p>
<p>开启日切面功能的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;LogPrintImportSelector.class, MyImportBeanDefinitionRegistrar.class, TestBean.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnablePrintRequestLog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截哪个包</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">targetPackage</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、SysAspect.java</strong></p>
<p>切面类, 此处只拦截 自定义的包下的加了 @RestController 和 @Controller 注解的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 10:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysAspect</span> <span class="keyword">extends</span> <span class="title class_">Rules</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法规则拦截 </span></span><br><span class="line"><span class="comment">     * 此处只拦截 加了 <span class="doctag">@RestController</span> 和 <span class="doctag">@Controller</span> 注解的类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="meta">@Pointcut(&quot;@within(org.springframework.web.bind.annotation.RestController)||@within(org.springframework.stereotype.Controller)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">controllerAspect</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;controllerAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span></span><br><span class="line">    &#123;</span><br><span class="line">        interceptor.forEach(j -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getPackages().equals(getTargetClassPackage(joinPoint)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j.before(joinPoint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getTargetClassPackage</span><span class="params">(JoinPoint point)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拦截的实体类</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> point.getTarget();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截的方法名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> point.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">simpleName</span> <span class="operator">=</span> target.getClass().getSimpleName();</span><br><span class="line">        <span class="keyword">return</span> simpleName.substring(simpleName.lastIndexOf(<span class="string">&quot;.&quot;</span>) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(value = &quot;controllerAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span></span><br><span class="line">    &#123;</span><br><span class="line">        interceptor.forEach(j -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getPackages().equals(getTargetClassPackage(joinPoint)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j.after(joinPoint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;controllerAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span></span><br><span class="line">    &#123;</span><br><span class="line">        interceptor.forEach(j -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getPackages().equals(getTargetClassPackage(joinPoint)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j.afterReturning(joinPoint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;controllerAspect()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable e)</span></span><br><span class="line">    &#123;</span><br><span class="line">        interceptor.forEach(j -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getPackages().equals(getTargetClassPackage(joinPoint)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j.doAfterThrowing(joinPoint, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;controllerAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(JoinPoint joinPoint)</span></span><br><span class="line">    &#123;</span><br><span class="line">        interceptor.forEach(j -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getPackages().equals(getTargetClassPackage(joinPoint)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j.around(joinPoint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、Interceptor.java</strong></p>
<p>为了扩展性，我留了切面的 5种方法的接口：Interceptor.jarva</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(JoinPoint joinPoint,Throwable e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认一个实现打印日志：需要扩展继续实现该接口，比如我需要存储记录日志的信息。请求的时候会打印如下信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(SysAspect.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>    &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;########  &#123;&#125;  请求开始 &quot;</span> + LocalDateTime.now() + <span class="string">&quot;   ###############&quot;</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;########  &#123;&#125;  请求的方法--&gt; &quot;</span> + className + <span class="string">&quot;/&quot;</span> + methodName + <span class="string">&quot;()&quot;</span> + <span class="string">&quot;/&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span>    &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;########  结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable e)</span>    &#123;</span><br><span class="line">        LOGGER.error(<span class="string">&quot;异常了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span>    &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;######## afterReturning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;######## around&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、LogPrintImportSelector.java</strong></p>
<p>实现 ImportSelector，主要用来拿到注解 <strong>@EnablePrintRequestLog</strong> 的参数 tagetPackage 的参数。并且加载其全局配置类：GlobConfig.java</p>
<p><strong>5、GlobConfig.java</strong></p>
<p>该类的可以做所有的配置，将所需要的Bean 放到这里注入到IOC容器中，此处为了 测试 <strong>@Import</strong>注解的使用，i u 没有放在这里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 18:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 扫描包，让其自动注入 好了</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.enable.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobConfig</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、MyImportBeanDefinitionRegistrar.java</strong></p>
<p>测试动态注册Bean,注册提供的默认切面打印日志类的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">        beanDefinition.setBeanClassName(DefaultInterceptor.class.getName());</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;defaultInterceptor&quot;</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、Rules.java</strong></p>
<p>主要用来存放 切面的拦截包路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Rules</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String packages;</span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getPackages</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> packages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Rules <span class="title function_">setPackages</span><span class="params">(String packages)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.packages = packages;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7、TestBean.java</strong></p>
<p>一个测试 @Import 导入普通Bean的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m test Bean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8、TestController.java</strong></p>
<p>测试对比 该类在 com.enable.demo 的包下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 20:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TesController</span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tes</span><span class="params">()</span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>将上面的项目打成一个 jar包，然后在新的项目中引入：如下：</p>
<img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-db2ef067df0466ed0498aa837544827c_720w.webp" class title="img">



<p>在新项目中的启动类上加上：该注解：**@EnablePrintRequestLog(targetPackage &#x3D; “generator.test.demo”)** 并且指定拦截的包名称。</p>
<img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-ffa6c661d5043b78dfceacdfcdb7bb34_720w.webp" class title="img">



<p>我们启动测试。</p>
<p>如上：我们定义了两个接口：</p>
<p>1、<a href="https://link.zhihu.com/?target=http://127.0.0.1:9999/test">http://127.0.0.1:9999/test</a>. 该接口在包引用者的包下：<code>generator.test.demo</code></p>
<p>2、<a href="https://link.zhihu.com/?target=http://127.0.0.1:9999/t">http://127.0.0.1:9999/t</a> 该接口在本身的 jar 包内 :<code>com.enable.demo</code></p>
<p>所以这时候应该只会有一个请求打印日志。</p>
<p>项目启动完毕。</p>
<img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-ece99befd5fd0a02d8dbe789b12a855e_720w.webp" class title="img">



<p>**1、请求：<a href="https://link.zhihu.com/?target=http://127.0.0.1:9999/test">http://127.0.0.1:9999/test</a>**接口，应该打印请求日志:结果如下：</p>
<img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-70f2ce3fcd66616c489c6c63e25755b8_720w.webp" class title="img">



<p>请求结果正确。</p>
<p><strong>2、请求另外一个接口 <a href="https://link.zhihu.com/?target=http://127.0.0.1:9999/t">http://127.0.0.1:9999/t</a></strong> ：该接口不应该打印请求日志。</p>
<p>结果：正确</p>
<img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-8c48ef685d46536bab6841f748de02c0_720w.webp" class title="img">



<p><strong>3、重写预留的切面增强的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 22:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YY</span> <span class="keyword">extends</span> <span class="title class_">DefaultInterceptor</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写切面前置增强方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看打印结果：</p>
<img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-1f9156f9586c4bd6caecdc82af769024_720w.webp" class title="img">



<p><strong>3、去除 @EnablePrintRequestLog注解测试。</strong></p>
<p>此时没有打印日志：正确</p>
<img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-9a4d47fbf943f70f8e608c2fa66bb8e0_720w.webp" class title="img">



<p><strong>总而言之，言而总之。</strong>利用@Enbale***的原理，你也可以很轻松的打造一个低耦合的组件功能，给别人很简单明了的使用，即使你的功能错中复杂，但是对于使用者来说，越少配置越好，拿来即用。</p>
<p>比如：你可以包装一个 权限登陆组件。以后哪个项目中使用到了，注解引入 jar 包 @Enable注解打开就可以使用，多么简单容易，不用重复去写代码…….</p>
<p>你学会了吗？？？？？？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ethanwhite-chen.github.io/2023/05/23/%E8%AF%B4%E4%B8%80%E8%AF%B4ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EthanWhite-Chen">
      <meta itemprop="description" content="不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykchen的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/23/%E8%AF%B4%E4%B8%80%E8%AF%B4ThreadLocal/" class="post-title-link" itemprop="url">ThreadLocal，一篇文章就够了</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-23 20:14:10 / Modified: 23:04:10" itemprop="dateCreated datePublished" datetime="2023-05-23T20:14:10+08:00">2023-05-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">面试题目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章主要从以下几个角度来分析理解</p>
<ul>
<li><p>1、ThreadLocal是什么</p>
</li>
<li><p>2、ThreadLocal怎么用</p>
</li>
<li><p>3、ThreadLocal源码分析</p>
</li>
<li><p>4、ThreadLocal内存泄漏问题</p>
</li>
</ul>
<hr>
<h3 id="1-ThreadLocal是什么？"><a href="#1-ThreadLocal是什么？" class="headerlink" title="1. ThreadLocal是什么？"></a>1. ThreadLocal是什么？</h3><p>从名字我们就可以看到<code>ThreadLocal</code> 叫做本地线程变量，意思是说，<code>ThreadLocal</code> 中填充的的是当前线程的变量，该变量对其他线程而言是封闭且隔离的，<code>ThreadLocal</code> 为变量在每个线程中创建了一个副本，这样每个线程都可以访问自己内部的副本变量。</p>
<p>从字面意思很容易理解，但是实际角度就没那么容易了，作为一个面试常问的点，使用场景也是很丰富。</p>
<ul>
<li>1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li>
<li>2、线程间数据隔离</li>
<li>3、进行事务操作，用于存储线程事务信息。</li>
<li>4、数据库连接，<code>Session</code>会话管理。</li>
</ul>
<p>现在相信你已经对<code>ThreadLocal</code>有一个大致的认识了，下面我们看看如何用？</p>
<h3 id="2-ThreadLocal怎么用？"><a href="#2-ThreadLocal怎么用？" class="headerlink" title="2. ThreadLocal怎么用？"></a>2. ThreadLocal怎么用？</h3><p>下面让我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            local.set(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,local:&quot;</span> + local.get());</span><br><span class="line">        &#125;).start());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">线程：Thread-<span class="number">0</span>,local:Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">线程：Thread-<span class="number">1</span>,local:Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">线程：Thread-<span class="number">2</span>,local:Thread-<span class="number">2</span>:<span class="number">2</span></span><br><span class="line">线程：Thread-<span class="number">3</span>,local:Thread-<span class="number">3</span>:<span class="number">3</span></span><br><span class="line">线程：Thread-<span class="number">4</span>,local:Thread-<span class="number">4</span>:<span class="number">4</span></span><br><span class="line">线程：Thread-<span class="number">5</span>,local:Thread-<span class="number">5</span>:<span class="number">5</span></span><br><span class="line">线程：Thread-<span class="number">6</span>,local:Thread-<span class="number">6</span>:<span class="number">6</span></span><br><span class="line">线程：Thread-<span class="number">7</span>,local:Thread-<span class="number">7</span>:<span class="number">7</span></span><br><span class="line">线程：Thread-<span class="number">8</span>,local:Thread-<span class="number">8</span>:<span class="number">8</span></span><br><span class="line">线程：Thread-<span class="number">9</span>,local:Thread-<span class="number">9</span>:<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>从结果可以看到，每一个线程都有自己的local 值，这就是TheadLocal的基本使用 。</p>
<p>下面我们从源码的角度来分析一下，ThreadLocal的工作原理。</p>
<h3 id="3-ThreadLocal源码分析"><a href="#3-ThreadLocal源码分析" class="headerlink" title="3. ThreadLocal源码分析"></a>3. ThreadLocal源码分析</h3><p>1、<code>set</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread&#x27;s copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="comment">//首先获取当前线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取线程中变量 ThreadLocal.ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="comment">//如果不为空，</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果为空，初始化该线程对象的map变量，其中key 为当前的threadlocal 变量</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//初始化线程内部变量 threadLocals ，key 为当前 threadlocal</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment">         * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment">         * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>汇总下，<code>ThreadLocalMap</code> 为 <code>ThreadLocal</code> 的一个静态内部类，里面定义了<code>Entry</code> 来保存数据。而且是继承的弱引用。在<code>Entry</code>内部使用<code>ThreadLocal</code>作为<code>key</code>，使用我们设置的<code>value</code>作为<code>value</code>。</p>
<p>对于每个线程内部有个<code>ThreadLocal.ThreadLocalMap</code> 变量，存取值的时候，也是从这个容器中来获取。</p>
<p>2、<code>get</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value in the current thread&#x27;s copy of this</span></span><br><span class="line"><span class="comment">     * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">     * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread&#x27;s value of this thread-local</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的分析，相信你对该方法已经有所理解了，首先获取当前线程，然后通过<code>key threadlocal</code> 获取 设置的<code>value</code> 。</p>
<h3 id="4-ThreadLocal-内存泄漏问题"><a href="#4-ThreadLocal-内存泄漏问题" class="headerlink" title="4. ThreadLocal 内存泄漏问题"></a>4. ThreadLocal 内存泄漏问题</h3><p>我们首先来看下，下面这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>注释说的很清楚了，<code>Note that null keys (i.e. entry.get()* == null)</code></p>
<p>如果 <code>key threadlocal</code> 为 <code>null</code> 了，这个 <code>entry</code> 就可以清除了。</p>
<p><code>ThreadLocal</code>是一个弱引用，当为<code>null</code>时，会被当成垃圾回收 。</p>
<img src="/2023/05/23/%E8%AF%B4%E4%B8%80%E8%AF%B4ThreadLocal/05/23/%E8%AF%B4%E4%B8%80%E8%AF%B4ThreadLocal/v2-50b25a5f65fe02d6eebe27801a94c833_720w.webp" class title="img">

<p><strong>重点来了，突然我们ThreadLocal是null了，也就是要被垃圾回收器回收了，但是此时我们的ThreadLocalMap（thread 的内部属性）生命周期和Thread的一样，它不会回收，这时候就出现了一个现象。那就是ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。</strong></p>
<p>解决办法：使用完<code>ThreadLocal</code>后，执行<code>remove</code>操作，避免出现内存溢出情况。</p>
<p>所以 如同 <code>lock</code> 的操作 最后要执行解锁操作一样，<code>ThreadLocal</code>使用完毕一定记得执行remove 方法，清除当前线程的数值。</p>
<p>如果不<code>remove</code> 当前线程对应的<code>VALUE</code> ,就会一直存在这个值。</p>
<p>使用了线程池，可以达到“线程复用”的效果。但是归还线程之前记得清除<code>ThreadLocalMap</code>，要不然再取出该线程的时候，<code>ThreadLocal</code>变量还会存在。这就不仅仅是内存泄露的问题了，整个业务逻辑都可能会出错。</p>
<h3 id="5-为什么key使用弱引用？"><a href="#5-为什么key使用弱引用？" class="headerlink" title="5. 为什么key使用弱引用？"></a>5. 为什么key使用弱引用？</h3><p>如果使用强引用，当<code>ThreadLocal</code> 对象的引用（强引用）被回收了，<code>ThreadLocalMap</code>本身依然还持有<code>ThreadLocal</code>的强引用，如果没有手动删除这个key ,则<code>ThreadLocal</code>不会被回收，所以只要当前线程不消亡，<code>ThreadLocalMap</code>引用的那些对象就不会被回收， 可以认为这导致<code>Entry</code>内存泄漏。</p>
<p>附：强引用-软引用-弱引用</p>
<ul>
<li>强引用：普通的引用，强引用指向的对象不会被回收；</li>
<li>软引用：仅有软引用指向的对象，只有发生gc且内存不足，才会被回收；</li>
<li>弱引用：仅有弱引用指向的对象，只要发生gc就会被回收。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">EthanWhite-Chen</p>
  <div class="site-description" itemprop="description">不积跬步无以至千里，不积小流无以成江河。分享点滴成长，就有光明未来！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ethanwhite-chen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ethanwhite-chen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ykchen998@foxmail.com" title="E-Mail → ykchen998@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EthanWhite-Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">173k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">5:15</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
