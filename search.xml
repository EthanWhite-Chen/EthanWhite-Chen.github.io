<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis Cluster架构详解</title>
      <link href="/2023/06/02/Redis-Cluster%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/06/02/Redis-Cluster%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么有了主从架构后还需要Redis-Cluster架构"><a href="#为什么有了主从架构后还需要Redis-Cluster架构" class="headerlink" title="为什么有了主从架构后还需要Redis Cluster架构"></a>为什么有了主从架构后还需要Redis Cluster架构</h2><h3 id="主从架构的容量瓶颈"><a href="#主从架构的容量瓶颈" class="headerlink" title="主从架构的容量瓶颈"></a>主从架构的容量瓶颈</h3><p>我们回忆一下主从架构（一主多从）中，master节点负责写入数据，并同步给slave节点，然后slave节点负责处理读请求；可以通过slave节点的扩容，提高主从架构的读QPS；同时基于哨兵可以确保主从架构的高可用性。</p><p>可以说主从 + 哨兵的一套组合拳，既能抗住高并发的读请求，同时也可以实现高可用性；但是主从架构的数据来源其实是master，而主从架构中只有一个master节点，就导致了redis存储的数据容量是很有限的。在海量数据场景下，如果单单使用主从+哨兵的架构，肯定是不行的。</p><blockquote><p>这就是我们所说的主从架构容量瓶颈。</p></blockquote><p>所以我们需要一个新的架构来支撑海量数据。</p><p>读者可以先思考一下，单个master节点的数据容量是有限的，那么我们搞多个master节点，并且每个master节点中的数据都是不同的，这样不就可以支撑更大的数据量了吗？</p><p>再说，这个新的架构支撑了更多的数据量，同时你至少也需要支撑高可用吧，如果连高可用性都不能保障的话，要这么大的数据量有什么用，一旦某个master节点发生故障，那么整个架构就不可用了，这也太坑爹了吧。所以新的架构也要做到高可用。</p><p><strong>这个新的架构，也就是我们接下来要讲解的Redis Cluster。</strong></p><h2 id="Redis-Cluster原理"><a href="#Redis-Cluster原理" class="headerlink" title="Redis Cluster原理"></a>Redis Cluster原理</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li><p>Redis Cluster包含多个master节点，每个master节点挂在多个slave节点，多个master可以支撑更大的数据量</p><blockquote><p><strong>横向扩容支持更大数据量</strong>：如果我们需要支撑更多的数据量，那么添加新的master和slave节点就好了</p></blockquote></li><li><p>当master节点挂掉后，Redis Cluster会从master对应的slave节点中选举出一个新的master完成故障转移（<strong>高可用</strong>）</p></li><li><p>redis cluster默认是不支持slave节点读或者写的，slave节点更多是为了master发生故障时备用的节点</p></li></ul><h3 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h3><h4 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h4><h5 id="维护元信息的两种方式介绍"><a href="#维护元信息的两种方式介绍" class="headerlink" title="维护元信息的两种方式介绍"></a>维护元信息的两种方式介绍</h5><p>在分布式存储中需要提供维护<strong>节点元信息</strong>的机制，常见的元信息维护方式为：集中式和P2P。Redis Cluster使用的是P2P的<code>gossip</code>协议。</p><blockquote><p><strong>节点元信息主要包括：节点负责哪些数据、是否出现故障等状态信息。</strong></p></blockquote><p>我们来对比一下这两种维护元信息的方式。</p><p>集中式：将元信息集中存储在一个外部组件里，比如ZooKeeper</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/276c8fb74c54408181d0efb8efb7abec~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="集中式元信息存储">集中式元信息存储</p><blockquote><ul><li>集中式的优点在于元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的存储中，其他节点读取的时候立即就可以感知到;</li><li>缺点在于，所有的元数据的跟新压力全部集中在一个地方，可能会导致元数据的存储有压力。</li></ul></blockquote><p>gossip协议：</p><ul><li>好处：元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力</li><li>缺点：<strong>元数据更新有延时</strong>，可能导致集群的一些操作会有一些滞后</li></ul><h5 id="10000端口"><a href="#10000端口" class="headerlink" title="10000端口"></a>10000端口</h5><p>每个节点都有一个专门用于<strong>节点间通信的端口</strong>，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口</p><blockquote><p>每个节点隔一段时间都会往另外几个节点发送<code>ping</code>消息，同时其他几点接收到<code>ping</code>之后返回<code>pong</code></p></blockquote><h5 id="节点交换的信息"><a href="#节点交换的信息" class="headerlink" title="节点交换的信息"></a>节点交换的信息</h5><blockquote><p>包含故障信息，节点的增加和移除，<code>hash slot</code>信息等等</p></blockquote><h5 id="gossip协议详解"><a href="#gossip协议详解" class="headerlink" title="gossip协议详解"></a>gossip协议详解</h5><h6 id="gossip消息"><a href="#gossip消息" class="headerlink" title="gossip消息"></a><code>gossip</code>消息</h6><blockquote><p><code>gossip</code>协议包含多种消息，包括<code>ping</code>、<code>pong</code>、<code>meet</code>、<code>fail</code>等等。</p></blockquote><ul><li><p><code>meet</code>：某个节点发送<code>meet</code>消息给新加入的节点，让新节点加入到集群中，然后新节点就会与其他节点通信</p></li><li><p><code>ping</code>：每个节点每秒都会频繁给其他节点发送<code>ping</code>，其中包含自己的状态还有自己维护的集群元信息。（节点之间互相交换元信息）</p><blockquote><ul><li>节点之间互相通过<code>ping</code>交换元信息。</li><li>每个节点每秒都会频繁发送<code>ping</code>给其他的节点，频繁的互相之间交换数据，互相进行元数据的更新</li></ul></blockquote></li><li><p><code>pong</code>：返回<code>ping</code>和<code>meet</code>，包含自己的状态和其他信息，也可以用于信息广播和更新</p></li><li><p><code>fail</code>：<strong>某个节点判断另一个节点<code>fail</code>之后，就发送<code>fail</code>给其他节点，通知其他节点，指定的节点宕机了</strong></p></li></ul><blockquote><p><code>ping</code>消息的深入理解：</p><ul><li><p><code>ping</code>很频繁，而且要携带一些元数据，所以可能会加重网络负担</p><blockquote><ul><li>考虑到网络开销，每个节点每秒会执行10次<code>ping</code>时，每次会选择5个最久没有通信的其他节点</li><li>当然如果发现与某个节点通信延时达到了<code>cluster_node_timeout</code> &#x2F; 2，那么立即发送<code>ping</code>，避免数据交换延时过长，落后的时间太长了<ul><li>比如说，两个节点之间都10分钟没有交换数据了，那么整个集群处于<strong>严重的元数据不一致</strong>的情况，就会有问题；所以<code>cluster_node_timeout</code>可以调节，如果调节比较大，那么会降低发送的频率</li></ul></li></ul></blockquote></li><li><p>每次<code>ping</code>，一个是带上自己节点的信息，还有就是带上<code>1/10</code>其他节点的信息，发送出去，进行数据交换</p></li></ul></blockquote><h3 id="高可用性与主备切换原理"><a href="#高可用性与主备切换原理" class="headerlink" title="高可用性与主备切换原理"></a>高可用性与主备切换原理</h3><blockquote><p>redis cluster的高可用的原理，几乎跟哨兵是类似的。</p></blockquote><h4 id="1-判断节点宕机"><a href="#1-判断节点宕机" class="headerlink" title="1. 判断节点宕机"></a>1. 判断节点宕机</h4><ul><li><p>如果一个节点认为另外一个节点宕机，那么就是<code>pfail</code>，主观宕机</p></li><li><p>如果多个节点都认为另外一个节点宕机了，那么就是<code>fail</code>，客观宕机</p><blockquote><p>可以类比到哨兵中的<code>sdown</code>、<code>odown</code></p></blockquote></li></ul><p>如果在<code>cluster-node-timeout</code>内，某个节点一直没有返回<code>pong</code>，那么就被认为<code>pfail</code>。</p><p>如果一个节点认为某个节点<code>pfail</code>了，那么会在gossip <code>ping</code>消息中，<code>ping</code>给其他节点，如果超过半数的节点都认为<code>pfail</code>了，那么就会变成<code>fail</code>（客观宕机）。</p><h4 id="2-从节点过滤"><a href="#2-从节点过滤" class="headerlink" title="2. 从节点过滤"></a>2. 从节点过滤</h4><ul><li>对宕机的master node，从其所有的slave node中，选择一个切换成master node</li><li>检查每个slave node与master node断开连接的时间，如果超过了<code>cluster-node-timeout</code> * <code>cluster-slave-validity-factor</code>，那么就没有资格切换成master</li></ul><h4 id="3-从节点选举"><a href="#3-从节点选举" class="headerlink" title="3. 从节点选举"></a>3. 从节点选举</h4><ol><li>每个从节点，都根据自己对master复制数据的<code>offset</code>，来设置一个选举时间，offset越大（复制数据越多）的从节点，选举时间越靠前，<strong>优先进行选举</strong>。</li><li>所有的master node开始slave选举投票，给要进行选举的slave进行投票，如果大部分master node（N&#x2F;2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成master。</li><li>从节点执行主备切换，从节点切换为主节点（故障转移）</li></ol><blockquote><p>哨兵的从节点选举：对所有从节点进行排序，slave <code>priority</code>，<code>offset</code>，<code>run id</code></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文先从主从架构的不足之处引出了Redis Cluster，然后介绍了Redis Cluster的原理，主要包含gossip协议以及高可用实现原理这两个点。本文并没有详细讲述Redis Cluster中比较重要的数据分片算法：hash slot算法，后面会专门写一篇文章讲述一下。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析 Redis 分布式锁原理</title>
      <link href="/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/"/>
      <url>/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、实现原理"><a href="#一、实现原理" class="headerlink" title="一、实现原理"></a>一、实现原理</h2><h2 id="1-1-基本原理"><a href="#1-1-基本原理" class="headerlink" title="1.1 基本原理"></a>1.1 基本原理</h2><p>JDK 原生的锁可以让不同<strong>线程</strong>之间以互斥的方式来访问共享资源，但如果想要在不同<strong>进程</strong>之间以互斥的方式来访问共享资源，JDK 原生的锁就无能为力了。此时可以使用 Redis 来实现分布式锁。</p><p>Redis 实现分布式锁的核心命令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure><p>SETNX 命令的作用是：如果指定的 key 不存在，则创建并为其设置值，然后返回状态码 1；如果指定的 key 存在，则直接返回 0。如果返回值为 1，代表获得该锁；此时其他进程再次尝试创建时，由于 key 已经存在，则都会返回 0 ，代表锁已经被占用。</p><p>当获得锁的进程处理完成业务后，再通过 del 命令将该 key 删除，其他进程就可以再次竞争性地进行创建，获得该锁。</p><p>通常为了避免死锁，我们会为锁设置一个超时时间，在 Redis 中可以通过 expire 命令来进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key seconds</span><br></pre></td></tr></table></figure><p>这里我们将两者结合起来，并使用 Jedis 客户端来进行实现，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> jedis.setnx(<span class="string">&quot;lockKey&quot;</span>, <span class="string">&quot;lockValue&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果此处程序被异常终止（如直接kill -9进程），则设置超时的操作就无法进行，该锁就会出现死锁</span></span><br><span class="line">    jedis.expire(<span class="string">&quot;lockKey&quot;</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码存在原子性问题，即 setnx + expire 操作是非原子性的，如果在设置超时时间前，程序被异常终止，则程序就会出现死锁。此时可以将 SETNX 和 EXPIRE 两个命令写在同一个 Lua 脚本中，然后通过调用 Jedis 的 eval() 方法来执行，并由 Redis 来保证整个 Lua 脚本操作的原子性。这种方式实现比较繁琐，因此官方文档中推荐了另外一种更加优雅的实现方法：</p><h2 id="1-2-官方推荐"><a href="#1-2-官方推荐" class="headerlink" title="1.2 官方推荐"></a>1.2 官方推荐</h2><p>[官方文档]( Distributed locks with Redis) 中推荐直接使用 set 命令来进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]</span><br></pre></td></tr></table></figure><p>这里我们主要关注以下四个参数：</p><ul><li><strong>EX</strong> ：设置超时时间，单位是秒；</li><li><strong>PX</strong> ：设置超时时间，单位是毫秒；</li><li><strong>NX</strong> ：当且仅当对应的 Key 不存在时才进行设置；</li><li><strong>XX</strong>：当且仅当对应的 Key 存在时才进行设置。</li></ul><p>这四个参数从 Redis 2.6.12 版本开始支持，因为当前大多数在用的 Redis 都已经高于这个版本，所以推荐直接使用该命令来实现分布式锁。对应的 Jedis 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;lockKey&quot;</span>, <span class="string">&quot;lockValue&quot;</span>, SetParams.setParams().nx().ex(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>此时一条命令就可以完成值和超时时间的设置，并且因为只有一条命令，因此其原子性也得到了保证。但因为引入了超时时间来避免死锁，同时也引出了其它两个问题：</p><img src="/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/v2-c2a257e6e20e01b93e012b5c8c710a95_720w.webp" class title="img"><ul><li><strong>问题一</strong>：当业务处理的时间超过过期时间后（图中进程 A），由于锁已经被释放，此时其他进程就可以获得该锁（图中进程 B），这意味着有两个进程（A 和 B）同时进入了临界区，此时分布式锁就失效了；</li><li><strong>问题二</strong>：如上图所示，当进程 A 业务处理完成后，此时删除的是进程 B 的锁，进而导致分布式锁又一次失效，让进程 B 和 进程 C 同时进入了临界区。</li></ul><p>针对问题二，我们可以在创建锁时为其指定一个唯一的标识作为 Key 的 Value，这里假设我们采用 UUID + 线程ID 来作为唯一标识：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">identifier</span> <span class="operator">=</span> UUID.randomUUID() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">jedis.set(<span class="string">&quot;LockKey&quot;</span>, identifier, SetParams.setParams().nx().ex(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>然后在删除锁前，先将该唯一标识与锁的 Value 值进行比较，如果不相等，证明该锁不属于当前的操作对象，此时不执行删除操作。为保证判断操作和删除操作整体的原子性，这里需要使用 Lua 脚本来执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这段脚本的意思是如果 value 的值与给定的值相同，则执行删除命令，否则直接返回状态码 0 。对应使用 Jedis 实现的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">jedis.eval(script, </span><br><span class="line">           Collections.singletonList(<span class="string">&quot;LockKey&quot;</span>),  <span class="comment">// keys的集合</span></span><br><span class="line">           Collections.singletonList(identifier)  <span class="comment">// args的集合</span></span><br><span class="line">          );</span><br></pre></td></tr></table></figure><p>接着再看问题一，问题一最简单的解决方法是：你可以估计业务的最大处理时间，然后保证设置的过期时间大于最大处理时间。但是由于业务会面临各种复杂的情况，因此可能无法保证业务每一次都能在规定的过期时间内处理完成，此时可以使用延长锁时效的策略。</p><h2 id="1-3-延长锁时效"><a href="#1-3-延长锁时效" class="headerlink" title="1.3 延长锁时效"></a>1.3 延长锁时效</h2><p>延长锁时效的方案如下：假设锁超时时间是 30 秒，此时程序需要每隔一段时间去扫描一下该锁是否还存在，扫描时间需要小于超时时间，通常可以设置为超时时间的 1&#x2F;3，在这里也就是 10 秒扫描一次。如果锁还存在，则重置其超时时间恢复到 30 秒。通过这种方案，只要业务还没有处理完成，锁就会一直有效；而当业务一旦处理完成，程序也会马上删除该锁。</p><p>Redis 的 Java 客户端 Redisson 提供的分布式锁就支持类似的延长锁时效的策略，称为 WatchDog，直译过来就是 “看门狗” 机制。</p><p>以上讨论的都是单机环境下的 Redis 分布式锁，而想要保证 Redis 分布式锁是高可用，首先 Redis 得是高可用的，Redis 的高可用模式主要有两种：哨兵模式和集群模式。以下分别进行讨论：</p><h2 id="二、哨兵模式与分布式锁"><a href="#二、哨兵模式与分布式锁" class="headerlink" title="二、哨兵模式与分布式锁"></a>二、哨兵模式与分布式锁</h2><p>哨兵模式是主从模式的升级版，能够在故障发生时自动进行故障切换，选举出新的主节点。但由于 Redis 的复制机制是异步的，因此在哨兵模式下实现的分布式锁是不可靠的，原因如下：</p><ul><li>由于主从之间的复制操作是异步的，当主节点上创建好锁后，此时从节点上的锁可能尚未创建。而如果此时主节点发生了宕机，从节点上将不会创建该分布式锁；</li><li>从节点晋升为主节点后，其他进程（或线程）仍然可以在该新主节点创建分布式锁，此时就存在多个进程（或线程）同时进入了临界区，分布式锁就失效了。</li></ul><p>因此在哨兵模式下，无法避免锁失效的问题。因此想要实现高可用的分布式锁，可以采取 Redis 的另一个高可用方案 —— Redis 集群模式。</p><h2 id="三、集群模式与分布式锁"><a href="#三、集群模式与分布式锁" class="headerlink" title="三、集群模式与分布式锁"></a>三、集群模式与分布式锁</h2><h2 id="3-1-RedLock-方案"><a href="#3-1-RedLock-方案" class="headerlink" title="3.1 RedLock 方案"></a>3.1 RedLock 方案</h2><p>想要在集群模式下实现分布式锁，Redis 提供了一种称为 RedLock 的方案，假设我们有 N 个 Redis 实例，此时客户端的执行过程如下：</p><ul><li>以毫秒为单位记录当前的时间，作为开始时间；</li><li>接着采用和单机版相同的方式，依次尝试在每个实例上创建锁。为了避免客户端长时间与某个故障的 Redis 节点通讯而导致阻塞，这里采用快速轮询的方式：假设创建锁时设置的超时时间为 10 秒，则访问每个 Redis 实例的超时时间可能在 5 到 50 毫秒之间，如果在这个时间内还没有建立通信，则尝试连接下一个实例；</li><li>如果在至少 N&#x2F;2+1 个实例上都成功创建了锁。并且 当前时间 - 开始时间 &lt; 锁的超时时间 ，则认为已经获取了锁，锁的有效时间等于 超时时间 - 花费时间（如果考虑不同 Redis 实例所在服务器的时钟漂移，则还需要减去时钟漂移）；</li><li>如果少于 N&#x2F;2+1 个实例，则认为创建分布式锁失败，此时需要删除这些实例上已创建的锁，以便其他客户端进行创建。</li><li>该客户端在失败后，可以等待一个随机的时间后，再次进行重试。</li></ul><p>以上就是 RedLock 的实现方案，可以看到主要是由客户端来实现的，并不真正涉及到 Redis 集群相关的功能。因此这里的 N 个 Redis 实例并不要求是一个真正的 Redis 集群，它们彼此之间可以是完全独立的，但由于只需要半数节点获得锁就能真正获得锁，因此其仍然具备容错性和高可用性。后面使用 Redisson 来演示 RedLock 时会再次验证这一点。</p><h2 id="3-2-低延迟通讯"><a href="#3-2-低延迟通讯" class="headerlink" title="3.2 低延迟通讯"></a>3.2 低延迟通讯</h2><p>另外实现 RedLock 方案的客户端与所有 Redis 实例进行通讯时，必须要保证低延迟，而且最好能使用多路复用技术来保证一次性将 SET 命令发送到所有 Redis 节点上，并获取到对应的执行结果。如果网络延迟较高，假设客户端 A 和 B 都在尝试创建锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET key 随机数A EX <span class="number">3</span> NX  #A客户端</span><br><span class="line">SET key 随机数B EX <span class="number">3</span> NX  #B客户端</span><br></pre></td></tr></table></figure><p>此时可能客户端 A 在一半节点上创建了锁，而客户端 B 在另外一半节点上创建了锁，那么两个客户端都将无法获取到锁。如果并发很高，则可能存在多个客户端分别在部分节点上创建了锁，而没有一个客户端的数量超过 N&#x2F;2+1。这也就是上面过程的最后一步中，强调一旦客户端失败后，需要等待一个随机时间后再进行重试的原因，如果是一个固定时间，则所有失败的客户端又同时发起重试，情况就还是一样。</p><p>因此最佳的实现就是客户端的 SET 命令能几乎同时到达所有节点，并几乎同时接受到所有执行结果。 想要保证这一点，低延迟的网络通信极为关键，下文介绍的 Redisson 就采用 Netty 框架来保证这一功能的实现。</p><h2 id="3-3-持久化与高可用"><a href="#3-3-持久化与高可用" class="headerlink" title="3.3 持久化与高可用"></a>3.3 持久化与高可用</h2><p>为了保证高可用，所有 Redis 节点还需要开启持久化。假设不开启持久化，假设进程 A 获得锁后正在处理业务逻辑，此时节点宕机重启，因为锁数据丢失了，其他进程便可以再次创建该锁，因此所有 Redis 节点都需要开启 AOF 的持久化方式。</p><p>AOF 默认的同步机制为 everysec，即每秒进程一次持久化，此时能够兼顾性能与数据安全，发生意外宕机的时，最多会丢失一秒的数据。但如果碰巧就是在这一秒的时间内进程 A 创建了锁，并由于宕机而导致数据丢失。此时其他进程还可以创建该锁，锁的互斥性也就失效了。想要解决这个问题有两种方式：</p><ul><li><strong>方式一</strong>：修改 Redis.conf 中 appendfsync 的值为 always，即每次命令后都进行持久化，此时会降低 Redis 性能，进而也会降低分布式锁的性能，但锁的互斥性得到了绝对的保证；</li><li><strong>方式二</strong>：一旦节点宕机了，需要等到锁的超时时间过了之后才进行重启，此时相当于原有锁自然失效（但你首先需要保证业务能在设定的超时时间内完成），这种方案也称为延时重启。</li></ul><h2 id="四、Redisson"><a href="#四、Redisson" class="headerlink" title="四、Redisson"></a>四、Redisson</h2><p>Redisson 是 Redis 的 Java 客户端，它提供了各种的 Redis 分布式锁的实现，如可重入锁、公平锁、RedLock、读写锁等等，并且在实现上考虑得也更加全面，适用于生产环境下使用。</p><h2 id="4-1-分布式锁"><a href="#4-1-分布式锁" class="headerlink" title="4.1 分布式锁"></a>4.1 分布式锁</h2><p>使用 Redisson 来创建单机版本分布式锁非常简单，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建RedissonClient,如果与spring集成，可以将RedissonClient声明为Bean,在使用时注入即可</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.100:6379&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建锁实例</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//3.尝试获取分布式锁，第一个参数为等待时间，第二个参数为锁过期时间</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">10</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">// 4.模拟业务处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;处理业务逻辑&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">20</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//5.释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">redissonClient.shutdown();</span><br></pre></td></tr></table></figure><p>此时对应在 Redis 中的数据结构如下：</p><img src="/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/v2-28d9e979f9f7a695267e7ac8c77e01c2_720w.webp" class title="img"><p>可以看到 key 就是代码中设置的锁名，而 value 值的类型是 hash，其中键 9280e909-c86b-43ec-b11d-6e5a7745e2e9:13 的格式为 UUID + 线程ID ；键对应的值为 1，代表加锁的次数。之所以要采用 hash 这种格式，主要是因为 Redisson 创建的锁是具有重入性的，即你可以多次进行加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isLock1</span> <span class="operator">=</span> lock.tryLock(<span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLock2</span> <span class="operator">=</span> lock.tryLock(<span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>此时对应的值就会变成 2，代表加了两次锁：</p><img src="/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/v2-90d0663d51c8fca4d8e2a9035406c186_720w.webp" class title="img"><p>当然和其他重入锁一样，需要保证解锁的次数和加锁的次数一样，才能完全解锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock.unlock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><h2 id="4-2-RedLock"><a href="#4-2-RedLock" class="headerlink" title="4.2 RedLock"></a>4.2 RedLock</h2><p>Redisson 也实现了 Redis 官方推荐的 RedLock 方案，这里我们启动三个 Redis 实例进行演示，它们彼此之间可以是完全独立的，并不需要进行集群的相关配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-server ../redis.conf</span><br><span class="line">$ ./redis-server ../redis.conf --port <span class="number">6380</span></span><br><span class="line">$ ./redis-server ../redis.conf --port <span class="number">6381</span></span><br></pre></td></tr></table></figure><p>对应的代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建RedissonClient</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config01.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.100:6379&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient01</span> <span class="operator">=</span> Redisson.create(config01);</span><br><span class="line"><span class="type">Config</span> <span class="variable">config02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config02.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.100:6380&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient02</span> <span class="operator">=</span> Redisson.create(config02);</span><br><span class="line"><span class="type">Config</span> <span class="variable">config03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config03.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.100:6381&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient03</span> <span class="operator">=</span> Redisson.create(config03);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建锁实例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lockName</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock01</span> <span class="operator">=</span> redissonClient01.getLock(lockName);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock02</span> <span class="operator">=</span> redissonClient02.getLock(lockName);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock03</span> <span class="operator">=</span> redissonClient03.getLock(lockName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 RedissonRedLock</span></span><br><span class="line"><span class="type">RedissonRedLock</span> <span class="variable">redLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonRedLock</span>(lock01, lock02, lock03);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redLock.tryLock(<span class="number">10</span>, <span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">// 4.模拟业务处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;处理业务逻辑&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">200</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//5.释放锁</span></span><br><span class="line">    redLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redissonClient01.shutdown();</span><br><span class="line">redissonClient02.shutdown();</span><br><span class="line">redissonClient03.shutdown();</span><br></pre></td></tr></table></figure><p>此时每个 Redis 实例上锁的情况如下：</p><img src="/2023/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/06/01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/v2-27d8b6a263203ca7996d7d1f839009d5_720w.webp" class title="img"><p>可以看到每个实例上都获得了锁。</p><h2 id="4-3-延长锁时效"><a href="#4-3-延长锁时效" class="headerlink" title="4.3 延长锁时效"></a>4.3 延长锁时效</h2><p>最后，介绍一下 Redisson 的 WatchDog 机制，它可以用来延长锁时效，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line"><span class="comment">// 1.设置WatchdogTimeout</span></span><br><span class="line">config.setLockWatchdogTimeout(<span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.100:6379&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建锁实例</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//3.尝试获取分布式锁，第一个参数为等待时间</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">// 4.模拟业务处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;处理业务逻辑&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;锁剩余的生存时间：&quot;</span> + lock.remainTimeToLive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//5.释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">redissonClient.shutdown();</span><br></pre></td></tr></table></figure><p>首先 Redisson 的 WatchDog 机制只会对那些没有设置锁超时时间的锁生效，所以我们这里调用的是两个参数的 tryLock() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><p>而不是包含超时时间的三个参数的 tryLock() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其次我们通过 config.setLockWatchdogTimeout(30 * 1000) 将 lockWatchdogTimeout 的值设置为 30000 毫秒（默认值也是 30000 毫秒）。此时 Redisson 的 WatchDog 机制会以 lockWatchdogTimeout 的 1&#x2F;3 时长为周期（在这里就是 10 秒）对所有未设置超时时间的锁进行检查，如果业务尚未处理完成（也就是锁还没有被程序主动删除），Redisson 就会将锁的超时时间重置为 lockWatchdogTimeout 指定的值（在这里就是设置的 30 秒），直到锁被程序主动删除位置。因此在上面的例子中可以看到，不论将模拟业务的睡眠时间设置为多长，其锁都会存在一定的剩余生存时间，直至业务处理完成。</p><p>反之，如果明确的指定了锁的超时时间 leaseTime，则以 leaseTime 的时间为准，因为 WatchDog 机制对明确指定超时时间的锁不会生效。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Plus的BaseMapper实现原理</title>
      <link href="/2023/06/01/MyBatis-Plus%E7%9A%84BaseMapper%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2023/06/01/MyBatis-Plus%E7%9A%84BaseMapper%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Mybatis-plus为我们提供了一些通用mapper方法，比如insert，update，selectById等等，我们通过让自己的mapper继承BaseMapper这个类就可以不用自己写sql就能直接调用一些基础的sql方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>但是在使用过程中还是发现这里面提供的方法有点少，当我们想要添加自己的通用sql方法的时候，可以通过官方文档描述的 <a href="https://link.juejin.cn/?target=https://mp.baomidou.com/guide/sql-injector.html">Sql 注入器</a> 来实现。比我们我们自己定义一个saveBatch方法，用来批量的插入数据。</p><h2 id="BaseMapper自定义扩展"><a href="#BaseMapper自定义扩展" class="headerlink" title="BaseMapper自定义扩展"></a>BaseMapper自定义扩展</h2><p>mybatis-plus提供了<code>ISqlInjector</code>接口，以及<code>AbstractSqlInjector</code>抽象类。我们通过实现该接口，或者继承抽象类的方式注入我们自已定义的SQL逻辑，然后继承BaseMapper添加我们需要的方法就可以添加自定义的mapper方法。</p><p>在这2个接口之外，mybatis-plus其实为我们提供了一个默认实现：<code>DefaultSqlInjector</code>，这里面已经包含了一些mybatis-plus已经封装好的BaseMapper里面的方法，我们想要扩展的话，可以直接继承这个类来进行扩展添加我们的方法。</p><p>这里我们希望在BaseMapper之外添加一个saveBatch方法，用来可以批量的插入数据：</p><ol><li>实现<code>DefaultSqlInjector</code>类，我们可以看到<strong>需要实现<code>getMethodList</code>方法</strong>，这个方法参数是mapper接口的class类，返回值是一个List<AbstractMethod>。所以我们自定义的方法是需要实现<code>AbstractMethod</code>。可以参考mybatis-plus中已经实现了一些<code>AbstractMethod</code>方法，我们仿造写一个SaveBatch类。</AbstractMethod></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomSqlInjector</span> <span class="keyword">extends</span> <span class="title class_">DefaultSqlInjector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title function_">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> &#123;</span><br><span class="line">      <span class="comment">// 父类的list已经包含了BaseMapper的基础方法。</span></span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="built_in">super</span>.getMethodList(mapperClass);</span><br><span class="line">        <span class="comment">// 添加我们需要增加的自定义方法。</span></span><br><span class="line">        methodList.add(<span class="keyword">new</span> <span class="title class_">SaveBatch</span>());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实现SaveBatch类的逻辑（这是官方的samples）。我们可以看到，这里的逻辑主要就是为了<strong>生成MappedStatement对象</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaveBatch</span> <span class="keyword">extends</span> <span class="title class_">AbstractMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MappedStatement <span class="title function_">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;&lt;script&gt;insert into %s %s values %s&lt;/script&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fieldSql</span> <span class="operator">=</span> prepareFieldSql(tableInfo);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">valueSql</span> <span class="operator">=</span> prepareValuesSqlForMysqlBatch(tableInfo);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sqlResult</span> <span class="operator">=</span> String.format(sql, tableInfo.getTableName(), fieldSql, valueSql);</span><br><span class="line">        <span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> languageDriver.createSqlSource(configuration, sqlResult, modelClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.addInsertMappedStatement(mapperClass, modelClass, <span class="string">&quot;saveBatch&quot;</span>, sqlSource, <span class="keyword">new</span> <span class="title class_">NoKeyGenerator</span>(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">prepareFieldSql</span><span class="params">(TableInfo tableInfo)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">fieldSql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        fieldSql.append(tableInfo.getKeyColumn()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        tableInfo.getFieldList().forEach(x -&gt; &#123;</span><br><span class="line">            fieldSql.append(x.getColumn()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        fieldSql.delete(fieldSql.length() - <span class="number">1</span>, fieldSql.length());</span><br><span class="line">        fieldSql.insert(<span class="number">0</span>, <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        fieldSql.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fieldSql.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">prepareValuesSqlForMysqlBatch</span><span class="params">(TableInfo tableInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">valueSql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        valueSql.append(<span class="string">&quot;&lt;foreach collection=\&quot;list\&quot; item=\&quot;item\&quot; index=\&quot;index\&quot; open=\&quot;(\&quot; separator=\&quot;),(\&quot; close=\&quot;)\&quot;&gt;&quot;</span>);</span><br><span class="line">        valueSql.append(<span class="string">&quot;#&#123;item.&quot;</span>).append(tableInfo.getKeyProperty()).append(<span class="string">&quot;&#125;,&quot;</span>);</span><br><span class="line">        tableInfo.getFieldList().forEach(x -&gt; valueSql.append(<span class="string">&quot;#&#123;item.&quot;</span>).append(x.getProperty()).append(<span class="string">&quot;&#125;,&quot;</span>));</span><br><span class="line">        valueSql.delete(valueSql.length() - <span class="number">1</span>, valueSql.length());</span><br><span class="line">        valueSql.append(<span class="string">&quot;&lt;/foreach&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> valueSql.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>最后我们需要将我们的Injector注入Spring容器中，替换默认的Injector。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CustomSqlInjector <span class="title function_">myLogicSqlInjector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomSqlInjector</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>验证：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TB3Mapper</span> <span class="keyword">extends</span> <span class="title class_">MyBaseMapper</span>&lt;Tb3&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Tb3&gt; tb3s = Arrays.asList(Tb3.getInstance(), Tb3.getInstance());</span><br><span class="line">    tb3Mapper.saveBatch(tb3s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output log</span></span><br><span class="line">==&gt;  Preparing: insert into <span class="title function_">tb3</span> <span class="params">(id,f1,f2,f3)</span> values ( ?,?,?,? ),( ?,?,?,? )</span><br><span class="line">==&gt; Parameters: <span class="number">38</span>(Integer), <span class="number">62</span>(Integer), -<span class="number">1546785812</span>(Integer), -<span class="number">16950756</span>(Integer), <span class="number">24</span>(Integer), <span class="number">17</span>(Integer), -<span class="number">1871764773</span>(Integer), <span class="number">169785869</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>首先简单说下mybatis-plus，我只是简单翻了下源码，mybatis-plus的工作原理就是：全面再次代理了mybatis的一些东西。比如自动配置转用了MybatisPlusAutoConfiguration，SqlSessionFactoryBean转用了MybatisSqlSessionFactoryBean等等，这些mybatis的核心部件，全部都被mybatis-plus给替换了，用成了它自己的，然后它就在自己的里面定制了自己的逻辑。</p><p>我只分析下BaseMapper的实现原理，当初在文档中没有看到这块，自己手写了一版自定义的逻辑，跟踪了这块代码。在这之前还是简单阐述下mybatis的一些核心的原理，如果没有看过mybatis源码的话，知道这些也应该能看懂。</p><p><strong>mybatis的整体逻辑可以分为2块</strong>：</p><ol><li>配置文件解析：这过程包括解析我们config的配置，以及mapper.xml文件。最终配置都会被解析到一个Configuration对象里面，后面的每个SqlSession也都会包含一个该Configuration对象实例的引用。这个Configuration里面最重要的有2个东西：</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72e6daf364f4649894a9cf26eeb2708~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210830223002642.png"></p><ul><li>mappedStatements：存放mapper对应的sql信息</li><li>mybatisMapperRegistry.knownMappers：存放mapper接口对应的代理类</li></ul><p>这2个东西贯穿了mybatis的接口到sql的执行逻辑。</p><ol><li>接口的调用：我们接口调用的其实是代理的包装类，这个类也是上图mybatisMapperRegistry.knownMappers里面展示的MybatisMapperProxyFactory（mybatis是MapperProxyFactory）的getObject返回的代理MybatisMapperProxy对象。这个代理类里面的主要逻辑就是拿着该类的全限定类名，指定某个方法的时候，去Configuration的mappedStatements里面去找到对应的sql。</li></ol><p>所以知道了mybatis的大概逻辑了，我们可以猜到：<strong>在Configuration加载的时候，一定有地方将我们BaseMapper的默认方法对应的SQL的信息给装载到mappedStatements这个map里面去。我们就需要去跟踪，在哪里我们将这些默认的基础方法的MappedStatement对象进行构建，并插入到configuration中的。</strong></p><p>debug跟踪可以发现：</p><p>第一步，肯定是自动配置要加载SqlSessionFactory，这个方法主要是构建MybatisSqlSessionFactoryBean对象，然后调用getObject方法，我们跟进<code>MybatisSqlSessionFactoryBean.getObject()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    notNull(dataSource, <span class="string">&quot;Property &#x27;dataSource&#x27; is required&quot;</span>);</span><br><span class="line">    state((configuration == <span class="literal">null</span> &amp;&amp; configLocation == <span class="literal">null</span>) || !(configuration != <span class="literal">null</span> &amp;&amp; configLocation != <span class="literal">null</span>),</span><br><span class="line">        <span class="string">&quot;Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together&quot;</span>);</span><br><span class="line">  <span class="comment">// 这里才是开始构建SqlSessionFactory的</span></span><br><span class="line">    <span class="built_in">this</span>.sqlSessionFactory = buildSqlSessionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最终会执行到buildSqlSessionFactory()。这块方法的主要逻辑就是解析XML配置来创建Configuration对象。我们可以在最下面发现解析我们mapper.xml文件的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Resource mapperLocation : <span class="built_in">this</span>.mapperLocations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapperLocation == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 对每一个mapper.xml文件进行解析</span></span><br><span class="line">                <span class="type">XMLMapperBuilder</span> <span class="variable">xmlMapperBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(mapperLocation.getInputStream(),</span><br><span class="line">                    targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                xmlMapperBuilder.parse();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ErrorContext.instance().reset();</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(() -&gt; <span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初步猜测：sql信息就是在这里面被装载进去的，重点看看<code>xmlMapperBuilder.parse();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">// debug发现，Configuration中mappedStatements在执行该方法之后，mapper方法数量就变多了。</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>bindMapperForNamespace</code>里面，是在执行<code>configuration.addMapper(boundType);</code>之后方法变多的。这个方法最终调用的是<code>MybatisMapperRegistry.addMapper()</code>，这个方法里面最终会转去调用<code>MybatisMapperAnnotationBuilder.parse()</code>方法，将mapper的方法加入到mappedStatements中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// https://github.com/baomidou/mybatis-plus/issues/3038</span></span><br><span class="line">            <span class="keyword">if</span> (GlobalConfigUtils.isSupperMapperChildren(configuration, type)) &#123;</span><br><span class="line">              <span class="comment">// 执行该步骤之后，新增了mappestatment</span></span><br><span class="line">                parserInjector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteMethod(<span class="keyword">new</span> <span class="title class_">InjectorResolver</span>(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parserInjector方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">parserInjector</span><span class="params">()</span> &#123;</span><br><span class="line">    GlobalConfigUtils.getSqlInjector(configuration).inspectInject(assistant, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GlobalConfigUtils.getSqlInjector</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ISqlInjector <span class="title function_">getSqlInjector</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getGlobalConfig(configuration).getSqlInjector();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//getSqlInjector()</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ISqlInjector</span> <span class="variable">sqlInjector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlInjector</span>();</span><br><span class="line"><span class="comment">//MybatisPlusAutoConfiguration.sqlSessionFactory#sqlInjector</span></span><br><span class="line"><span class="built_in">this</span>.getBeanThen(ISqlInjector.class, globalConfig::setSqlInjector);</span><br></pre></td></tr></table></figure><p>我们可以看到，通过一连串的方法拿到ISqlInjector实现类。默认是DefaultSqlInjector，但是如果Spring中被手动注入了该实现类的话，就会在自动配置的时候，修改为我们自定义的SqlInjector。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab28d15821f34d3d834ade63a0b01501~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210830230401071.png"></p><p>这里就会转到我们自定义的逻辑了，但是我们这里CustomSqlInjector是extends DefaultSqlInjector的，所以逻辑还是在DefaultSqlInjector里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSqlInjector</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title function_">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Insert</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Delete</span>(),</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    ).collect(toList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractSqlInjector</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; modelClass = extractModelClass(mapperClass);</span><br><span class="line">    <span class="keyword">if</span> (modelClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> mapperClass.toString();</span><br><span class="line">        Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">        <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">          <span class="comment">// 可以看到这里拿取我们CustomSqlInjector返回的AbstractMethod list，然后循环调用inject</span></span><br><span class="line">            List&lt;AbstractMethod&gt; methodList = <span class="built_in">this</span>.getMethodList(mapperClass);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                <span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">                <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(mapperClass.toString() + <span class="string">&quot;, No effective injection method was found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mapperRegistryCache.add(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractMethod</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.configuration = builderAssistant.getConfiguration();</span><br><span class="line">    <span class="built_in">this</span>.builderAssistant = builderAssistant;</span><br><span class="line">    <span class="built_in">this</span>.languageDriver = configuration.getDefaultScriptingLanguageInstance();</span><br><span class="line">    <span class="comment">/* 注入自定义方法 */</span></span><br><span class="line">    injectMappedStatement(mapperClass, modelClass, tableInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就很清楚了，这里面一系列的模板方法模式的类，预留了钩子让子类去实现。</p><p><code>DefaultSqlInjector</code>这个类只是为了提供哪些方法需要被注入到mappedStatements中，这个list将被抽象类<code>AbstractSqlInjector</code>钩子调用。</p><p><code>AbstractSqlInjector</code>主要就是循环<code>getMethodList</code>返回的AbstractMethod组成的List，然后调用inject方法。</p><p><code>AbstractMethod</code>的<code>inject</code>也就是我们自己定义的逻辑。</p><p><code>SaveBatch</code>在构建好一个MappedStatement对象需要的元素后，调用<code>addInsertMappedStatement</code>将插入到Configuration的mappedStatements中。</p><p>分析完毕。</p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>mybatis-plus除了BaseMapper之外，还有一些公共的方法，是放在一个 <code>ServiceImpl</code>的类中的，很多人在service层继承这个类来获取这些功能，我一直很不喜欢这种方式：</p><ul><li>在Service层继承这个东西，感觉像是把Dao的功能迁移到了Service层面了，层次结构有点不舒服（当然实际使用没什么影响）。</li><li>这个ServiceImpl里面很多方法被强制加了是事务注解，我们都无法改变！这个比较糟糕，多数据源的时候这些事务注解会导致数据源切换失败。</li></ul><p>我的想法是这些方法能不能再落到BaseMapper层？经过这次分析发现，确实不太合适：BaseMapper里面的基础方法一般都对应这一条SQL，这条SQL是能被完整构建的。</p><p>但是在ServiceImpl里面的方法，很多其实都是打包多条SQL然后统一提交进行flush操作的，甚至一写比如saveOrUpdate方法都是执行查询，然后处理后再更新或者插入。这些都不是单个SQL能完成的任务，因此mybatis-plus将这些逻辑只能放在ServiceImpl中。</p><p>如果想将这些方法，还是放在BaseMapper中，那么可能就需要去特别的修改MapperProxy代理类了。相较而言，放在ServiceImpl还是不错的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mybatis-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保障缓存和数据库的一致性（超详细案例）</title>
      <link href="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/"/>
      <url>/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>今天给大家分享一道大厂面试的常见题目，高并发下如何保障缓存和数据库的一致性，本文内容源于我在工作中的大量实际项目实践和思考。</p><p>本文内容有视频版本，喜欢看视频的同学可以直接通过下面的二维码观看。如果你对文章的内容有疑惑，有可以先看视频的对应内容，视频可能讲的会更细一点。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>该问题提出之前，面试官可能会先跟你聊一些其他的缓存知识点，然后通过一些场景题逐渐引导到该题目，例如更新数据库成功，删除Redis失败，Redis是脏数据，如何处理？等等之类的。</p><p>接着我们来看现在主流的有哪些方案，最后我会分享我自己的最终方案。</p><h2 id="方案1：同步删除"><a href="#方案1：同步删除" class="headerlink" title="方案1：同步删除"></a><strong>方案1：同步删除</strong></h2><h3 id="核心流程："><a href="#核心流程：" class="headerlink" title="核心流程："></a><strong>核心流程：</strong></h3><ol><li>先更新数据库数据</li><li>然后删除缓存数据</li></ol><h3 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h3><p><strong>1）删除缓存失败存在脏数据</strong></p><p><strong>2）难以收拢所有更新数据库入口</strong></p><p>使用同步删除方案，你必须在所有更新数据库的地方都进行缓存的删除操作，如果你有一个地方漏掉了，对应的缓存就相当于没有删除了，就会导致脏数据问题。</p><p>还有就是如果我们通过命令行直接来更新数据库的数据，或者通过公司提供的数据库管理平台来更新数据库数据，这个时候你就没法删除了，因为你的同步删除其实只是写在你的代码里面，这个时候也就导致脏数据问题了，这也是为什么说同步删除很难覆盖所有的入口，同时存在很大的风险。</p><p><strong>3）并发场景下存在脏数据</strong></p><p>我们看一个例子：</p><p>例子：表A存在数据 a&#x3D;1，并发情况下可能有以下流程：</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-192ff9ff327e6c9cd69ac53d7dbb9357_720w.webp" class title="img"><p>该例子中，由于线程2在查询完数据库数据之后，写入缓存之前，数据库的数据被线程1更新并且执行完同步删除操作了，所以最终导致脏数据问题，并且脏数据可能会持续很久。</p><p>当然，由于更新数据库操作耗时一般比写缓存更久，所以该例子发生的概率并不会太大，但还是有可能的。</p><p>最典型的场景就是，线程2查询完数据库之后，写缓存之前，线程2所在服务器发生了YGC，这个时候线程2可能就需要等待几十毫秒才能执行写缓存操作，这种情况就很容易出现上面这个例子了。</p><p><strong>小结：由于难以收拢所有更新数据库入口，同时可能存在长期的脏数据问题，该方案一般不会被单独使用，但是可以作为一个补充，下面的方案会提到。</strong></p><h2 id="方案2：延迟双删"><a href="#方案2：延迟双删" class="headerlink" title="方案2：延迟双删"></a><strong>方案2：延迟双删</strong></h2><h3 id="核心流程：-1"><a href="#核心流程：-1" class="headerlink" title="核心流程："></a><strong>核心流程：</strong></h3><ol><li>删除缓存数据</li><li>更新数据库数据</li><li>等待一小段时间</li><li>再次删除缓存数据</li></ol><h3 id="存在的问题：-1"><a href="#存在的问题：-1" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h3><p><strong>1）延迟时间难以确认</strong></p><p>到底是延迟一秒或者是几秒，这个其实很难确认，你总不能延迟几分钟吧，因为你如果延迟几分钟，那这几分钟可能就存在脏数据了，所以这个时间很难确定。</p><p><strong>2）无法绝对保障数据的一致性</strong></p><p>我们看下面这个例子：</p><p>例子：表A存在数据 a&#x3D;1，并发情况下可能有以下流程</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-6f5ab13cc2164dc7600fbcbdc9b94c92_720w.webp" class title="img"><p>该例子中，由于数据库主从同步完成之间，存在并发的请求，从而导致脏数据问题，并且脏数据可能会持续很久。</p><p>可能有的同学觉得稍微调大点延迟时间就可以解决这个问题，但是其实主库在写压力比较大的时候，主从之间的同步延迟甚至可能是分钟级的。</p><p>因此，该方案整体来说还是有明显的问题，所以说一般也不会使用这个方案。</p><p><strong>小结：由于延迟时间难以确认，同时无法绝对保障数据的一致性，该方案一般不会使用。</strong></p><h2 id="方案3：异步监听binlog删除-重试"><a href="#方案3：异步监听binlog删除-重试" class="headerlink" title="方案3：异步监听binlog删除 + 重试"></a><strong>方案3：异步监听binlog删除 + 重试</strong></h2><h3 id="核心流程：-2"><a href="#核心流程：-2" class="headerlink" title="核心流程："></a><strong>核心流程：</strong></h3><ol><li>更新数据库</li><li>监听binlog删除缓存</li><li>缓存删除失败则通过MQ不断重试，直至删除成功</li></ol><p>整体流程图如下：</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-bb6f95453ac4ff102e292816d0b956af_720w.webp" class title="img"><p>该方案是当前的主流方案，整体上没太大的问题，但是极端场景下可能还是有一些小问题。</p><h3 id="存在的问题：-2"><a href="#存在的问题：-2" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h3><p><strong>1）脏数据时间窗口“较大”</strong></p><p>这个脏数据时间窗口较大，是相对同步删除来说。在你收到binlog之前，他中间要经过：binlog从主库同步到从库、binlog从库到binlog监听组件、binlog从监听组件发送到MQ、消费MQ消息，这些操作每个都是有一定的耗时的，可能是几十毫秒甚至几百毫秒，所以说它其实整体是有一个脏数据的时间窗口。</p><p>而同步删除是在更新完数据库后马上删除，时间窗口大概也就是1毫秒左右，所以说binlog的方式相对于同步删除，可能存在的脏数据窗口会稍微大一点。</p><p><strong>2）极端场景下存在长期脏数据问题</strong></p><ul><li>binlog抓取组件宕机导致脏数据。该方案强依赖于监听binlog的组件，如果监听binlog组件出现宕机，则会导致大量脏数据。</li><li>拆库拆表流程中可能存在并发脏数据</li></ul><p><strong>拆库拆表流程中并发脏数据问题</strong></p><p>我们来看下面这个例子：</p><p>表A正在进行数据库拆分，当前进行到灰度切读流量阶段：部分读新库，部分读老库</p><p>数据库拆分大致流程：增量数据同步（双写）、全量数据迁移、数据一致性校验、灰度切读、切读完毕后停写老库。</p><p>此时表A存在数据 a&#x3D;1，并发情况下可能有以下流程</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-d032690f6a50cd0993eade0268429281_720w.webp" class title="img"><p>该例子中，灰度切读阶段中，我们还是优先保障老库的流程，因此还是先写老库，由于写新库和写老库之间存在时间间隔，导致线程2并发查询到新库的老数据，同时在监听binlog删除缓存流程之后将老数据写入缓存，从而导致脏数据问题，并且脏数据可能会持续很久。</p><p>双写的方式有很多种，我们使用的是通过公司的中间件直接将老库数据通过binlog的方式同步到新库，该方案通过监控发现在写压力较大的情况下，延迟可能会达到几秒，因此出现了上述问题。</p><p>而如果是使用代码进行同步双写，双写之间的时间间隔会较小，该问题出现的概率会相对低很多，但是还是无法保障绝对不会出现，就像上面提过的，写老库和写新库2个操作之间如果发生了YGC或者FGC，就可能导致这两个操作之间的时间间隔比较大，从而可能发生上面的案例。</p><p>还有就是代码双写的方式必须收敛所有的写入口，上文提到过的，通过命令行或者数据库管理平台的方式修改的数据，代码双写也是无法覆盖的，需要执行者在新老库都执行一遍，如果遗漏了新库，则可能导致数据问题。</p><p><strong>小结：该方案在大多数场景下没有太大问题，业务比较小的场景可以使用，或者在其基础上进行适当补充。</strong></p><h2 id="最终方案：缓存三重删除-数据一致性校验-更新流程禁用缓存-强制读Redis主节点"><a href="#最终方案：缓存三重删除-数据一致性校验-更新流程禁用缓存-强制读Redis主节点" class="headerlink" title="最终方案：缓存三重删除 + 数据一致性校验 + 更新流程禁用缓存 + 强制读Redis主节点"></a><strong>最终方案：缓存三重删除 + 数据一致性校验 + 更新流程禁用缓存 + 强制读Redis主节点</strong></h2><p>这个方案也是我现在在我们项目中里面使用的方案，这里面有很多很多的思考，踩了各种坑之后不断优化而来的方案。该方案整体以方案3作为主体，然后增加了各种优化。</p><h3 id="整体方案如下："><a href="#整体方案如下：" class="headerlink" title="整体方案如下："></a><strong>整体方案如下：</strong></h3><ul><li><p>更新数据库同步删除缓存</p></li><li><p>监听数据库的binlog异步删除缓存：带重试，保障一定会最终删除成功</p></li><li><p>缓存数据带过期时间，过期后自动删除，越近更新的数据过期时间越短</p></li><li><ul><li>主要用于进一步防止并发下的脏数据问题</li><li>解决一些由于未知情况，导致需要更换缓存结构的问题</li></ul></li><li><p>监听数据库的binlog延迟N秒后进行数据一致性校验</p></li><li><ul><li>解决一些极端场景下的脏数据问题</li></ul></li><li><p>存在数据库更新的链路禁用对应缓存</p></li><li><ul><li>防止并发下短期内的脏数据影响到更新流程</li></ul></li><li><p>强制读Redis主节点</p></li><li><p>查询异步数据一致性校验、灰度放量</p></li></ul><p><strong>整体流程图</strong></p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-763c24d16aaf83bfa3725b33bf4fd1f4_720w.webp" class title="img"><p>下面我们来细说各个方案点的设计初衷。</p><p><strong>1）更新数据库后同步删除缓存</strong></p><p>这个同步删除缓存其实是为了解决我们上面说的那个异步binlog删除不一致时间窗口比较大的问题。更新完数据之后，我们马上进行一次同步删除，不一致的时间窗口非常小。</p><p><strong>2）监听数据库的binlog异步删除缓存</strong></p><p>该步骤是整个方案的核心，也就是方案3，因为binlog理论上是绝对不会丢的，他不像同步删除存在无法收敛入口的问题。因此，我们会保障该步骤一定能删除成功，如果出现失败，则通过MQ不断重试。</p><p>通过前面两个方案点，我们其实已经保障了绝大多数场景下数据是正确的。</p><p><strong>3）缓存数据带过期时间，过期后自动删除，越近更新的数据过期时间越短</strong></p><p>该策略的设计初衷是因为我们前面讲的那些并发问题其实都是在存在并发更新跟一些并发查询的场景下出现的，因此最近刚刚更新过的数据，他出现不一致的概率相对于那种很久没更新过的数据来说会大很多。</p><p>例如最近一个小时内更新的数据，我可能给他设计的过期时间很短，当然这个过期时间很多是相对于其他数据而言，绝对时间还是比较长的，例如我们使用的是一个小时。</p><p>这边是因为我们整体的请求量和数据量太大，如果使用的过期时间太短，会导致写缓存流量特别大，导致缓存集群压力很大。</p><p>因此，如果使用该策略，建议过期时间一开始可以设置大一点，然后逐渐往下调，同时观察缓存集群的压力情况。</p><p>该方案可以进一步保证我们数据的一个最终一致性。</p><p>同时带过期时间可以解决另一个问题，如果你在缓存上线后发现缓存数据结构设计不合理，你想把该缓存替换掉。如果该缓存有过期时间，你不需要处理存量数据，让他到期自动删除就行了。如果该缓存没有过期时间，则你需要将存量数据进行删除，不然可能会占用大量空间。</p><p><strong>4）监听数据库的binlog延迟N秒后进行数据一致性校验</strong></p><p>这个操作也是非常关键，方案3存在的问题就可以通过这个操作来解决掉。就如上面提过的，脏数据都是在更新操作之后的很短时间内触发的。</p><p>因此，我们对每一个更新操作，都在延迟一段时间后去校验其缓存数据是否正确，如果不正确，则进行修复，这样就保障了绝大多数并发导致的脏数据问题。</p><p>至于延迟多久，我个人建议是延迟几分钟，不能延迟太短，否则起不到兜底的效果。</p><p><strong>5）存在数据库更新的链路禁用对应缓存</strong></p><p>在数据库更新的场景里面，我们可能会有一些查询操作。例如我更新完这个数据之后，我马上又查了一下。这个时候其实如果你去走缓存，很有可能是会存在脏数据。因为他更新完之后，马上读取这个间隔是非常短的。你的缓存其实可能还没有删除完，或者存在短期内的不一致，我们还没有修复。</p><p>但是这种更新场景他对数据的一致性要求一般是比较高的。因为更新完之后，他要拿这个查询出来的数据去做一些其他操作。例如记录数据变更的操作日志。</p><p>我把一个数据从a&#x3D;1改成a&#x3D;2，我在更新之前，我先查出来a&#x3D;1，更新完之后我立马就去查出来a&#x3D;2，这个时候我就记录一条操作日志，内容是a从1变成2。</p><p>这种情况下，如果你在更新完之后的这个查询去走缓存，就有很大的概率查到a&#x3D;1，这时候你的操作日志就变成a从1变成1，导致操作日志是错的。</p><p>所以说这种更新后的查询，我们一般会让他不走缓存，因为他这个时效性就是太快了，缓存流程可能还没处理完成。</p><p>这个方案点其实是借鉴了MySQL事务的设计思想，MySQL中，事务对于自己更新过的内容都是实时可见的。因此，我们这边也做了一个类似的设计。</p><p><strong>6）强制读Redis主节点</strong></p><p>Redis跟MySQL一样，也会有主从副本，也会有主从延迟。当你将数据写入Redis后，马上去查Redis，可能由于查询从副本，导致读取到的是老数据，因此我们可以通过直接强制读主节点来解决这个问题，进一步增加数据的准确性。</p><p>Redis 不像 MySQL 有主节点压力过大的问题，Redis 是分布式的，可以将16384个槽分摊到多个分片上，每个分片的主节点部署在不同的机器上，这样强制读主时，流量也会分摊到多个机器上，不会存在MySQL的单节点压力过大问题。</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%A1%88%E4%BE%8B%EF%BC%89/v2-02aad86db8c81c74b9d08764d0436191_720w.webp" class title="img"><p><strong>7）查询异步数据一致性校验、灰度放量</strong></p><p>这一步是缓存功能使用前的一些保障措施，保障缓存数据是准确的。</p><p>对于查询异步数据一致性校验，我们一般在查询完数据库之后，通过线程池异步的再查询一次缓存，然后把这个缓存的数据跟刚才数据库查出来的数据进行比较，然后将结果进行打点统计。</p><p>然后查看数据一致性校验的一致率有多少，如果不一致的概率超过了1%，那可能说明我们的流程还是有问题，我们需要分析不一致的例子，找出原因，进行优化。</p><p>如果不一致的概率低于0.01%，那说明整个流程可能基本上已经没啥问题了。这边理论上一定会存在一些不一致的数据，因为我们查询数据库和缓存之间还是有一定的时间间隔的，可能是1毫秒这样，在高并发下，可能这个间隔之间数据已经被修改过了，所以你拿到的缓存数据和数据库数据可能其实不是一个版本，这种情况下的不一致是正常的。</p><p>对于灰度放量，其实就是保护我们自己的一个措施。因为缓存流程毕竟还没经过线上的验证，我们一下全切到缓存，如果万一有问题，那可能就导致大量问题，从而可能导致线上事故。</p><p>如果我们一开始只是使用几个门店来进行灰度，如果有问题，影响其实很小，可能是一个简单的事件，对我们基本没影响。</p><p>在有类似比较大的改造时，通过灰度放量的方式来逐渐上线，是一种比较安全的措施，也是比较规范的措施。</p><p><strong>小结：该方案的链路确实比较长，但是高并发下确实会有很多问题，因此我们需要有很多措施去保障。当然，这个方案也不是一下子就是这样的，也是通过不断的实践和采坑才逐渐演进而来的。目前该方案在我们线上环境使用了挺长一段时间了，基本没有什么问题，整体还是比较完善的。</strong></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>缓存和数据库一致性保障方案，目前网上的资料大多是类似于方案3，如果你能在面试中说出我给的这个方案，相信可以让面试官眼前一亮，这其实就是你的加分项，可以帮助你从众多候选人之中脱颖而出。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mysql </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证 redis 的高并发和高可用？</title>
      <link href="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/"/>
      <url>/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>如果你用 <a href="https://cloud.tencent.com/product/crs?from=20065&from_column=20065">redis</a> 缓存技术的话，肯定要考虑如何用 redis 来加多台机器，保证 redis 是高并发的，还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，即 redis 高可用。</p><p>由于此节内容较多，因此，会分为两个小节进行讲解。</p><ul><li>redis 主从架构</li><li>redis 基于哨兵实现高可用</li></ul><p>Redis 主从架构</p><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/j5hcino47d.png" class title="img"><p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p><h2 id="redis-replication-的核心机制"><a href="#redis-replication-的核心机制" class="headerlink" title="redis replication 的核心机制"></a>redis replication 的核心机制</h2><ul><li>redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li></ul><p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p><p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p><h2 id="redis-主从复制的核心原理"><a href="#redis-主从复制的核心原理" class="headerlink" title="redis 主从复制的核心原理"></a>redis 主从复制的核心原理</h2><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/j1tiqlu8f3.png" class title="img"><h3 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h3><p>从 redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p><p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code>。</p><blockquote><p>如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。</p></blockquote><h3 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h3><p>master 在内存中直接创建 <code>RDB</code>，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync yes</span><br><span class="line"># 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span><br><span class="line">repl-diskless-sync-delay <span class="number">5</span></span><br></pre></td></tr></table></figure><p>复制</p><h3 id="过期-key-处理"><a href="#过期-key-处理" class="headerlink" title="过期 key 处理"></a>过期 key 处理</h3><p>slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</p><h2 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a>复制的完整流程</h2><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的<code>host</code>和<code>ip</code>，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node 第一次执行全量复制，将所有数据发给slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/vhgsx88g20.png" class title="img"><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ul><li>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</li><li>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</li><li>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</li><li>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB <span class="number">60</span></span><br></pre></td></tr></table></figure><p>复制</p><ul><li>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时基于旧的数据版本对外提供服务。</li><li>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。</li></ul><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><ul><li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</li><li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是1MB。</li><li>msater就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</li></ul><h3 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h3><p>主从节点互相都会发送 heartbeat 信息。</p><p>master 默认每隔 10秒 发送一次 heartbeat，slave node 每隔 1秒 发送一个 heartbeat。</p><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。</p><h2 id="redis-如何才能做到高可用"><a href="#redis-如何才能做到高可用" class="headerlink" title="redis 如何才能做到高可用"></a>redis 如何才能做到高可用</h2><p>如果系统在 365 天内，有 99.99% 的时间，都是可以哗哗对外提供服务的，那么就说系统是高可用的。</p><p>一个 slave 挂掉了，是不会影响可用性的，还有其它的 slave 在提供相同数据下的相同的对外的查询服务。</p><p>但是，如果 master node 死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node 还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了。</p><p>redis 的高可用架构，叫做 <code>failover</code> 故障转移，也可以叫做主备切换。</p><p>master node 在故障时，自动检测，并且将某个 slave node 自动切换位 master node的过程，叫做主备切换。这个过程，实现了 redis 的主从架构下的高可用。</p><p>后面会详细说明 redis 基于哨兵的高可用性。</p><p>redis 实现高并发主要依靠主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。</p><p>如果想要在实现高并发的同时，容纳大量的数据，那么就需要 redis 集群，使用 redis 集群之后，可以提供每秒几十万的读写并发。</p><p>redis 高可用，如果是做主从架构部署，那么加上哨兵就可以了，就可以实现，任何一个实例宕机，可以进行主备切换。</p><h2 id="Redis基于哨兵模式实现高可用"><a href="#Redis基于哨兵模式实现高可用" class="headerlink" title="Redis基于哨兵模式实现高可用"></a>Redis基于哨兵模式实现高可用</h2><p>在开始本章的讲解之前，我们首先从宏观角度回顾一下 <a href="https://cloud.tencent.com/product/crs?from=20065&from_column=20065">Redis</a> 实现高可用相关的技术。它们包括：持久化、复制、哨兵和集群，在本系列的前篇文章介绍了持久化以及复制的原理以及实现。本文将对剩下的两种高可用技术哨兵、集群进行讲解，讲一讲它们是如何进一步提高系统的高可用性？</p><p>Redis 的主从复制模式下，一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点，同时还要通知客户端更新主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制来解决这个问题。</p><p>在 Redis 3.0 之前，使用哨兵（sentinel）机制来监控各个节点之间的状态。Redis Cluster 是 Redis 的分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 在分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用 Cluster 架构方案达到<a href="https://cloud.tencent.com/product/clb?from=20065&from_column=20065">负载均衡</a>的目的。</p><h2 id="Redis-HA-实践（Redis-Sentinel）"><a href="#Redis-HA-实践（Redis-Sentinel）" class="headerlink" title="Redis HA 实践（Redis Sentinel）"></a><strong>Redis HA 实践（Redis Sentinel）</strong></h2><h3 id="Redis-Sentinel-概述"><a href="#Redis-Sentinel-概述" class="headerlink" title="Redis Sentinel 概述"></a><strong>Redis Sentinel 概述</strong></h3><p>Sentinel（哨岗、哨兵）是 Redis 的高可用（high availability）解决方案：由一个或多个 Sentinel 实例（instance）组成的 Sentinel 系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/dy25zd7xc0.png" class title="img"><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/uo069eiopx.png" class title="img"><p>当 server1 的下线时长超过用户设定的下线时长上限时，Sentinel 系统就会对 server1 执行故障转移操作：</p><ul><li>首先，Sentinel 系统会挑选 server1 属下的其中一个从服务器，并将这个被选中的从服务升级为新的主服务器。</li><li>之后，Sentinel 系统会向 server1 属下的所有从服务器发送新的复制指令，让他们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li><li>另外，Sentinel 还会继续监视已下线的 server1，并在它重新上线时，将它设置为新的主服务器的从服务器。</li></ul><p>Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li>监控（Monitoring）：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒（Notification）：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><h3 id="Redis-Sentinel-重点总结"><a href="#Redis-Sentinel-重点总结" class="headerlink" title="Redis Sentinel 重点总结"></a><strong>Redis Sentinel 重点总结</strong></h3><ul><li>Sentinel 只是一个运行在特殊模式下的 Redis 服务器，因此初始化服务器时将普通 Redis 服务器使用的代码替换成 Sentinel 专门代码，它使用了和普通模式不同的命令表，所以 Sentinel 模式能够使用的命令和普通 Redis 服务器能够使用的命令不同。</li><li>Sentinel 会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，其中命令连接用于向主服务器发送命令请求，而订阅连接则用于接收指定频道的消息。</li><li>Sentinel 通过主服务器发送 INFO 命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。在一般情况下，Sentinel 以每十秒一次的频率向被监视的主服务器和从服务器发送 INFO 命令，当主服务器处于下线状态，或者 Sentinel 正在对主服务器进行故障转移操作时，Sentinel 向从服务器发送 INFO 命令的频率会改为每秒一次。</li><li>对于监视同一个主服务器和从服务器的多个 Sentinel 来说，它们会以每两秒一次的频率，通过向被监视服务器的 <em>sentinel</em>:hello 频道发送消息来向其他 Sentinel 宣告自己的存在。每个 Sentinel 也会从 <em>sentinel</em>:hello 频道中接收其他 Sentinel 发来的消息，并根据这些消息为其他 Sentinel 创建相应的实例结构以及命令连接。Sentinel 只会与主服务器和从服务器创建命令连接和订阅连接，Sentinel 与 Sentinel 之间则只创建命令连接。</li><li>Sentinel 以每秒一次的频率向实例（包括主服务器、从服务器、其他 Sentinel）发送 PING 命令，并根据实例对 PING 命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向 Sentinel 发送无效回复时，Sentinel 会将这个实例判断为主观下线。</li><li>当 Sentinel 将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其它 Sentinel 进行询问，看它们是否同意这个主服务器已经进入主观下线状态。当 Sentinel 收集到足够多的的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。</li><li>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel[1]，并由领头 Sentinel 对下线主服务器进行故障转移操作。</li></ul><h3 id="Redis-Sentinel-搭建"><a href="#Redis-Sentinel-搭建" class="headerlink" title="Redis Sentinel 搭建"></a><strong>Redis Sentinel 搭建</strong></h3><h4 id="Redis-Sentinel-部署技巧及其环境"><a href="#Redis-Sentinel-部署技巧及其环境" class="headerlink" title="Redis Sentinel 部署技巧及其环境"></a><strong>Redis Sentinel 部署技巧及其环境</strong></h4><ul><li>一个健壮的部署至少需要三个哨兵实例，并且使用奇数个 Sentinel。</li><li>三个哨兵实例应该放置在客户使用独立方式确认故障的计算机或虚拟机中，例如不同的物理机或不同可用区域的虚拟机。</li><li>哨兵配置文件中只需要配置主从复制中的主副本 ip 和端口即可，当主从进行切换时哨兵会自动修改哨兵配置文件中的主副本 ip 为新在主副本 ip。</li></ul><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/49c37tz8j9.png" class title="img"><p>由于本人没有这么多服务器，因此在一台机器上模拟一个 Redis Sentinel 集群。</p><table><thead><tr><th align="left">角色</th><th align="left">IP 地址</th><th align="left">端口号</th></tr></thead><tbody><tr><td align="left">Redis Master</td><td align="left">127.0.0.1</td><td align="left">6380</td></tr><tr><td align="left">Redis Slave-01</td><td align="left">127.0.0.1</td><td align="left">6381</td></tr><tr><td align="left">Redis Slave-02</td><td align="left">127.0.0.1</td><td align="left">6382</td></tr><tr><td align="left">Redis Slave-03</td><td align="left">127.0.0.1</td><td align="left">6383</td></tr><tr><td align="left">Redis Sentinel-01</td><td align="left">127.0.0.1</td><td align="left">26381</td></tr><tr><td align="left">Redis Sentinel-02</td><td align="left">127.0.0.1</td><td align="left">26382</td></tr><tr><td align="left">Redis Sentinel-03</td><td align="left">127.0.0.1</td><td align="left">26383</td></tr></tbody></table><h4 id="Redis-Sentinel-安装指南"><a href="#Redis-Sentinel-安装指南" class="headerlink" title="Redis Sentinel 安装指南"></a><strong>Redis Sentinel 安装指南</strong></h4><p>1、下载 Redis 服务软件包到服务器，解压后并编译安装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# mkdir /usr/local/redis</span><br><span class="line">[root@VM_24_98_centos ~]# wget <span class="attr">http</span>:<span class="comment">//download.redis.io/releases/redis-5.0.6.tar.gz</span></span><br><span class="line">[root@VM_24_98_centos ~]# tar -zvxf redis-<span class="number">5.0</span><span class="number">.6</span>.<span class="property">tar</span>.<span class="property">gz</span> -C /usr/local/redis</span><br><span class="line">[root@VM_24_98_centos ~]# cd /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/</span><br><span class="line">[root@VM_24_98_centos redis-<span class="number">5.0</span><span class="number">.6</span>]# make <span class="variable constant_">PREFIX</span>=<span class="regexp">/usr/</span>local/redis install</span><br></pre></td></tr></table></figure><p>复制</p><p>2、设置 Redis 主服务器</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/local/redis/redis-master/redis-<span class="number">6380</span></span><br><span class="line">[root@VM_24_98_centos redis-master]# cp -r /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/redis.<span class="property">conf</span> /usr/local/redis/redis-master/redis-<span class="number">6380</span>/</span><br><span class="line">[root@VM_24_98_centos redis-master]# vim /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">conf</span></span><br></pre></td></tr></table></figure><p>复制</p><p>b. 设置 Redis Master 主服务器配置环境</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 开启远程连接</span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"># 端口号</span><br><span class="line">port <span class="number">6380</span></span><br><span class="line"># 守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 进程文件</span><br><span class="line">pidfile /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">pid</span></span><br><span class="line"># 日志文件</span><br><span class="line">logfile /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">log</span></span><br><span class="line"># 工作目录</span><br><span class="line">dir /usr/local/redis/redis-master/redis-<span class="number">6380</span>/</span><br><span class="line"># 主服务器密码</span><br><span class="line">masterauth foobared</span><br><span class="line"># 认证密码</span><br><span class="line">requirepass foobared</span><br><span class="line"># 开启 <span class="variable constant_">AOF</span> 持久化</span><br><span class="line">appendonly yes</span><br><span class="line"># 每秒调用一次 fsync</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><p>复制</p><p>c. 启动 Redis Master 主服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis-<span class="number">6380</span>]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">conf</span></span><br><span class="line">[root@VM_24_98_centos redis-<span class="number">6380</span>]# ps -ef |grep redis</span><br></pre></td></tr></table></figure><p>复制</p><p>d. 客户端测试连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6380</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">REPLICATION</span></span><br><span class="line"># <span class="title class_">Replication</span></span><br><span class="line"><span class="attr">role</span>:master</span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">master_replid</span>:5c1034ac4dec31d6a4ae883e1eaacca3a78bc3b6</span><br><span class="line"><span class="attr">master_replid2</span>:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:-<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="number">1048576</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure><p>复制</p><p>3、设置 Redis 从服务器</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/local/redis/redis-slave/redis-<span class="number">6381</span></span><br><span class="line">[root@VM_24_98_centos redis-slave]# cp -r /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/redis.<span class="property">conf</span> /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/</span><br><span class="line">[root@VM_24_98_centos redis-slave]# vim /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/redis.<span class="property">conf</span></span><br></pre></td></tr></table></figure><p>复制</p><p>b. 设置 Redis Slave 从服务器配置环境</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 开启远程连接</span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"># 端口号</span><br><span class="line">port <span class="number">6381</span></span><br><span class="line"># 守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 进程文件</span><br><span class="line">pidfile /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/redis.<span class="property">pid</span></span><br><span class="line"># 日志文件</span><br><span class="line">logfile /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/redis.<span class="property">log</span></span><br><span class="line"># 工作目录</span><br><span class="line">dir /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/</span><br><span class="line"># 主从复制 <span class="title class_">Master</span> 节点地址 + 端口</span><br><span class="line">replicaof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6380</span></span><br><span class="line"># 主服务器密码</span><br><span class="line">masterauth foobared</span><br><span class="line"># 认证密码</span><br><span class="line">requirepass foobared</span><br><span class="line"># 开启 <span class="variable constant_">AOF</span> 持久化</span><br><span class="line">appendonly yes</span><br><span class="line"># 每秒调用一次 fsync</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><p>复制</p><p>c. 启动 Redis Slave 从服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis-<span class="number">6381</span>]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/redis.<span class="property">conf</span></span><br><span class="line">[root@VM_24_98_centos redis-<span class="number">6381</span>]# ps -ef |grep redis</span><br></pre></td></tr></table></figure><p>复制</p><p>d. 客户端测试连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-slave/redis-<span class="number">6381</span>/redis.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6381</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6381</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">REPLICATION</span></span><br><span class="line"># <span class="title class_">Replication</span></span><br><span class="line"><span class="attr">role</span>:slave</span><br><span class="line"><span class="attr">master_host</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">master_port</span>:<span class="number">6380</span></span><br><span class="line"><span class="attr">master_link_status</span>:up</span><br><span class="line"><span class="attr">master_last_io_seconds_ago</span>:<span class="number">5</span></span><br><span class="line"><span class="attr">master_sync_in_progress</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">slave_repl_offset</span>:<span class="number">14</span></span><br><span class="line"><span class="attr">slave_priority</span>:<span class="number">100</span></span><br><span class="line"><span class="attr">slave_read_only</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">master_replid</span>:8ecb8d89dba51e54aabb1c7feeda42fe6e6a8dc0</span><br><span class="line"><span class="attr">master_replid2</span>:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="number">14</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:-<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="number">1048576</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="number">14</span></span><br></pre></td></tr></table></figure><p>复制</p><p>e. 同理，从服务器 redis-6382、redis-6383 按照上面的步骤部署。</p><p>4、Redis Sentinel 部署</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span></span><br><span class="line">[root@VM_24_98_centos redis-sentinel]# cp -r /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/sentinel.<span class="property">conf</span> /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/</span><br><span class="line">[root@VM_24_98_centos redis-sentinel]# vim /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/sentinel.<span class="property">conf</span></span><br></pre></td></tr></table></figure><p>复制</p><p>b. 设置 Redis Sentinel 哨兵服务器配置环境</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 端口号</span><br><span class="line">port <span class="number">26381</span></span><br><span class="line"># 守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 进程文件</span><br><span class="line">pidfile /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/redis.<span class="property">pid</span></span><br><span class="line"># 日志文件</span><br><span class="line">logfile /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/redis.<span class="property">log</span></span><br><span class="line"># 工作目录</span><br><span class="line">dir /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/</span><br><span class="line"># 指定监控 master&#123;<span class="number">2</span> 表示多少个 sentinel 同意&#125;</span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6380</span> <span class="number">2</span></span><br><span class="line"># 安全信息</span><br><span class="line">sentinel auth-pass mymaster foobared</span><br></pre></td></tr></table></figure><p>复制</p><p>c. 启动 Redis Sentinel 哨兵服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis-<span class="number">26381</span>]# /usr/local/redis/bin/redis-sentinel /usr/local/redis/redis-sentinel/redis-<span class="number">26381</span>/sentinel.<span class="property">conf</span></span><br><span class="line">[root@VM_24_98_centos redis-<span class="number">26381</span>]# ps -ef |grep redis</span><br></pre></td></tr></table></figure><p>复制</p><p>d. 客户端测试连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">26381</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">26381</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">SENTINEL</span></span><br><span class="line"># <span class="title class_">Sentinel</span></span><br><span class="line"><span class="attr">sentinel_masters</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">sentinel_tilt</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_running_scripts</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_scripts_queue_length</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_simulate_failure_flags</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">master0</span>:name=mymaster,status=ok,address=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>,slaves=<span class="number">3</span>,sentinels=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>复制</p><p>e. 同理，哨兵服务器 redis-26382、redis-26383 按照上面的步骤部署</p><p>f. 查看 Redis Master 主服务器连接状况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6380</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">REPLICATION</span></span><br><span class="line"># <span class="title class_">Replication</span></span><br><span class="line"><span class="attr">role</span>:master</span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="number">3</span></span><br><span class="line"><span class="attr">slave0</span>:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">6383</span>,state=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line"><span class="attr">slave1</span>:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">6381</span>,state=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line"><span class="attr">slave2</span>:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">6382</span>,state=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line"><span class="attr">master_replid</span>:cc8ef3fe2e51a714f5b73b2fbe3bd697cacbc453</span><br><span class="line"><span class="attr">master_replid2</span>:8ecb8d89dba51e54aabb1c7feeda42fe6e6a8dc0</span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="number">20836</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:<span class="number">1522</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="number">1048576</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="number">20836</span></span><br></pre></td></tr></table></figure><p>复制</p><h3 id="Redis-Sentinel-场景测试"><a href="#Redis-Sentinel-场景测试" class="headerlink" title="Redis Sentinel 场景测试"></a><strong>Redis Sentinel 场景测试</strong></h3><p>模拟场景：Redis Master 节点挂掉，查看 Redis 集群状态。</p><p>Step1、关掉 Master 节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6380</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; <span class="variable constant_">SHUTDOWN</span></span><br></pre></td></tr></table></figure><p>复制</p><p>Step2、通过哨兵查看集群状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">26381</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">26381</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">SENTINEL</span></span><br><span class="line"># <span class="title class_">Sentinel</span></span><br><span class="line"><span class="attr">sentinel_masters</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">sentinel_tilt</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_running_scripts</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_scripts_queue_length</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">sentinel_simulate_failure_flags</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">master0</span>:name=mymaster,status=ok,address=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6381</span>,slaves=<span class="number">3</span>,sentinels=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>复制</p><p>通过 Sentinel 信息可以看到，Master 节点已经自动切换到 6381 端口了，说明主节点挂掉后，6381 Slave 节点自动升级成为了 Master 节点。</p><p>通过 Sentinel 日志文件显示了 failover 的过程：</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/it3cdc8xvp.png" class title="img"><p>Step3、启动 6380 Redis 服务，然后查看节点角色，此时 6380 变成了 Slave，6381 为 Master 节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-<span class="number">6380</span>/redis.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6380</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; <span class="variable constant_">INFO</span> <span class="variable constant_">REPLICATION</span></span><br><span class="line"># <span class="title class_">Replication</span></span><br><span class="line"><span class="attr">role</span>:slave</span><br><span class="line"><span class="attr">master_host</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">master_port</span>:<span class="number">6381</span></span><br><span class="line"><span class="attr">master_link_status</span>:up</span><br><span class="line"><span class="attr">master_last_io_seconds_ago</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">master_sync_in_progress</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">slave_repl_offset</span>:<span class="number">782228</span></span><br><span class="line"><span class="attr">slave_priority</span>:<span class="number">100</span></span><br><span class="line"><span class="attr">slave_read_only</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">master_replid</span>:84aa69ee0b191bba31162c26c4ddb1c87a705f7e</span><br><span class="line"><span class="attr">master_replid2</span>:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="number">782228</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:-<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="number">1048576</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="number">777789</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="number">4440</span></span><br></pre></td></tr></table></figure><p>复制</p><h2 id="Redis-HA-实践（Redis-Cluster）"><a href="#Redis-HA-实践（Redis-Cluster）" class="headerlink" title="Redis HA 实践（Redis Cluster）"></a><strong>Redis HA 实践（Redis Cluster）</strong></h2><h3 id="Redis-Cluster-概述"><a href="#Redis-Cluster-概述" class="headerlink" title="Redis Cluster 概述"></a><strong>Redis Cluster 概述</strong></h3><p>Redis 集群是 Redis 提供的分布式<a href="https://cloud.tencent.com/solution/database?from=20065&from_column=20065">数据库</a>方案，集群通过分片（sharding）而非一致性哈希（consistency hashing）来进行数据分享，并提供复制和故障转移功能。Redis Cluster，主要是针对海量数据 + 高并发 + 高可用的场景。Redis Cluster 支撑 N 个 Redis Master Node，每个 Master Node 都可以挂载多个 Slave Node。Redis Cluster 节点间采用 Gossip 协议[2]进行通信。</p><p>节点：一个 Redis 集群通常由多个节点（node）组成，连接各个节点的工作可以使用 CLUSTER MEET <ip> <port> 命令来完成，将各个独立的节点连接起来，构成一个包含多个节点的集群。向一个节点 node 发送 CLUSTER MEET 命令，可以让 node 节点与 ip 和 port 所指定的节点进行握手（handshake），当握手成功时，node 节点就会将 ip 和 port 所指定的节点添加到 node 节点当前所在的集群中。</port></ip></p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/7eyyyn1obp.png" class title="img"><p><strong>槽指派</strong>：Redis 集群通过分片的方式来保存数据库中的键值对，集群的整数据库被分为 16384 个槽（slot），数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。Redis 集群有固定的 16384 个 hash slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/808e3izvdh.png" class title="img"><h3 id="Redis-Cluster-重点总结"><a href="#Redis-Cluster-重点总结" class="headerlink" title="Redis Cluster 重点总结"></a><strong>Redis Cluster 重点总结</strong></h3><ul><li>节点通过握手来将其他节点添加到自己所处的集群当中。</li><li>集群中的 16384（2的14次方）个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给其他节点。</li><li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</li><li>对 Redis 集群的重新分片工作是由 redis-trib 负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另外一个节点。重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</li><li>如果节点 A 正在迁移槽 i 至节点 B，那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时，节点 A 会向客户端返回一个 ASK 错误，指引客户端到节点 B 继续查找指定的数据库键。</li><li>MOVED 错误表示槽的负责权已经从一个节点转移到了另外一个节点，而 ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。</li><li>Redis 集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</li><li>集群中的节点通过发送和接收消息来进行通信，常见的消息包括 MEET、PING、PONG、PUBLISH、FAIL 五种。</li></ul><h3 id="Redis-Cluster-与-Redis-Sentinel-区别"><a href="#Redis-Cluster-与-Redis-Sentinel-区别" class="headerlink" title="Redis Cluster 与 Redis Sentinel 区别"></a><strong>Redis Cluster 与 Redis Sentinel 区别</strong></h3><ul><li>哨兵模式监控权交给了哨兵系统，集群模式中是工作节点自己做监控。</li><li>哨兵模式发起选举是选举一个 leader 哨兵节点来处理故障转移，集群模式是在从节点中选举一个新的主节点，来处理故障的转移。</li></ul><h3 id="Redis-Cluster-搭建"><a href="#Redis-Cluster-搭建" class="headerlink" title="Redis Cluster 搭建"></a><strong>Redis Cluster 搭建</strong></h3><h4 id="Redis-Cluster-部署技巧及其环境"><a href="#Redis-Cluster-部署技巧及其环境" class="headerlink" title="Redis Cluster 部署技巧及其环境"></a><strong>Redis Cluster 部署技巧及其环境</strong></h4><ul><li>Redis 集群至少需要 3 个节点，因为投票容错机制要求超过半数节点认为某个节点挂了该节点才是挂了，所以 2 个节点无法构成集群。</li><li>要保证集群的高可用，需要每个节点都有从节点，也就是备份节点，即三主三从，所以 Redis 集群至少需要 6 台服务器。</li><li>Redis 5.0 开始不再使用 Ruby 搭建集群，而是直接使用客户端命令 redis-cli 来创建。</li><li>不支持多数据库空间，集群模式下只能使用 db0 空间。</li></ul><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/k8zcq5yvs2.png" class title="img"><p>由于资源有限，因此在一台机器上模拟一个 Redis Cluster。</p><table><thead><tr><th align="left">角色</th><th align="left">IP 地址</th><th align="left">端口号</th></tr></thead><tbody><tr><td align="left">Redis Cluster-Master-01-6391</td><td align="left">127.0.0.1</td><td align="left">6391</td></tr><tr><td align="left">Redis Cluster-Master-02-6393</td><td align="left">127.0.0.1</td><td align="left">6393</td></tr><tr><td align="left">Redis Cluster-Master-02-6395</td><td align="left">127.0.0.1</td><td align="left">6395</td></tr><tr><td align="left">Redis Cluster-Slave-01-6394</td><td align="left">127.0.0.1</td><td align="left">6394</td></tr><tr><td align="left">Redis Cluster-Slave-02-6396</td><td align="left">127.0.0.1</td><td align="left">6396</td></tr><tr><td align="left">Redis Cluster-Slave-03-6392</td><td align="left">127.0.0.1</td><td align="left">6392</td></tr></tbody></table><h4 id="Redis-Cluster-安装指南"><a href="#Redis-Cluster-安装指南" class="headerlink" title="Redis Cluster 安装指南"></a><strong>Redis Cluster 安装指南</strong></h4><p>1、下载 Redis 服务软件包到服务器，解压后并编译安装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# mkdir /usr/local/redis</span><br><span class="line">[root@VM_24_98_centos ~]# wget <span class="attr">http</span>:<span class="comment">//download.redis.io/releases/redis-5.0.6.tar.gz</span></span><br><span class="line">[root@VM_24_98_centos ~]# tar -zvxf redis-<span class="number">5.0</span><span class="number">.6</span>.<span class="property">tar</span>.<span class="property">gz</span> -C /usr/local/redis</span><br><span class="line">[root@VM_24_98_centos ~]# cd /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/</span><br><span class="line">[root@VM_24_98_centos redis-<span class="number">5.0</span><span class="number">.6</span>]# make <span class="variable constant_">PREFIX</span>=<span class="regexp">/usr/</span>local/redis install</span><br></pre></td></tr></table></figure><p>复制</p><p>2、设置 Redis Cluster 服务器</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# mkdir -p /usr/local/redis/redis-cluster/redis-<span class="number">6391</span></span><br><span class="line">[root@VM_24_98_centos ~]# cp -r /usr/local/redis/redis-<span class="number">5.0</span><span class="number">.6</span>/redis.<span class="property">conf</span> /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/</span><br><span class="line">[root@VM_24_98_centos ~]# vim /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">conf</span></span><br></pre></td></tr></table></figure><p>复制</p><p>b. 设置 Redis Cluster 服务器配置环境</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 开启远程连接</span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"># </span><br><span class="line">protected-mode no</span><br><span class="line"># 端口号</span><br><span class="line">port <span class="number">6391</span></span><br><span class="line"># 守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 进程文件</span><br><span class="line">pidfile /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">pid</span></span><br><span class="line"># 日志文件</span><br><span class="line">logfile /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">log</span></span><br><span class="line"># 工作目录</span><br><span class="line">dir /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/</span><br><span class="line"># 主服务器密码</span><br><span class="line">masterauth foobared</span><br><span class="line"># 认证密码</span><br><span class="line">requirepass foobared</span><br><span class="line"># 开启 <span class="variable constant_">AOF</span> 持久化</span><br><span class="line">appendonly yes</span><br><span class="line"># 每秒调用一次 fsync</span><br><span class="line">appendfsync everysec</span><br><span class="line"># 开启集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 集群的配置文件，首次启动会自动创建</span><br><span class="line">cluster-config-file nodes.<span class="property">conf</span></span><br><span class="line"># 集群节点连接超时时间，<span class="number">15</span>秒</span><br><span class="line">cluster-node-timeout <span class="number">15000</span></span><br></pre></td></tr></table></figure><p>复制</p><p>c. 启动 Redis Cluster 服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">conf</span></span><br><span class="line">[root@VM_24_98_centos ~]# ps -ef |grep redis</span><br></pre></td></tr></table></figure><p>复制</p><p>d. 客户端测试连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">INFO</span></span><br><span class="line"><span class="attr">cluster_state</span>:fail</span><br><span class="line"><span class="attr">cluster_slots_assigned</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_slots_ok</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_slots_pfail</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_slots_fail</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_known_nodes</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">cluster_size</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_current_epoch</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_my_epoch</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_stats_messages_sent</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_stats_messages_received</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure><p>复制</p><p>e. 同理，集群服务器 redis-6392、redis-6393 、redis-6394、redis-6395、redis-6396 按照上面的步骤部署</p><p>3、Redis 5.0 开始不再使用 ruby 搭建集群，而是直接使用客户端命令 redis-cli 来创建。</p><p>a. 创建顺序三主三从，前面三个是主后面三个是从。由于我们设置了redis集群的密码，所以要带上密码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli --cluster create <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6395</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6392</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6394</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6396</span> --cluster-replicas <span class="number">1</span> -a foobared</span><br></pre></td></tr></table></figure><p>复制</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/9n5cusr6j9.png" class title="img"><p>b. 客户端测试连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">INFO</span></span><br><span class="line"><span class="attr">cluster_state</span>:ok</span><br><span class="line"><span class="attr">cluster_slots_assigned</span>:<span class="number">16384</span></span><br><span class="line"><span class="attr">cluster_slots_ok</span>:<span class="number">16384</span></span><br><span class="line"><span class="attr">cluster_slots_pfail</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_slots_fail</span>:<span class="number">0</span></span><br><span class="line"><span class="attr">cluster_known_nodes</span>:<span class="number">6</span></span><br><span class="line"><span class="attr">cluster_size</span>:<span class="number">3</span></span><br><span class="line"><span class="attr">cluster_current_epoch</span>:<span class="number">6</span></span><br><span class="line"><span class="attr">cluster_my_epoch</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">cluster_stats_messages_ping_sent</span>:<span class="number">1153</span></span><br><span class="line"><span class="attr">cluster_stats_messages_pong_sent</span>:<span class="number">1241</span></span><br><span class="line"><span class="attr">cluster_stats_messages_sent</span>:<span class="number">2394</span></span><br><span class="line"><span class="attr">cluster_stats_messages_ping_received</span>:<span class="number">1236</span></span><br><span class="line"><span class="attr">cluster_stats_messages_pong_received</span>:<span class="number">1153</span></span><br><span class="line"><span class="attr">cluster_stats_messages_meet_received</span>:<span class="number">5</span></span><br><span class="line"><span class="attr">cluster_stats_messages_received</span>:<span class="number">2394</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">NODES</span></span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6394</span>@<span class="number">16394</span> slave c54ebef126b30b5bd9cb157ccc0b6ddb952a1f50 <span class="number">0</span> <span class="number">1574234724000</span> <span class="number">5</span> connected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span>@<span class="number">16393</span> master - <span class="number">0</span> <span class="number">1574234725711</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line">43c325955c74f0ed79de6850dca8a509195acb13 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6392</span>@<span class="number">16392</span> slave 718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">0</span> <span class="number">1574234724000</span> <span class="number">4</span> connected</span><br><span class="line">3a32043079bf6af3723230ee3e6412e84dd66180 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574234724708</span> <span class="number">6</span> connected</span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb952a1f50 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>@<span class="number">16391</span> myself,master - <span class="number">0</span> <span class="number">1574234725000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line">718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6395</span>@<span class="number">16395</span> master - <span class="number">0</span> <span class="number">1574234723000</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br></pre></td></tr></table></figure><p>复制</p><p><strong>Redis Cluster 场景测试</strong></p><p>（1）模拟场景：Redis Cluster 中 某个 Master 节点挂掉，查看 Redis Cluster 状态。</p><p>Step1、关掉 Cluster-Master-6391 节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">SHUTDOWN</span></span><br></pre></td></tr></table></figure><p>复制</p><p>Step2、查看集群状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6393</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">NODES</span></span><br><span class="line">43c325955c74f0ed79de6850dca8a509195acb13 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6392</span>@<span class="number">16392</span> slave 718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">0</span> <span class="number">1574236204772</span> <span class="number">4</span> connected</span><br><span class="line">3a32043079bf6af3723230ee3e6412e84dd66180 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574236206778</span> <span class="number">6</span> connected</span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6394</span>@<span class="number">16394</span> master - <span class="number">0</span> <span class="number">1574236201000</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line">718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6395</span>@<span class="number">16395</span> master - <span class="number">0</span> <span class="number">1574236206000</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb952a1f50 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>@<span class="number">16391</span> master,fail - <span class="number">1574236049092</span> <span class="number">1574236047289</span> <span class="number">1</span> disconnected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span>@<span class="number">16393</span> myself,master - <span class="number">0</span> <span class="number">1574236204000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br></pre></td></tr></table></figure><p>复制</p><p>通过 CLUSTER NODES 信息可以看到，Cluster-Master-01-6391 主节点处于下线状态（fail），其 Cluster-Master-01-6391 节点的从节点 Cluster-Slave-01-6394 变为主节点；说明主节点挂掉后，6394 Slave 节点自动升级成为了 Master 节点。</p><p>Step3、启动 6391 Redis 服务，然后查看节点角色，此时 6391 变成了 Slave，6394 为 Master 节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">NODES</span></span><br><span class="line">43c325955c74f0ed79de6850dca8a509195acb13 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6392</span>@<span class="number">16392</span> slave 718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">0</span> <span class="number">1574238264397</span> <span class="number">4</span> connected</span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb952a1f50 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>@<span class="number">16391</span> myself,slave cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">0</span> <span class="number">1574238261000</span> <span class="number">1</span> connected</span><br><span class="line">3a32043079bf6af3723230ee3e6412e84dd66180 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574238265400</span> <span class="number">6</span> connected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span>@<span class="number">16393</span> master - <span class="number">0</span> <span class="number">1574238263000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line">718f66ab8b3574597a97b90f8257773d0483c556 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6395</span>@<span class="number">16395</span> master - <span class="number">0</span> <span class="number">1574238263000</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6394</span>@<span class="number">16394</span> master - <span class="number">0</span> <span class="number">1574238264000</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br></pre></td></tr></table></figure><p>复制</p><p>（2）模拟场景：为 Redis Cluster 添加一个新主（master）节点</p><p>Step1、按照上面的步骤新增一 Redis Cluster 服务器 Cluster-Master-04-6397</p><p>Step2、将 Cluster-Master-04-6397 节点加入 Redis Cluster 中（127.0.0.1:6391 为集群中任意可用的节点）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli --cluster add-node <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6397</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>  -a foobared</span><br></pre></td></tr></table></figure><p>复制</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/n11rtq4vp6.png" class title="img"><p><strong>Step3、为节点 Cluster-Master-04-6397 分配 slots（127.0.0.1:6391 为集群中任意可用的节点）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis-cluster]# /usr/local/redis/bin/redis-cli --cluster reshard <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span> -a foobared</span><br></pre></td></tr></table></figure><p>复制</p><img src="/2023/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/05/24/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/lj99ax1xuh.png" class title="img"><p>（3）模拟场景：为 Redis Cluster 某个 Master 节点添加 一个新从（slave）节点</p><p>Step1、按照上面的步骤新增一 Redis Cluster 服务器 Cluster-Slave-04-6398</p><p>Step2、将 Cluster-Slave-04-6398 节点加入 Redis Cluster 中（127.0.0.1:6391 为集群中任意可用的节点）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种方法随机为 6398 指定一个 master</span></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli --cluster add-node <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6398</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span> --cluster-slave -a foobared</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方式将为 6398 指定某个 master-id</span></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli --cluster add-node <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6398</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span> --cluster-slave --cluster-master-id 5cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c -a foobared</span><br></pre></td></tr></table></figure><p>复制</p><p>Step3、查看集群状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>&gt; <span class="variable constant_">CLUSTER</span> <span class="variable constant_">NODES</span></span><br><span class="line">5cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6397</span>@<span class="number">16397</span> master - <span class="number">0</span> <span class="number">1574243297701</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">1364</span> <span class="number">5461</span>-<span class="number">6826</span> <span class="number">10923</span>-<span class="number">12287</span></span><br><span class="line">207628f6fb8b3bb9a22db757507350fb880d4990 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6396</span>@<span class="number">16396</span> slave 94af5d349465be57400b6a4a1d770d56ad3d94ce <span class="number">0</span> <span class="number">1574243294000</span> <span class="number">6</span> connected</span><br><span class="line">94af5d349465be57400b6a4a1d770d56ad3d94ce <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6393</span>@<span class="number">16393</span> master - <span class="number">0</span> <span class="number">1574243296700</span> <span class="number">2</span> connected <span class="number">6827</span>-<span class="number">10922</span></span><br><span class="line">2e0134b0a87a73903d4774b6b37dd43e78e93733 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6391</span>@<span class="number">16391</span> myself,master - <span class="number">0</span> <span class="number">1574243292000</span> <span class="number">1</span> connected <span class="number">1365</span>-<span class="number">5460</span></span><br><span class="line">21a288afc7b6addebcd943ca606dd34f6b9c99db <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6398</span>@<span class="number">16398</span> slave 5cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c <span class="number">0</span> <span class="number">1574243295697</span> <span class="number">7</span> connected</span><br><span class="line">63bc9da88066b475bd878a56a11dd18023b211b6 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6394</span>@<span class="number">16394</span> slave 2e0134b0a87a73903d4774b6b37dd43e78e93733 <span class="number">0</span> <span class="number">1574243295000</span> <span class="number">5</span> connected</span><br><span class="line">c3d20b7f2df806ec87f3d45a7e334b5a2d3abe5b <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6395</span>@<span class="number">16395</span> master - <span class="number">0</span> <span class="number">1574243296000</span> <span class="number">3</span> connected <span class="number">12288</span>-<span class="number">16383</span></span><br><span class="line">f6a7c788d9e5d40bc62a3723ba02c25607cc2825 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6392</span>@<span class="number">16392</span> slave c3d20b7f2df806ec87f3d45a7e33</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis高可用 </tag>
            
            <tag> redis高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis教程：Redis 持久化</title>
      <link href="/2023/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2023/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>Redis 持久化方式</p><hr><h1 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h1><p>概述</p><p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。</p><p>你也可以通过调用 SAVE或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。 比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集:</p><p>save 60 1000</p><p>这种持久化方式被称为快照 snapshotting.</p><h2 id="何时执行快照"><a href="#何时执行快照" class="headerlink" title="何时执行快照"></a><strong>何时执行快照</strong></h2><p>出现下面的情况redis会快照内存里的数据</p><ul><li>用户发送bgsave命令(此时redis会fork一个子进程,子进程负责生成硬盘文件,父进程负责继续接受命令)</li><li>用户发送save命令(和bgsave命令不同,发送save命令后,到系统创建快照完成之前系统不会再接收新的命令,换 句话说save命令会阻塞后面的命令,而bgsave不会)</li><li>用户在配置文件了配置了类似这样的命令 save 60 1000</li><li>这个的意思是说,自从上次快照成功算起,如果满足”60秒内有1000次写入”这个条件,系统就自动调用bgsave,如 果配置文件里有多个save命令,只有满足一个就调用bgsave命令</li><li>用户发送shutdown,系统会先执行save命令阻塞客户端,然后关闭服务器</li><li>当有主从架构时,从服务器向主服务器发送sync命令来执行复制操作时,只有主服务器当时没有进行bgsave操 作,那么主服务器就会执行bgsave操作。</li></ul><h2 id="快照的配置信息"><a href="#快照的配置信息" class="headerlink" title="快照的配置信息"></a><strong>快照的配置信息</strong></h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br><span class="line">stop-writes-on-bgsave-error no rdbcompression yes</span><br><span class="line">dbﬁlename dump.rdb</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a><strong>工作方式</strong></h2><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作: Redis 调用forks. 同时拥有父进程和子进程。</p><p>子进程将数据集写入到一个临时 RDB 文件中。</p><p>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p><h1 id="只追加操作的文件（Append-only-ﬁle，AOF"><a href="#只追加操作的文件（Append-only-ﬁle，AOF" class="headerlink" title="只追加操作的文件（Append-only ﬁle，AOF)"></a>只追加操作的文件（Append-only ﬁle，AOF)</h1><p>概述</p><p>快照功能并不是非常耐久（dura ble）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>你可以在配置文件中打开AOF方式:</p><p>appendonly yes</p><p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p><h2 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a><strong>日志重写</strong></h2><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p><p>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建</p><p>（rebuild）。执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件。</p><h2 id="AOF有多耐用"><a href="#AOF有多耐用" class="headerlink" title="AOF有多耐用"></a><strong>AOF有多耐用</strong></h2><p>你可以配置 Redis 多久才将数据 fsync (从缓存区输入)到磁盘一次。有三种方式：</p><p>每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全</p><p>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。</p><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p><p><strong>如果AOF文件损坏了怎么办？</strong></p><p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</p><ol><li>为现有的 AOF 文件创建一个备份。</li><li>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复: redis-check-aof –ﬁx</li><li>（可选）使用 diﬀ -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。</li><li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</li></ol><p><strong>AOP重写原理</strong></p><p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制: redis 执行 fork() ，现在同时拥有父进程和子进程。</p><p>子进程开始将新 AOF 文件的内容写入到临时文件。</p><p>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</p><p>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据 追加到新 AOF 文件的末尾。</p><p>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</p><p><strong>怎样从RDB方式切换为AOF方式</strong></p><p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换到 AOF ： 为最新的 dump.rdb 文件创建一个备份。</p><p>将备份放到一个安全的地方。</p><p>执行以下两条命令:</p><p>-redis-cli conﬁg set appendonly yes redis-cli conﬁg set save “”</p><p>确保写命令会被正确地追加到 AOF 文件的末尾。</p><p>执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。</p><p>执行的第二条命令用于关闭 RDB 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 RDB 和 AOF 这两种持久化功能。</p><p>重要:别忘了在 redis.conf 中打开 AOF 功能！ 否则的话， 服务器重启之后， 之前通过 CONFIG SET 设置的配置就会被遗忘， 程序会按原来的配置来启动服务器。</p><p><strong>AOF和RDB之间的相互作用</strong></p><p>在版本号大于等于 2.4 的 Redis 中， BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE。这可以防止两个 Redis 后台进程同时对磁盘进行大量的I&#x2F;O 操作。</p><p>如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户， BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。 当Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为AOF 文件所保存的数据通常是最完整的。</p><p><strong>AOF VS RDB</strong></p><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数 据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF</p><p>文件的体积不至于过大.</p><p>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p><p>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p><p>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始:</p><p><strong>RDB的优缺点</strong></p><p>优点</p><p>RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个 小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需 求恢复到不同版本的数据集.</p><p>RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用 于灾难恢复.</p><p>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父 进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能.</p><p>与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些.</p><p>缺点</p><p>如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽 然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存 整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕 机,你可能会丢失几分钟的数据.</p><p>RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这 种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度.</p><p><strong>AOF 优缺点</strong></p><p>优点 -</p><p>使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync. 使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户 端请求),一旦出现故障，你最多丢失1秒的数据.</p><p>AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过 程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题.</p><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p><p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到FLUSHALL 执行之前的状态。</p><p>缺点 -</p><p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</p><p>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</p><p><strong>备份redis数据</strong></p><p>在阅读这个小节前， 请牢记下面这句话: 确保你的数据由完整的备份. 磁盘故障， 节点失效， 诸如此类的问题都可能让你的数据消失不见， 不进行备份是非常危险的。</p><p>Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。</p><p>这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。</p><p>创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。</p><p>确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 ﬁnd 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。</p><p>至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">PATH=/usr/local/bin:$PATH</span><br><span class="line">redis-cli SAVE</span><br><span class="line">date=$(date +&quot;%Y%m%d&quot;)</span><br><span class="line">cp /var/lib/redis/6379/dump.rdb /data01/cache_backup/$date.rdb</span><br><span class="line">echo &quot;done!&quot;</span><br></pre></td></tr></table></figure><p><strong>容灾备份</strong></p><p>Redis 的容灾备份基本上就是对数据进行备份， 并将这些备份传送到多个不同的外部数据中心。容灾备份可以在</p><p>Redis 运行并产生快照的主数据中心发生严重的问题时， 仍然让数据处于安全状态。</p><p>因为很多 Redis 用户都是创业者， 他们没有大把大把的钱可以浪费， 所以下面介绍的都是一些实用又便宜的容灾备份方法：</p><p>Amazon S3 ，以及其他类似 S3 的服务，是一个构建灾难备份系统的好地方。 最简单的方法就是将你的每小时或者每日 RDB 备份加密并传送到 S3 。 对数据的加密可以通过 gpg -c 命令来完成（对称加密模式）。 记得把你的密码放到几个不同的、安全的地方去（比如你可以把密码复制给你组织里最重要的人物）。 同时使用多个储存服务来保存数据文件，可以提升数据的安全性。</p><p>传送快照可以使用 SCP 来完成（SSH 的组件）。 以下是简单并且安全的传送方法： 买一个离你的数据中心非常远的 VPS ， 装上 SSH ， 创建一个无口令的 SSH 客户端 key ， 并将这个 key 添加到 VPS 的authorized_keys 文件中， 这样就可以向这个 VPS 传送快照备份文件了。 为了达到最好的数据安全性， 至少要从两个不同的提供商那里各购买一个 VPS 来进行数据容灾备份。</p><p>需要注意的是， 这类容灾系统如果没有小心地进行处理的话， 是很容易失效的。最低限度下， 你应该在文件传送完毕之后， 检查所传送备份文件的体积和原始快照文件的体积是否相同。 如果你使用的是VPS ， 那么还可以通过比对文件的 SHA1 校验和来确认文件是否传送完整。</p><p>另外， 你还需要一个独立的警报系统， 让它在负责传送备份文件的传送器（transfer）失灵时通知你。</p><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF<strong>重写</strong></h2><p>很多软件，都会对日志下手，因为，日志的优点保住，还是不错的，就是可以尽量不丢失数据，并且，同时克服一下它的缺点，就是把体量变小，恢复变快。所以，redis 的也采取了一定的做法：在 4.0 以前，有一个机制叫做重写。比如，回到之前的例子，不断创建 key，删除 key；那么，你可以发现，这样的操作，都可以抵消，对不对。再比如，假设有一个 list，你不断往里面 push 1W 个 v，那么，是不是就可以只写一条 push 语句，然后让它执行 1W 次就 ok？所以，总结一下，就是：<strong>删除抵消的，合并重复的。</strong></p><p>现在也知道了，最终得到的也是一个纯指令的 AOF 文件虽然指令被削减了一部分，但是纯指令，还是得一条条去恢复，所以效率还是有些低的。所以，后来，redis 偷偷地学习了 hdfs 的优点，就是，从 4.0 版本开始，AOF 会包含 RDB 全量，然后追加新的写操作。<br>而包含一个 RDB 全量之后，就可以直接把数据给导入内存即可，不用一步一步的操作。而追加的一部分写操作，又可以保证数据的全。在重写的时候，会先把老的数据，以 RDB 的形式，存到 AOF 文件中，然后，再把增量的，以指令的方式存入 AOF。AOF 就会包含二进制数据和增量的日志，于是就成了一个混合体。于是，这么改进，AOF 就把两个优点都占有了：既有 RDB 的快；又有 AOF 的全。fsync的间隔这样，明白了 AOF 之后，我们继续回头。redis 既然是一个内存级 kv 数据库，那么，这时写操作就会触发 I&#x2F;O，<br>那这样的话，就会影响 redis 的写速度，就会变慢。</p><p>redis 给了 3 个级别：</p><p><strong>NO</strong><br>        <strong>ALWAYS</strong><br><strong>everysec</strong><br>首先，如果你还不知道 fsync 是什么，那我得先简单描述一下：<br>传统的 UNIX 实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘 I&#x2F;O 都通过缓冲进行。<br>当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的 I&#x2F;O 操作。<br>这种输出方式被称为延迟写（delayed write）</p><p>延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，于是，就可能使得写到文件中的数据在一段时间内并没有写到磁盘上。这样，当系统发生故障时，这种延迟可能造成文件更新内容的丢失。所以，redis 给出的三个级别，就是让我们在数据可能丢失的数量、和性能之间，做出一个权衡。假设，我们采用 NO，从不手动将数据刷入磁盘，无疑，由于不用一直写磁盘，所以 redis 的性能，一定是最高的。但是，这样，就只有在缓冲区满了的时候，才会刷数据到磁盘。于是，在宕机的时候，会丢失的数据，则会有很多。假设，我们采用 ALWAYS，每次写，都将指令追加到 AOF。这样，我们最多最多，丢失一条数据（就是最后哪一条还没来得及写进磁盘的时候）。但是，由于每笔操作都往磁盘刷写，那性能一定是会受到很大的影响。所以，很多时候，会倾向于使用 everysec，每秒。<br>这样的话，由于不会次次写磁盘，所以对性能的影响还不至于那么大，而且，时间间隔也只有一秒，即使丢失，影响也不会太大。<br>所以，这往往作为一个折中方案。</p><h2 id="AOF-重写控制与详解"><a href="#AOF-重写控制与详解" class="headerlink" title="AOF 重写控制与详解"></a>AOF 重写控制与详解</h2><p>描述：Redis 生成新的 AOF 文件来代替旧 AOF 文件，这个新的 AOF 文件包含重建当前数据集所需的最少命令。具体过程是遍历所有数据库的所有键，从数据库读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。</p><p>命令：有两个 Redis 命令可以用于触发 AOF 重写，一个是 BGREWRITEAOF 、另一个是 REWRITEAOF 命令；</p><p>开启：AOF 重写由两个参数共同控制，auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size，同时满足这两个条件，则触发 AOF 后台重写 BGREWRITEAOF。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前AOF文件比上次重写后的AOF文件大小的增长比例超过100 </span><br><span class="line">auto-aof-rewrite-percentage 100  </span><br><span class="line">// 当前AOF文件的文件大小大于64MB </span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><p>关闭：auto-aof-rewrite-percentage 0，指定0的百分比，以禁用自动AOF重写功能。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 0</span><br></pre></td></tr></table></figure><p>REWRITEAOF：进行 AOF 重写，但是会阻塞主进程，服务器将无法处理客户端发来的命令请求，通常不会直接使用该命令。</p><p>BGREWRITEAOF：fork 子进程来进行 AOF 重写，阻塞只会发生在 fork 子进程的时候，之后主进程可以正常处理请求。</p><p>REWRITEAOF 和 BGREWRITEAOF 的关系与 SAVE 和 BGSAVE 的关系类似。</p><p>相关源码在 aof.c，核心方法是：rewriteAppendOnlyFile</p><h2 id="AOF-后台重写存在的问题"><a href="#AOF-后台重写存在的问题" class="headerlink" title="AOF 后台重写存在的问题"></a>AOF 后台重写存在的问题</h2><p>AOF 后台重写使用子进程进行从写，解决了主进程阻塞的问题，但是仍然存在另一个问题：子进程在进行 AOF 重写期间，服务器主进程还需要继续处理命令请求，新的命令可能会对现有的数据库状态进行修改，从而使得当前的数据库状态和重写后的 AOF 文件保存的数据库状态不一致。</p><h2 id="如何解决-AOF-后台重写存在的数据不一致问题"><a href="#如何解决-AOF-后台重写存在的数据不一致问题" class="headerlink" title="如何解决 AOF 后台重写存在的数据不一致问题"></a>如何解决 AOF 后台重写存在的数据不一致问题</h2><p>为了解决上述问题，Redis 引入了 AOF 重写缓冲区（aof_rewrite_buf_blocks），这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个写命令之后，它会同时将这个写命令追加到 AOF 缓冲区和 AOF 重写缓冲区。</p><p>这样一来可以保证：</p><p>1、现有 AOF 文件的处理工作会如常进行。这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</p><p>2、从创建子进程开始，也就是 AOF 重写开始，服务器执行的所有写命令会被记录到 AOF 重写缓冲区里面。</p><p>这样，当子进程完成 AOF 重写工作后，父进程会在 serverCron 中检测到子进程已经重写结束，则会执行以下工作：</p><p>1、将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中，这时新 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致。</p><p>2、对新的 AOF 文件进行改名，原子的覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。</p><p>之后，父进程就可以继续像往常一样接受命令请求了。</p><p>相关源码在 aof.c，核心方法是：rewriteAppendOnlyFileBackground</p><h2 id="AOF-重写缓冲区内容过多怎么办"><a href="#AOF-重写缓冲区内容过多怎么办" class="headerlink" title="AOF 重写缓冲区内容过多怎么办"></a>AOF 重写缓冲区内容过多怎么办</h2><p>将 AOF 重写缓冲区的内容追加到新 AOF 文件的工作是由主进程完成的，所以这一过程会导致主进程无法处理请求，如果内容过多，可能会使得阻塞时间过长，显然是无法接受的。</p><p>Redis 中已经针对这种情况进行了优化：</p><p>1、在进行 AOF 后台重写时，Redis 会创建一组用于父子进程间通信的管道，同时会新增一个文件事件，该文件事件会将写入 AOF 重写缓冲区的内容通过该管道发送到子进程。</p><p>2、在重写结束后，子进程会通过该管道尽量从父进程读取更多的数据，每次等待可读取事件1ms，如果一直能读取到数据，则这个过程最多执行1000次，也就是1秒。如果连续20次没有读取到数据，则结束这个过程。</p><p>通过这些优化，Redis 尽量让 AOF 重写缓冲区的内容更少，以减少主进程阻塞的时间。</p><p>到此，AOF 后台重写的核心内容基本告一段落，通过一张图来看下其完整流程。</p><img src="/2023/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/v2-c860405f0c426655102ad1294caebbc2_720w.webp" class title="img"><p>相关源码在 aof.c，核心方法是：aofCreatePipes、aofChildWriteDiffData、rewriteAppendOnlyFile</p><h2 id="RDB、AOF、混合持久，我应该用哪一个？"><a href="#RDB、AOF、混合持久，我应该用哪一个？" class="headerlink" title="RDB、AOF、混合持久，我应该用哪一个？"></a>RDB、AOF、混合持久，我应该用哪一个？</h2><p>一般来说， 如果想尽量保证数据安全性， 你应该同时使用 RDB 和 AOF 持久化功能，同时可以开启混合持久化。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>如果你的数据是可以丢失的，则可以关闭持久化功能，在这种情况下，Redis 的性能是最高的。</p><p>使用 Redis 通常都是为了提升性能，而如果为了不丢失数据而将 appendfsync 设置为 always 级别时，对 Redis 的性能影响是很大的，在这种不能接受数据丢失的场景，其实可以考虑直接选择 MySQL 等类似的数据库。</p><h2 id="服务启动时如何加载持久化数据"><a href="#服务启动时如何加载持久化数据" class="headerlink" title="服务启动时如何加载持久化数据"></a>服务启动时如何加载持久化数据</h2><p>简单来说，如果同时启用了 AOF 和 RDB，Redis 重新启动时，会使用 AOF 文件来重建数据集，因为通常来说， AOF 的数据会更完整。</p><p>而在引入了混合持久化之后，使用 AOF 重建数据集时，会通过文件开头是否为“REDIS”来判断是否为混合持久化。</p><p>完整流程如下图所示：</p><img src="/2023/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/05/24/Redis%E6%95%99%E7%A8%8B%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96/v2-fc88a7b32d3394a14a0d50a72318694e_720w.webp" class title="img"><p>相关源码在 server.c，核心方法是：loadDataFromDisk</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ面试问题三连：如何解决消息不丢失、重复消费、积压？</title>
      <link href="/2023/05/24/MQ%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B8%89%E8%BF%9E%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%E3%80%81%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E7%A7%AF%E5%8E%8B%EF%BC%9F/"/>
      <url>/2023/05/24/MQ%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B8%89%E8%BF%9E%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%E3%80%81%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E7%A7%AF%E5%8E%8B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="MQ面试问题三连：如何解决消息不丢失、重复消费、积压？"><a href="#MQ面试问题三连：如何解决消息不丢失、重复消费、积压？" class="headerlink" title="MQ面试问题三连：如何解决消息不丢失、重复消费、积压？"></a>MQ面试问题三连：如何解决消息不丢失、重复消费、积压？</h1><h1 id="如何确保消息不丢失"><a href="#如何确保消息不丢失" class="headerlink" title="如何确保消息不丢失?"></a>如何确保消息不丢失?</h1><h2 id="为什么消息会丢失"><a href="#为什么消息会丢失" class="headerlink" title="为什么消息会丢失?"></a>为什么消息会丢失?</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1088cf1322414c1c8ae2f65d75baae2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h5 id="整个消息从生产到消费，哪些地方可能导致丢消息？"><a href="#整个消息从生产到消费，哪些地方可能导致丢消息？" class="headerlink" title="整个消息从生产到消费，哪些地方可能导致丢消息？"></a>整个消息从生产到消费，哪些地方可能导致丢消息？</h5><p>生产阶段：消息在Producer中被创建，<strong>网络传输</strong>到Broker。</p><p>存储阶段：消息在Broker<strong>存储</strong>，若是集群，消息会被<strong>复制</strong>到其他副本上。</p><p>消费阶段：Consumer从Broker拉取消息，<strong>网络传输</strong>到Consumer上。</p><p>总结下来有以下可靠性问题：</p><ol><li>网络传输时的可靠性问题</li><li>存储时的可靠性问题</li></ol><p>在主流的消息队列产品中都提供了非常完成的消息可靠性保证机制，确保消息的可靠传递，不丢失消息。</p><h2 id="你怎么知道消息丢没丢？"><a href="#你怎么知道消息丢没丢？" class="headerlink" title="你怎么知道消息丢没丢？"></a>你怎么知道消息丢没丢？</h2><p>首当其冲的问题其实不是如何保证消息传递的可靠性，而是应该考虑如何知道消息是否丢失。</p><p>答案是<strong>有序性</strong>。</p><p>原理很简单：</p><ol><li>在Producer端，每个发送的消息添加一个<strong>连续递增</strong>的序号。</li><li>在Consumer端，若检测到消息<strong>序号不连续</strong>了，则丢消息了，还可以确定丢的是那一条数据。</li></ol><h3 id="分布式提升了消息丢失检查方法的复杂度"><a href="#分布式提升了消息丢失检查方法的复杂度" class="headerlink" title="分布式提升了消息丢失检查方法的复杂度"></a>分布式提升了消息丢失检查方法的复杂度</h3><p>在Kafka和RocketMQ中，为了提升并发程度，降低了有序性。从Topic级有序降到了分区级有序。</p><p><strong>因此由原来的每个Topic检测消息序号的连续性，降为每个分区单独检测消息序号的连续性。</strong></p><p>因此我们要注意：</p><p><strong>在Producer端</strong></p><ol><li>我们要指定发送消息的分区</li><li>若有多个Producer实例，每个Producer分别生成各自的消息序号，且附加上Producer标识。</li></ol><p><strong>在Consumer端</strong></p><ol><li>按照Producer分表来检测序号的连续性。</li><li>Consumer实例数最好和分区数一致，一一对应可以方便Consumer检测序号的连续性。</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ae5a38dfe04972bb6916688e9a5c7a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h2 id="怎么确保消息不丢失？"><a href="#怎么确保消息不丢失？" class="headerlink" title="怎么确保消息不丢失？"></a>怎么确保消息不丢失？</h2><h3 id="请求确认机制（ACK）解决网络传输时的可靠性问题"><a href="#请求确认机制（ACK）解决网络传输时的可靠性问题" class="headerlink" title="请求确认机制（ACK）解决网络传输时的可靠性问题"></a>请求确认机制（ACK）解决网络传输时的可靠性问题</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c0bd35a65be4e41a2b2a895b0b8fd55~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p><strong>请求确认机制原理</strong></p><ol><li>Producer告诉Broker我消息发给你了，你收到了告诉我一声。</li><li>Broker收到消息之后给Producer发送，我收到了。</li></ol><h3 id="生产阶段和消费阶段发送ACK的时机不同"><a href="#生产阶段和消费阶段发送ACK的时机不同" class="headerlink" title="生产阶段和消费阶段发送ACK的时机不同"></a>生产阶段和消费阶段发送ACK的时机不同</h3><p>生产阶段：</p><ol><li>若存储阶段为单机，则Broker将消息写入硬盘之后，再返回ACK。</li><li>若存储阶段为集群，则将消息发送到Broker两个以上节点，再返回ACK。 消费阶段：</li></ol><p>Consumer消费掉消息之后，再返回ACK。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c054816f808f4983a99f0fc2e70258d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h1 id="为什么会有重复消息？"><a href="#为什么会有重复消息？" class="headerlink" title="为什么会有重复消息？"></a>为什么会有重复消息？</h1><p>我们可以从业务和技术角度切入。</p><h2 id="业务角度"><a href="#业务角度" class="headerlink" title="业务角度"></a>业务角度</h2><ol><li>前端重复提交表单</li><li>用户恶意进行刷单</li></ol><h2 id="技术角度"><a href="#技术角度" class="headerlink" title="技术角度"></a>技术角度</h2><p>MQTT协议中对<strong>传递消息时的服务质量</strong>进行了分类，虽然由MQTT协议定义但是在所有消息传递场景都适用。</p><p><strong>At most once</strong>:最多分发一次。也就是说不保证消息可靠性，允许丢消息。</p><p><strong>At least once</strong>:至少分发一次。也就是说保证消息可靠性，允许重复消息。</p><p><strong>Exactly once</strong>:只分发一次。这是最高级别的消息传递，消息丢失和重复都是不可接受的，使用这个服务质量等级会有额外的开销。</p><p>消息队列传递消息时的服务质量通常是<strong>At least once</strong>，因为保证消息的可靠性符合大部分业务的需求。</p><blockquote><p>At least once-&gt;保证消息可靠性-&gt;同一条消息会被重复发送-&gt;重复消费问题</p></blockquote><h1 id="怎么解决消息被重复消费的问题？"><a href="#怎么解决消息被重复消费的问题？" class="headerlink" title="怎么解决消息被重复消费的问题？"></a>怎么解决消息被重复消费的问题？</h1><p>因为消息队列的服务质量是<strong>At least once</strong> ，因此消息队列<strong>无法保证消息不重复</strong>，因此消费重复的问题得由<strong>Consumer端</strong>来解决。</p><p>一般采用<strong>幂等性解决重复消息问题</strong>。</p><h2 id="什么是幂等？"><a href="#什么是幂等？" class="headerlink" title="什么是幂等？"></a>什么是幂等？</h2><p>幂等操作的特点：<strong>任意多次执行所产生的影响均与一次执行的影响相同</strong>。</p><p>举个栗子：</p><p>幂等操作：“将某账户余额设置为100元”，这个操作执行多次之后账户余额始终是100元，因此这个操作是幂等的。</p><p>不幂等操作：“将某账户余额增加100元”，每次一执行，余额都会增加100元，因此这个操作是不幂等的。</p><h2 id="在Restful中哪些操作需要考虑幂等？"><a href="#在Restful中哪些操作需要考虑幂等？" class="headerlink" title="在Restful中哪些操作需要考虑幂等？"></a>在Restful中哪些操作需要考虑幂等？</h2><p>现在流行的 Restful 推荐的几种 HTTP 接口方法中，分别存在幂等行与不能保证幂等的方法，如下：</p><ol><li><code>√ </code>满足幂等</li><li><code>x</code> 不满足幂等</li><li><code>-</code> 可能满足也可能不满足幂等，根据实际业务逻辑有关</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad4808e71f4f49a9a90a3ad46b3eef2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h2 id="如何实现幂等？"><a href="#如何实现幂等？" class="headerlink" title="如何实现幂等？"></a>如何实现幂等？</h2><p>实现幂等的最好方式是<strong>从业务逻辑设计上入手，将消费的业务逻辑设计成具备幂等性的操作。</strong></p><h3 id="利用数据库的唯一约束实现幂等"><a href="#利用数据库的唯一约束实现幂等" class="headerlink" title="利用数据库的唯一约束实现幂等"></a>利用数据库的唯一约束实现幂等</h3><p>举个栗子：改造“将某账户余额增加100元”的业务逻辑。</p><p>1.增加限定，每个转账单每个账户只可以执行一次变更操作。具体实现：在数据库中建一张转账流水表，表包含字段转账单ID、账户ID、变更金额，对（转账单ID、账户ID）创建唯一键约束。</p><p>2.“将某账户余额增加100元”的业务逻辑变为：“在转账流水表中增加一条转账记录，然后再根据转账记录，异步操作更新用户余额”。</p><p>如果重复消费，就回触发唯一键约束，从而实现了操作的幂等性。</p><h3 id="为更新的数据设置前置条件"><a href="#为更新的数据设置前置条件" class="headerlink" title="为更新的数据设置前置条件"></a>为更新的数据设置前置条件</h3><p>核心思想：<strong>乐观锁</strong></p><p>举个栗子：改造“将某账户余额增加100元”的业务逻辑。</p><p>为“将某账户余额增加100元”添加前置条件，变为：“如果某账户余额版本为2，则将账户X的余额增加100元”。</p><p>每次更新时，若数据中的版本号和消息中的版本号一直，则更新数据并且版本号+1，否则拒绝更新，从而实现了操作的幂等性。</p><h3 id="记录并检查操作（也叫Token机制或GUID机制）"><a href="#记录并检查操作（也叫Token机制或GUID机制）" class="headerlink" title="记录并检查操作（也叫Token机制或GUID机制）"></a>记录并检查操作（也叫Token机制或GUID机制）</h3><p>基本思路：在执行数据更新操作之前，先检查一下是否执行过这个更新操作。</p><p>举个栗子：改造“将某账户余额增加100元”的业务逻辑。</p><p>给“将某账户余额增加100元”生成全局唯一ID，存入Redis中，假设Redis中存在全局唯一ID则消息没有被消费，否则消息已经被消费。</p><p>消费时，第一步，先到Redis检查全局唯一ID是否存在，第二步，存在则消费，第三步，消费完成之后，到Redis删除全局唯一ID。</p><p>该方法需要<strong>保证消费时三步操作的原子性</strong>，才能实现幂等，否则会出现Bug。具体原子性的实现可以是分布式事务，也可以是分布式锁。</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbf84739a84d49d083304b5867842fa8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h1 id="什么是消息积压？"><a href="#什么是消息积压？" class="headerlink" title="什么是消息积压？"></a>什么是消息积压？</h1><p>大量消息被堆积在broker端，没有被消费。</p><h1 id="为什么会消息积压？"><a href="#为什么会消息积压？" class="headerlink" title="为什么会消息积压？"></a>为什么会消息积压？</h1><p>宏观角度主要原因是：<strong>producer端生产速度 &gt; consumer端消费速度</strong>。</p><p>导致<strong>producer端生产速度 &gt; consumer端消费速度</strong>的情况有多种：</p><ol><li>设计的时候就没有考虑消费速度要大于生产速度，这种情况最不应该。</li><li>某一时刻消息积压上涨<ol><li>比如说抢购，导致生产端一下子并发量飙升，考虑水平扩容或者服务降级。</li><li>消费端有很多消费失败，导致消费性能下降</li></ol></li></ol><h1 id="消息积压了该怎么办？"><a href="#消息积压了该怎么办？" class="headerlink" title="消息积压了该怎么办？"></a>消息积压了该怎么办？</h1><p>这里首先得有一个认识：<strong>消息队列本身的处理能力要远大于业务系统的处理能力。因此主要考虑业务逻辑中的性能优化。</strong></p><h2 id="紧急处理"><a href="#紧急处理" class="headerlink" title="紧急处理"></a>紧急处理</h2><p>问题的根在于consumer端消费速度慢导致的，最直接的方法就是<strong>水平扩容</strong>，增加消费端的并发数，来提升总体的消费性能。</p><p>需要注意的是：在Kafka或RocketMQ中 <strong>在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。</strong> 否则水平扩容之后也是没有效果的。</p><p>具体需要怎么进行紧急扩容，可以参考另外一篇文章，消息队列已经挤压了百万条，需要怎么进行紧急补救</p><h2 id="紧急处理之后进行Consumer端优化"><a href="#紧急处理之后进行Consumer端优化" class="headerlink" title="紧急处理之后进行Consumer端优化"></a>紧急处理之后进行Consumer端优化</h2><p>只要针对consumer端的业务逻辑进行优化。</p><h1 id="我们的业务代码怎么和消息队列配合，达到一个最佳的性能？"><a href="#我们的业务代码怎么和消息队列配合，达到一个最佳的性能？" class="headerlink" title="我们的业务代码怎么和消息队列配合，达到一个最佳的性能？"></a>我们的业务代码怎么和消息队列配合，达到一个最佳的性能？</h1><h2 id="producer端"><a href="#producer端" class="headerlink" title="producer端"></a>producer端</h2><p>发送端性能上不去，你需要优先检查一下，<strong>是不是发消息之前的业务逻辑耗时太多导致的。</strong></p><p>提升发送性能的方法：<strong>设置合适的并发和批量大小。</strong></p><p>Producer 发消息给 Broker，Broker 收到消息后返回确认响应，这是一次完整的交互。</p><p>提升发送性能就是为了在<strong>单位时间内增加交互的消息量</strong>。</p><p>并发方式：对于响应时间短的友好</p><p>批量方式：对吞吐量大的友好</p><h3 id="耗时分析"><a href="#耗时分析" class="headerlink" title="耗时分析"></a>耗时分析</h3><ul><li>1.准备发送：发送端准备数据、序列化消息、构造请求等逻辑的时间</li><li>2.消息从producer端网络传输到broker端</li><li>3.broker端处理消息</li><li>4.消息响应从broker端网络传输到producer端</li></ul><h2 id="broker端"><a href="#broker端" class="headerlink" title="broker端"></a>broker端</h2><p>刚才已经提过了，消费队列性能远大于业务系统的处理能力，所以broker端的性能不用考虑，要考虑也可以通过水平扩容broker达到很好的效果。</p><h2 id="consumer端"><a href="#consumer端" class="headerlink" title="consumer端"></a>consumer端</h2><p>如上，只要针对consumer端的业务逻辑进行优化，或者进行水平扩容，且在broker增加分区。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文彻底明白Spring的循环依赖</title>
      <link href="/2023/05/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2023/05/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Spring</strong>的循环依赖，也就是两个<strong>bean</strong>之间产生了互相依赖，那么引出的问题就是如何顺利的将两个<strong>bean</strong>创建出来并注册到容器中。更有甚者，产生了循环依赖的<strong>bean</strong>还需要生成动态代理对象，这种情况则比普通的循环依赖更为复杂。</p><p>本篇文章将对<strong>Spring</strong>中的循环依赖进行详细分析，结合<strong>示例工程</strong>，<strong>流程图示</strong>和<strong>源码</strong>，力求一文阐释清楚<strong>Spring</strong>中的循环依赖问题以及如何解决，并会在最后给出<strong>Spring</strong>中的三个缓存的具体作用。</p><p>在开始本文的分析前，有如下几点概念说明。</p><ol><li><strong>bean</strong>的实例化，就是将<strong>bean</strong>的对象<strong>new</strong>出来，称为<strong>bean</strong>的原始对象，原始对象没有完成属性注入，不能称为<strong>bean</strong>；</li><li><strong>bean</strong>的属性注入，就是为<strong>bean</strong>的原始对象注入其它<strong>bean</strong>即依赖注入，完成依赖注入的原始对象，此时可以作为<strong>bean</strong>放入容器；</li><li><strong>bean</strong>的初始化可以理解为：<strong>bean</strong>实例化 + <strong>bean</strong>属性注入。</li></ol><p><strong>Spring</strong>版本：<strong>5.3.2</strong></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一-循环依赖的产生"><a href="#一-循环依赖的产生" class="headerlink" title="一. 循环依赖的产生"></a>一. 循环依赖的产生</h3><p>如果有两个业务类实现如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceB myServiceB;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceA myServiceA;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么<strong>Spring</strong>在初始化<strong>MyServiceA</strong>的<strong>bean</strong>时候，会为<strong>MyServiceA</strong>的原始对象注入<strong>MyServiceB</strong>的<strong>bean</strong>，此时由于容器中没有<strong>MyServiceB</strong>的<strong>bean</strong>，所以<strong>Spring</strong>又会去初始化<strong>MyServiceB</strong>的<strong>bean</strong>，初始化<strong>MyServiceB</strong>的bean的时候，会为<strong>MyServiceB</strong>的原始对象注入<strong>MyServiceA</strong>的<strong>bean</strong>，此时就发生了循环依赖。</p><p>后续都将<strong>MyServiceA</strong>简称为<strong>A</strong>，将<strong>MyServiceB</strong>简称为<strong>B</strong>。</p><h3 id="二-循环依赖的解决"><a href="#二-循环依赖的解决" class="headerlink" title="二. 循环依赖的解决"></a>二. 循环依赖的解决</h3><p>如下是循环依赖中最复杂的一种情况，即两个需要生成动态代理的<strong>bean</strong>之间形成了循环依赖。</p><p>业务类如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceA</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String initMessage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceB myServiceB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyService A execute.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        initMessage = <span class="string">&quot;MyService A.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceB</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String initMessage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyServiceA myServiceA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyService B execute.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        initMessage = <span class="string">&quot;MyService B.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在业务类中使用了@<strong>MyAnnotation</strong>注解来修饰方法，该注解是自定义注解，没有任何含义，仅为了帮助在<strong>SpringAOP</strong>中进行切点声明，@<strong>MyAnnotation</strong>注解定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.leanr.spring.ioc.mytest.MyAnnotation)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">allMethodPointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;allMethodPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeBeforeMethod</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyAspect execute.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.leanr.spring.ioc.mytest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>测试类如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span></span><br><span class="line">                <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么针对上面这种需要生成动态代理的<strong>bean</strong>之间存在循环依赖的情况，整个解决流程如下所示。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847dddf8699b423eba9cc3841135bb24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Spring-循环依赖示意图"></p><p>上述流程图中，出现了<strong>一级缓存</strong>，<strong>二级缓存</strong>和<strong>三级缓存</strong>，如果对这三个缓存没有概念，那么就暂时不要去深究，就当这三个缓存是三个<strong>Map</strong>，在下面的章节，会结合源码，具体分析其作用。</p><h3 id="三-源码分析"><a href="#三-源码分析" class="headerlink" title="三. 源码分析"></a>三. 源码分析</h3><p>在<strong>Spring</strong>中，如果基于<strong>XML</strong>配置<strong>bean</strong>，那么使用的容器为<strong>ClassPathXmlApplicationContext</strong>，如果是基于注解配置<strong>bean</strong>，则使用的容器为<strong>AnnotationConfigApplicationContext</strong>。以<strong>AnnotationConfigApplicationContext</strong>为例，其构造函数如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">// 初始化容器</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>AnnotationConfigApplicationContext</strong>的构造函数中会调用到<strong>AbstractApplicationContext</strong>的<strong>refresh()</strong> 方法，实际上无论是基于<strong>XML</strong>配置<strong>bean</strong>，还是基于注解配置<strong>bean</strong>，亦或者是<strong>Springboot</strong>中，在初始化容器时都会调用到<strong>AbstractApplicationContext</strong>的<strong>refresh()</strong> 方法中。下面看一下<strong>refresh()</strong> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化所有非延时加载的单例bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关心<strong>refresh()</strong> 方法中调用的<strong>finishBeanFactoryInitialization()</strong> 方法，该方法会初始化所有非延时加载的单例<strong>bean</strong>，其实现如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有非延时加载的单例bean</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>finishBeanFactoryInitialization()</strong> 方法中会调用到<strong>DefaultListableBeanFactory</strong>的<strong>preInstantiateSingletons()</strong> 方法，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个循环中通过getBean()方法初始化bean</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是FactoryBean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不是FactoryBean，则通过getBean()方法来初始化bean</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里需要注意，<strong>Spring</strong>中初始化<strong>bean</strong>，是通过调用容器的<strong>getBean()</strong> 方法来完成，在<strong>getBean()</strong> 方法中如果获取不到<strong>bean</strong>，此时就会初始化这个<strong>bean</strong>，<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法的实现如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">0public Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 有三种情况会调用到这里</span></span><br><span class="line">    <span class="comment">// 1. 容器启动的时候初始化A，所以调用到这里以进行A的初始化</span></span><br><span class="line">    <span class="comment">// 2. 初始化A的时候要属性注入B，所以调用到这里以进行B的初始化</span></span><br><span class="line">    <span class="comment">// 3. 初始化B的时候要属性注入A，所以调用到这里以获取A的bean</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">        String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object beanInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1和情况2：去一级缓存中获取bean，是获取不到的</span></span><br><span class="line">    <span class="comment">// 情况3：依次去一级缓存，二级缓存和三级缓存中获取A的bean</span></span><br><span class="line">    <span class="comment">// 情况3：在本示例中，最终会在三级缓存中获取到A原始对象对应的ObjectFactory</span></span><br><span class="line">    <span class="comment">// 情况3：然后通过A原始对象对应的ObjectFactory获取A原始对象（的代理对象）</span></span><br><span class="line">    <span class="comment">// 情况3：获取到A原始对象（的代理对象）后，会将其放入二级缓存</span></span><br><span class="line">    <span class="comment">// 情况3：然后将A原始对象对应的ObjectFactory从三级缓存删除</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非单例bean是无法支持循环依赖的，所以这里判断是否是非单例bean的循环依赖场景，如果是则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况1和情况2都会执行到这里</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 在上面的getSingleton()方法中会调用到createBean()方法</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            beanCreation.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际会有三种情况调用到<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法，总结如下。</p><ol><li>容器初始化的时候，初始化<strong>A</strong>，这种情况，是无法从一级缓存中获取到<strong>A</strong>的<strong>bean</strong>（或者代理<strong>bean</strong>）的，所以调用<strong>getSingleton(String)</strong> 方法会返回<strong>null</strong>，然后调用<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;<strong>?**&gt;)方法来获取（初始化）</strong>A**；</li><li>初始化<strong>A</strong>的时候，会属性注入<strong>B</strong>，此时会调用到<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法来初始化<strong>B</strong>，这种情况的逻辑同上；</li><li>初始化<strong>B</strong>的时候，会属性注入<strong>A</strong>，此时会调用到<strong>AbstractBeanFactory</strong>的<strong>getBean()</strong> 方法来获取<strong>A</strong>的<strong>bean</strong>（或者代理<strong>bean</strong>），并且能够在<strong>getSingleton(String)</strong> 方法中获取到<strong>A</strong>的原始对象对应的<strong>ObjectFactory</strong>，然后通过<strong>A</strong>的原始对象对应的<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法获取到<strong>A</strong>的原始对象（的代理对象），并将其放入二级缓存，最后将<strong>A</strong>的原始对象对应的<strong>ObjectFactory</strong>从三级缓存中删除。</li></ol><p>上述的情况1和情况2，在<strong>getSingleton(String)</strong> 方法中只会去一级缓存获取，而情况三会依次去一级缓存，二级缓存和三级缓存中获取，这是因为有一个叫做<strong>singletonsCurrentlyInCreation</strong>的集合会对即将实例化并执行初始化逻辑的<strong>bean</strong>进行标记，那么在情况1和情况2中，<strong>singletonsCurrentlyInCreation</strong>中都是没有<strong>A</strong>或<strong>B</strong>的标记的，只有情况3的<strong>singletonsCurrentlyInCreation</strong>中有<strong>A</strong>的标记，如果有标记，表明这时发生了循环依赖，所以需要去到二级缓存或者三级缓存中获取到提前暴露出来的对象。</p><p>如果是情况1或者情况2，那么就会调用到<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;<strong>?**&gt;)方法来初始化</strong>A<strong>或者</strong>B<strong>，这里传入的</strong>ObjectFactory**&lt;<strong>?**&gt;实际是一个</strong>Lambdas<strong>表达式，所以调用</strong>ObjectFactory<strong>的</strong>getObject()** 方法，就会调用到<strong>createBean()</strong> 方法。下面继续看<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;**?**&gt;)方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向singletonsCurrentlyInCreation集合中添加beanName</span></span><br><span class="line">            <span class="comment">// 标记beanName对应的bean正在初始化，这里就是标记A或者B正在初始化</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用getObject()方法，实际就是调用之前的createBean()方法</span></span><br><span class="line">                <span class="comment">// 这里得到的singletonObject就是初始化后得到的bean（或者代理bean）</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 移除A或者B正在初始化的标记</span></span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">// 将A或者B的bean放入一级缓存</span></span><br><span class="line">                <span class="comment">// 删除A或者B在二级缓存中的原始对象（的代理对象）</span></span><br><span class="line">                <span class="comment">// 删除A或者B在三级缓存中的ObjectFactory</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DefaultSingletonBeanRegistry</strong>的<strong>getSingleton</strong>(<strong>String, ObjectFactory</strong>&lt;<strong>?**&gt;)方法中首先会标记</strong>A<strong>或者</strong>B<strong>正在初始化，然后调用到</strong>AbstractAutowireCapableBeanFactory<strong>的</strong>createBean()** 方法，在<strong>createBean()</strong> 方法中会真正的把对象<strong>new</strong>出来以得到原始对象，然后为原始对象属性注入其它<strong>bean</strong>（循环依赖就是在这里发生）和执行初始化逻辑，在<strong>createBean()</strong> 方法执行完后，就会得到真正可用的<strong>bean</strong>（或代理<strong>bean</strong>），之后就从<strong>singletonsCurrentlyInCreation</strong>中移除正在初始化的标记，然后将<strong>bean</strong>（或者代理<strong>bean</strong>）放入一级缓存，然后删除在二级缓存中的原始对象（的代理对象），删除在三级缓存中的<strong>ObjectFactory</strong>。那么重点就是<strong>createBean()</strong> 方法，其实现如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到BeanDefinition</span></span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化在这里</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进<strong>doCreateBean()</strong> 方法，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把A或者B的对象new出来，称作原始对象</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的bean就是A或者B的原始对象，此时没有被属性注入，也没有执行初始化逻辑</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里计算结果为true，目的是提前将A或B的原始对象对应的ObjectFactory放到三级缓存中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将A或者B的原始对象对应的ObjectFactory放到三级缓存中</span></span><br><span class="line">        <span class="comment">// 那么ObjectFactory的getObejct()方法实际就会调用到getEarlyBeanReference()方法</span></span><br><span class="line">        <span class="comment">// 如果需要动态代理，getEarlyBeanReference()方法会返回原始对象的代理对象</span></span><br><span class="line">        <span class="comment">// 如果不需要动态代理，getEarlyBeanReference()方法会返回原始对象</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里为A或者B的原始对象进行属性注入</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 调用initializeBean()方法来为A或者B的原始对象执行初始化的逻辑</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 这里会从二级缓存中将A或者B的原始对象（的代理对象）获取出来</span></span><br><span class="line">        <span class="comment">// 如果是初始化A的时候调用到这里，那么能够获取出来A的原始对象（的代理对象）</span></span><br><span class="line">        <span class="comment">// 如果是初始化B的时候调用到这里，那么不能够获取出来B的原始对象（的代理对象）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">// 只有A能进到这里</span></span><br><span class="line">                <span class="comment">// 将A的原始对象（的代理对象）替换A的原始对象</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原始对象（的代理对象）返回</span></span><br><span class="line">    <span class="comment">// 其实这里的对象已经是可以使用的bean了</span></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doCreateBean()</strong> 方法可以概括如下。</p><ol><li><strong>new</strong>出对象以得到<strong>A</strong>或<strong>B</strong>的原始对象，然后将<strong>A</strong>或<strong>B</strong>的原始对象对应的<strong>ObjectFactory</strong>放入三级缓存（提前暴露原始对象的<strong>ObjectFactory</strong>到三级缓存中，以使得发生循环依赖的时候能够在三级缓存中通过原始对象的<strong>ObjectFactory</strong>获得原始对象或者原始对象的代理对象）；</li><li>为原始对象进行属性注入，这里就分为两种情况。<ol><li>为<strong>A</strong>原始对象属性注入<strong>B</strong>的<strong>bean</strong>，那么就触发了初始化<strong>B</strong>的逻辑；</li><li>为<strong>B</strong>原始对象属性注入<strong>A</strong>的<strong>bean</strong>，那么在这里，就会使用到<strong>A</strong>提前暴露到三级缓存中的<strong>ObjectFactory</strong>来获取<strong>A</strong>的原始对象（的代理对象），由前面的分析可知，通过<strong>A</strong>的<strong>ObjectFactory</strong>来获取到<strong>A</strong>的原始对象（的代理对象）后，会将其放入二级缓存，所以这个时候二级缓存中存在<strong>A</strong>的原始对象（的代理对象）。</li></ol></li><li>调用initializeBean()方法来为A或者B的原始对象执行初始化的逻辑，initializeBean()方法中有一个和循环依赖密切相关的执行步骤就是在后置处理器中为需要动态代理的对象生成代理对象，那么这里又有两种情况。<ol><li>初始化<strong>A</strong>的时候执行到这里，说明<strong>B</strong>的初始化已经执行完毕了（因为<strong>A</strong>的属性注入已经结束了），所以<strong>A</strong>原始对象的代理对象就已经生成并且注入到了<strong>B</strong>的<strong>bean</strong>（或者代理<strong>bean</strong>）中，所以这里<strong>A</strong>就不能再在<strong>initializeBean()</strong> 方法的后置处理器中再生成一个代理对象，如果生成就出现了两个代理对象违反了单例；</li><li>初始化<strong>B</strong>的时候执行到这里，<strong>B</strong>原始对象的代理对象还没有在任何一个地方有生成，所以需要在<strong>initializeBean()</strong> 方法的后置处理器中生成一个代理对象，并将这个代理对象返回。同时，在前面的分析中已知，只有通过调用<strong>ObjectFactory</strong>来获取原始对象（的代理对象）的时候，才会将原始对象（的代理对象）放入二级缓存，所以<strong>B</strong>的原始对象（的代理对象）是没有被放入到二级缓存中去的。</li></ol></li><li>由于doCreateBean()方法是需要返回可用的bean，所以在A和B都需要动态代理的情况下，还需要为属性注入和执行了初始化逻辑之后的对象再最后做一步操作，那就是将A和B的动态代理对象获取到并返回。<ol><li>对于<strong>A</strong>，<strong>A</strong>的动态代理对象在二级缓存中，所以调用<strong>getSingleton()</strong> 方法从二级缓存中获取并返回；</li><li>对于<strong>B</strong>，<strong>B</strong>的动态代理对象不存在于二级缓存中，但是当前<strong>B</strong>的对象已经是在后置处理器中生成的动态代理对象，所以直接返回。</li></ol></li></ol><p>那么到这里，<strong>Spring</strong>使用三级缓存来解决循环依赖的问题就基本分析完毕，建议结合第二节中的流程图一起阅读。</p><h3 id="四-一级缓存作用"><a href="#四-一级缓存作用" class="headerlink" title="四. 一级缓存作用"></a>四. 一级缓存作用</h3><p>一级缓存的定义在<strong>DefaultSingletonBeanRegistry</strong>中，定义如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>一级缓存用于存放容器中可以使用的<strong>bean</strong>或者代理<strong>bean</strong>，像例子中的<strong>A</strong>和<strong>B</strong>，由于它们都需要生成动态代理对象，所以它们在一级缓存中存放的就是它们的代理<strong>bean</strong>，后续容器中任何地方使用<strong>A</strong>和<strong>B</strong>，都是使用的一级缓存中它们的代理<strong>bean</strong>。</p><h3 id="五-二级缓存作用"><a href="#五-二级缓存作用" class="headerlink" title="五. 二级缓存作用"></a>五. 二级缓存作用</h3><p>二级缓存的定义在<strong>DefaultSingletonBeanRegistry</strong>中，定义如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>二级缓存用于存放原始对象（的代理对象），以让在有多重循环依赖的时候其它对象都从二级缓存中拿到同一个当前原始对象（的代理对象），并且只有在调用了三级缓存中的<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法获取原始对象（的代理对象）时，才会将原始对象（的代理对象）放入二级缓存，而调用三级缓存中的<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法获取原始对象（的代理对象）这种情况只会发生在有循环依赖的时候，所以，**<code>二级缓存在没有循环依赖的情况下不会被使用到</code>**。</p><h3 id="六-三级缓存作用"><a href="#六-三级缓存作用" class="headerlink" title="六. 三级缓存作用"></a>六. 三级缓存作用</h3><p>三级缓存的定义在<strong>DefaultSingletonBeanRegistry</strong>中，定义如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>三级缓存用于存放原始对象对应的<strong>ObjectFactory</strong>，每生成一个原始对象，都会将这个原始对象对应的<strong>ObjectFactory</strong>放到三级缓存中，通过调用<strong>ObjectFactory</strong>的<strong>getObject()</strong> 方法，就能够在需要动态代理的情况下为原始对象生成代理对象并返回，否则返回原始对象，以此来处理循环依赖时还需要动态代理的情况。</p><p>为什么会存在三级缓存，主要原因就是：**<code>延迟代理对象的创建</code><strong>。设想一下，如果在创建出一个原始对象的时候，就直接将这个原始对象的代理对象创建出来（如果需要创建的话），然后就放在二级缓存中，似乎感觉三级缓存就没有存在的必要了对吧，但是请打住，这里存在的问题就是，如果真这么做了，那么每一个对象在创建出原始对象后，就都会去创建代理对象，而</strong>Spring<strong>的原始设计中，代理对象的创建应该是由</strong>AnnotationAwareAspectJAutoProxyCreator<strong>这个后置处理器的</strong>postProcessAfterInitialization()** 来完成，也就是：**<code>在对象初始化完毕后，再去创建代理对象</code><strong>。如果真的只用两个缓存来解决循环依赖，那么就会打破</strong>Spring<strong>对</strong>AOP**的一个设计思想。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Spring</strong>中发生循环依赖，简单讲就是<strong>A</strong>的<strong>bean</strong>依赖<strong>B</strong>的<strong>bean</strong>，<strong>B</strong>的<strong>bean</strong>又依赖<strong>A</strong>的<strong>bean</strong>。</p><p><strong>Spring</strong>解决循环依赖的思路就是，当<strong>A</strong>的<strong>bean</strong>需要<strong>B</strong>的<strong>bean</strong>的时候，提前将<strong>A</strong>的<strong>bean</strong>放在缓存中（实际是将<strong>A</strong>的<strong>ObjectFactory</strong>放到三级缓存），然后再去创建<strong>B</strong>的<strong>bean</strong>，但是<strong>B</strong>的<strong>bean</strong>也需要<strong>A</strong>的<strong>bean</strong>，那么这个时候就去缓存中拿<strong>A</strong>的<strong>bean</strong>，<strong>B</strong>的<strong>bean</strong>创建完毕后，再回来继续创建<strong>A</strong>的<strong>bean</strong>，最终完成循环依赖的解决。</p><p>那么有几个问题需要结合整篇文章的讨论，进行一个总结。</p><p><strong>1. 为什么不直接使用一级缓存来解决循环依赖</strong></p><p>一级缓存中预期存放的是一个正常完整的<strong>bean</strong>，而如果只用一级缓存来解决循环依赖，那么一级缓存中会在某个时间段存在不完整的<strong>bean</strong>，这是不安全的。</p><p><strong>2. 为什么不直接使用一级缓存和二级缓存解决循环依赖</strong></p><p>这个问题需要结合为什么引入三级缓存来分析。引用第六节的论述，使用一级缓存和二级缓存确实可以解决循环依赖，但是这要求每个原始对象创建出来后就立即生成动态代理对象（如果有的话），然后将这个动态代理对象放入二级缓存，这就打破了<strong>Spring</strong>对<strong>AOP</strong>的设计原则，即：**<code>在对象初始化完毕后，再去创建代理对象</code><strong>。所以引入三级缓存，并且在三级缓存中存放一个对象的</strong>ObjectFactory<strong>，目的就是：</strong><code>延迟代理对象的创建</code>**，这里延迟到啥时候创建呢，有两种情况：第一种就是确实存在循环依赖，那么没办法，只能在需要的时候就创建出来代理对象然后放到二级缓存中，第二种就是不存在循环依赖，那就是正常的在初始化的后置处理器中创建。</p><p>因此不直接使用一级缓存和二级缓存来解决循环依赖的原因就是：**<code>希望在不存在循环依赖的情况下不破坏Spring对AOP的设计原则</code>**。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> aop </tag>
            
            <tag> ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解@Enable* 原理</title>
      <link href="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在Spring 和 SpringBoot 中有很多这样的注解，例如常见的：<code>@EnableAsync</code>、 <code>@EnableCaching</code> 、<code>@EnableConfigurationProperties</code>。</p><p>每引用一个starer 几乎都有一个 <strong>@Enable</strong>*相关的注解。</p><p>这一注解的作用：就是用来启用某一个功能的配置。启用某一功能，仅需要加上一个注解即可生效，可以使组建之间的相互依赖降低了耦合性。</p><hr><p>例如：<code>@EnableAsync</code> 注解启用异步功能，在SpringBoot中如果没有启用这个注解，直接在使用 <code>@Async</code> 是没法起到异步执行的作用的。所有使用这个功能，就先启用 <code>@EnableAsync</code>,不然他的相关配置不生效，也就是配置了@Async 注解，也没有人来管它。</p><p>一个简单的注解，能带动一个某一个功能模块甚至带动一整个框架的，比如：@SpringBootApplication。来分析一下这个 @Enable*注解的原理。</p><p>其实 <strong>@Enable*注解很简单，随便找一个注解，点进去一看就能恍然大悟，它的所有核心 都在* *@Import 注解当中。 所有真正核心的 是</strong> @Import**注解，由它去加载它自己对应的配置类，然后启动他的功能。</p><p>所以 <strong>@Enbale *注解就是没有啥用的，就是营造一种* *高大上的、又神奇装牛X的 感觉。所以它有啥用？其实它没有用。你看既然 使用</strong> @Import注解就可以了<strong>，还要它干嘛，我直接使用</strong> @Import注解去加载就好了**，这不是多此一举吗？</p><p><strong>真的没有用吗？</strong> <strong>有用的！！ 存在即合理</strong></p><p>举个例子：**<code>@EnableAutoConfiguration</code>**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、除了桥梁的作用，它还可以携带上一些参数：在解析处理这个 注解的时候，可以从这里拿到一些 自定义配置的参数，去做相关的操作。</p><p>2、除了 <strong>@Import</strong> 注解还有其它的注解 <strong>@AutoConfigurationPackage</strong> ，它可以组合多个注解放到一起。</p><p>3、高大上又神秘高级，又方面你开发者去使用。假如：启用这个功能可能需要更多的 类加载，还有要其它注解去配和，如果不将其包装到 <strong>@Enable</strong>*中，那对开发者来说，配置起来又相对麻烦了许多，将其包装到一起，只需要记住使用这一功能记住这个注解即可。极大的方面！！。</p><p>4、将功能做组建抽离开来，降低耦合性。</p><p>所以此重点就不再是 <strong>@Enable* 注解了</strong>，而是 <strong><code>@Import</code><strong>注解了，</strong>挂羊头卖狗肉！</strong></p><h1 id="1、-Import-注解的作用"><a href="#1、-Import-注解的作用" class="headerlink" title="1、@Import 注解的作用"></a>1、@Import 注解的作用</h1><p>我们看一下这个注解的源码解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> Configuration</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> ImportSelector</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> ImportResource</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span></span><br><span class="line"><span class="comment">     * or regular component classes to import.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  这个value值 有三种类型：</span></span><br><span class="line"><span class="comment">     *      -   其它的常规类型，就相当于Configuration配置累解析</span></span><br><span class="line"><span class="comment">     *      -   ImportSelector</span></span><br><span class="line"><span class="comment">     *      -   ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Import 注解导入的类 有三种，分别是：ImportSelector、 ImportBeanDefinitionRegistrar、一种是普通各类，会当作为配置类去处理。</p><p>@Import 注解的作用可以用来将 JavaBean 注入到IOC容器中。</p><p>1、比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;UserService.class&#125;)</span></span><br></pre></td></tr></table></figure><p>注入一个JavaBean到 IOC容器中。</p><p>2、又比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;XXConfig.class&#125;)</span></span><br></pre></td></tr></table></figure><p>导入一个配置类，然后继续扩展解析这个配置类。</p><p>3、又比如： <code>@Import(&#123;XXImportSelector.class&#125;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-09-27 13:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata)</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; zClass = <span class="literal">null</span>;</span><br><span class="line">        Set&lt;String&gt; annotationTypes = importingClassMetadata.getAnnotationTypes();</span><br><span class="line">        Iterator&lt;String&gt; zClasses = annotationTypes.iterator();</span><br><span class="line">        <span class="keyword">while</span> (zClasses.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> zClasses.next();</span><br><span class="line">            <span class="keyword">if</span> (type.equals(EnableConfig.class.getName()))</span><br><span class="line">            &#123;</span><br><span class="line">                Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(EnableConfig.class.getName());</span><br><span class="line">                zClass = (Class&lt;?&gt;) annotationAttributes.get(<span class="string">&quot;zClass&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;zClass.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入实现ImportSelector的类，这个实现可以拿到许多相关注解，然后可以取对应注解上的值，进行你所想要的操作。</p><p>4、还比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;XXBeanDefinitionRegistry.class&#125;)</span></span><br></pre></td></tr></table></figure><p>导入 BeanDefinitionRegistry 的实现类。该接口是Spring中定义的bean的注册类。所以的Bean注册都会走这个类。所以导入一个BeanDefinitionRegistry的实现类，可以自定义实现动态注册 bean的操作。</p><h1 id="源码了解"><a href="#源码了解" class="headerlink" title="源码了解"></a>源码了解</h1><p>如下是处理 @Import注解的的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理 @Import 注解，加载某个类，将其假如IOC容器中 擦数： 当前的配置类，当前的源码类，导入的类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">            Collection&lt;SourceClass&gt; importCandidates, <span class="type">boolean</span> checkForCircularImports)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// @Import 注解 可以配置多个类没循环遍历</span></span><br><span class="line">                <span class="comment">// 该注解上面说了 有三种类型，遍历做分支处理</span></span><br><span class="line">                <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 三种类行，做分支判断</span></span><br><span class="line">                    <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">                        <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">                        Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                        <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line"></span><br><span class="line">                        ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                                selector, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//延迟导入处理</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.deferredImportSelectors != <span class="literal">null</span> &amp;&amp; selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">this</span>.deferredImportSelectors.add(</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorHolder</span>(configClass, (DeferredImportSelector) selector));</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 执行 ImportSelector 接口的方法，实现了该ImportSelector的方法，拿到要注入的类全名</span></span><br><span class="line">                            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 返回来的转为一个配置类去加载</span></span><br><span class="line">                            Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 继续递归检查</span></span><br><span class="line">                            processImports(configClass, currentSourceClass, importSourceClasses, <span class="literal">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">                      <span class="comment">// 处理 ImportBeanDefinitionRegistrar 的实现类</span></span><br><span class="line">            <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">                        <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">                        Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line"></span><br><span class="line">                        <span class="type">ImportBeanDefinitionRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span></span><br><span class="line">                                BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);</span><br><span class="line"></span><br><span class="line">                        ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                                registrar, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">                        <span class="comment">// process it as an @Configuration class</span></span><br><span class="line">                        <span class="comment">// 当作配置类解析</span></span><br><span class="line">                        <span class="built_in">this</span>.importStack.registerImport(</span><br><span class="line">                                currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">                        processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                        <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">                        configClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个源码了解就到这里。</p><h1 id="利用-Enable-自己也装一次高大上。"><a href="#利用-Enable-自己也装一次高大上。" class="headerlink" title="利用 @Enable* 自己也装一次高大上。"></a>利用 @Enable* 自己也装一次高大上。</h1><p>我们来写一个启用切面打印日志功能。</p><p>我们新建一个项目，作为一个starter , 一个jar包。 然后其他项目引入这个 jar启用日志打印的操作。</p><p>项目如下：</p><img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-a228903e207405c3b19863254a231f42_720w.webp" class title="img"><p><strong>1、EnablePrintRequestLog.java</strong></p><p>开启日切面功能的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;LogPrintImportSelector.class, MyImportBeanDefinitionRegistrar.class, TestBean.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnablePrintRequestLog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截哪个包</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">targetPackage</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、SysAspect.java</strong></p><p>切面类, 此处只拦截 自定义的包下的加了 @RestController 和 @Controller 注解的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 10:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysAspect</span> <span class="keyword">extends</span> <span class="title class_">Rules</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法规则拦截 </span></span><br><span class="line"><span class="comment">     * 此处只拦截 加了 <span class="doctag">@RestController</span> 和 <span class="doctag">@Controller</span> 注解的类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="meta">@Pointcut(&quot;@within(org.springframework.web.bind.annotation.RestController)||@within(org.springframework.stereotype.Controller)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">controllerAspect</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;controllerAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span></span><br><span class="line">    &#123;</span><br><span class="line">        interceptor.forEach(j -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getPackages().equals(getTargetClassPackage(joinPoint)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j.before(joinPoint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getTargetClassPackage</span><span class="params">(JoinPoint point)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拦截的实体类</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> point.getTarget();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截的方法名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> point.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">simpleName</span> <span class="operator">=</span> target.getClass().getSimpleName();</span><br><span class="line">        <span class="keyword">return</span> simpleName.substring(simpleName.lastIndexOf(<span class="string">&quot;.&quot;</span>) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(value = &quot;controllerAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span></span><br><span class="line">    &#123;</span><br><span class="line">        interceptor.forEach(j -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getPackages().equals(getTargetClassPackage(joinPoint)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j.after(joinPoint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;controllerAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span></span><br><span class="line">    &#123;</span><br><span class="line">        interceptor.forEach(j -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getPackages().equals(getTargetClassPackage(joinPoint)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j.afterReturning(joinPoint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;controllerAspect()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable e)</span></span><br><span class="line">    &#123;</span><br><span class="line">        interceptor.forEach(j -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getPackages().equals(getTargetClassPackage(joinPoint)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j.doAfterThrowing(joinPoint, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;controllerAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(JoinPoint joinPoint)</span></span><br><span class="line">    &#123;</span><br><span class="line">        interceptor.forEach(j -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getPackages().equals(getTargetClassPackage(joinPoint)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j.around(joinPoint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、Interceptor.java</strong></p><p>为了扩展性，我留了切面的 5种方法的接口：Interceptor.jarva</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(JoinPoint joinPoint,Throwable e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认一个实现打印日志：需要扩展继续实现该接口，比如我需要存储记录日志的信息。请求的时候会打印如下信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(SysAspect.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>    &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;########  &#123;&#125;  请求开始 &quot;</span> + LocalDateTime.now() + <span class="string">&quot;   ###############&quot;</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;########  &#123;&#125;  请求的方法--&gt; &quot;</span> + className + <span class="string">&quot;/&quot;</span> + methodName + <span class="string">&quot;()&quot;</span> + <span class="string">&quot;/&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span>    &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;########  结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable e)</span>    &#123;</span><br><span class="line">        LOGGER.error(<span class="string">&quot;异常了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span>    &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;######## afterReturning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;######## around&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、LogPrintImportSelector.java</strong></p><p>实现 ImportSelector，主要用来拿到注解 <strong>@EnablePrintRequestLog</strong> 的参数 tagetPackage 的参数。并且加载其全局配置类：GlobConfig.java</p><p><strong>5、GlobConfig.java</strong></p><p>该类的可以做所有的配置，将所需要的Bean 放到这里注入到IOC容器中，此处为了 测试 <strong>@Import</strong>注解的使用，i u 没有放在这里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 18:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 扫描包，让其自动注入 好了</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.enable.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobConfig</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、MyImportBeanDefinitionRegistrar.java</strong></p><p>测试动态注册Bean,注册提供的默认切面打印日志类的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">        beanDefinition.setBeanClassName(DefaultInterceptor.class.getName());</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;defaultInterceptor&quot;</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、Rules.java</strong></p><p>主要用来存放 切面的拦截包路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Rules</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String packages;</span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getPackages</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> packages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Rules <span class="title function_">setPackages</span><span class="params">(String packages)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.packages = packages;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、TestBean.java</strong></p><p>一个测试 @Import 导入普通Bean的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 19:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m test Bean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8、TestController.java</strong></p><p>测试对比 该类在 com.enable.demo 的包下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 20:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TesController</span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tes</span><span class="params">()</span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>将上面的项目打成一个 jar包，然后在新的项目中引入：如下：</p><img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-db2ef067df0466ed0498aa837544827c_720w.webp" class title="img"><p>在新项目中的启动类上加上：该注解：**@EnablePrintRequestLog(targetPackage &#x3D; “generator.test.demo”)** 并且指定拦截的包名称。</p><img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-ffa6c661d5043b78dfceacdfcdb7bb34_720w.webp" class title="img"><p>我们启动测试。</p><p>如上：我们定义了两个接口：</p><p>1、<a href="https://link.zhihu.com/?target=http://127.0.0.1:9999/test">http://127.0.0.1:9999/test</a>. 该接口在包引用者的包下：<code>generator.test.demo</code></p><p>2、<a href="https://link.zhihu.com/?target=http://127.0.0.1:9999/t">http://127.0.0.1:9999/t</a> 该接口在本身的 jar 包内 :<code>com.enable.demo</code></p><p>所以这时候应该只会有一个请求打印日志。</p><p>项目启动完毕。</p><img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-ece99befd5fd0a02d8dbe789b12a855e_720w.webp" class title="img"><p>**1、请求：<a href="https://link.zhihu.com/?target=http://127.0.0.1:9999/test">http://127.0.0.1:9999/test</a>**接口，应该打印请求日志:结果如下：</p><img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-70f2ce3fcd66616c489c6c63e25755b8_720w.webp" class title="img"><p>请求结果正确。</p><p><strong>2、请求另外一个接口 <a href="https://link.zhihu.com/?target=http://127.0.0.1:9999/t">http://127.0.0.1:9999/t</a></strong> ：该接口不应该打印请求日志。</p><p>结果：正确</p><img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-8c48ef685d46536bab6841f748de02c0_720w.webp" class title="img"><p><strong>3、重写预留的切面增强的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 永健</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-10 22:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YY</span> <span class="keyword">extends</span> <span class="title class_">DefaultInterceptor</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写切面前置增强方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看打印结果：</p><img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-1f9156f9586c4bd6caecdc82af769024_720w.webp" class title="img"><p><strong>3、去除 @EnablePrintRequestLog注解测试。</strong></p><p>此时没有打印日志：正确</p><img src="/2023/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/05/23/%E4%BA%86%E8%A7%A3-Enable-%E5%8E%9F%E7%90%86/v2-9a4d47fbf943f70f8e608c2fa66bb8e0_720w.webp" class title="img"><p><strong>总而言之，言而总之。</strong>利用@Enbale***的原理，你也可以很轻松的打造一个低耦合的组件功能，给别人很简单明了的使用，即使你的功能错中复杂，但是对于使用者来说，越少配置越好，拿来即用。</p><p>比如：你可以包装一个 权限登陆组件。以后哪个项目中使用到了，注解引入 jar 包 @Enable注解打开就可以使用，多么简单容易，不用重复去写代码…….</p><p>你学会了吗？？？？？？</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> enable注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal，一篇文章就够了</title>
      <link href="/2023/05/23/%E8%AF%B4%E4%B8%80%E8%AF%B4ThreadLocal/"/>
      <url>/2023/05/23/%E8%AF%B4%E4%B8%80%E8%AF%B4ThreadLocal/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要从以下几个角度来分析理解</p><ul><li><p>1、ThreadLocal是什么</p></li><li><p>2、ThreadLocal怎么用</p></li><li><p>3、ThreadLocal源码分析</p></li><li><p>4、ThreadLocal内存泄漏问题</p></li></ul><hr><h3 id="1-ThreadLocal是什么？"><a href="#1-ThreadLocal是什么？" class="headerlink" title="1. ThreadLocal是什么？"></a>1. ThreadLocal是什么？</h3><p>从名字我们就可以看到<code>ThreadLocal</code> 叫做本地线程变量，意思是说，<code>ThreadLocal</code> 中填充的的是当前线程的变量，该变量对其他线程而言是封闭且隔离的，<code>ThreadLocal</code> 为变量在每个线程中创建了一个副本，这样每个线程都可以访问自己内部的副本变量。</p><p>从字面意思很容易理解，但是实际角度就没那么容易了，作为一个面试常问的点，使用场景也是很丰富。</p><ul><li>1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li><li>2、线程间数据隔离</li><li>3、进行事务操作，用于存储线程事务信息。</li><li>4、数据库连接，<code>Session</code>会话管理。</li></ul><p>现在相信你已经对<code>ThreadLocal</code>有一个大致的认识了，下面我们看看如何用？</p><h3 id="2-ThreadLocal怎么用？"><a href="#2-ThreadLocal怎么用？" class="headerlink" title="2. ThreadLocal怎么用？"></a>2. ThreadLocal怎么用？</h3><p>下面让我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            local.set(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,local:&quot;</span> + local.get());</span><br><span class="line">        &#125;).start());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">线程：Thread-<span class="number">0</span>,local:Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">线程：Thread-<span class="number">1</span>,local:Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">线程：Thread-<span class="number">2</span>,local:Thread-<span class="number">2</span>:<span class="number">2</span></span><br><span class="line">线程：Thread-<span class="number">3</span>,local:Thread-<span class="number">3</span>:<span class="number">3</span></span><br><span class="line">线程：Thread-<span class="number">4</span>,local:Thread-<span class="number">4</span>:<span class="number">4</span></span><br><span class="line">线程：Thread-<span class="number">5</span>,local:Thread-<span class="number">5</span>:<span class="number">5</span></span><br><span class="line">线程：Thread-<span class="number">6</span>,local:Thread-<span class="number">6</span>:<span class="number">6</span></span><br><span class="line">线程：Thread-<span class="number">7</span>,local:Thread-<span class="number">7</span>:<span class="number">7</span></span><br><span class="line">线程：Thread-<span class="number">8</span>,local:Thread-<span class="number">8</span>:<span class="number">8</span></span><br><span class="line">线程：Thread-<span class="number">9</span>,local:Thread-<span class="number">9</span>:<span class="number">9</span></span><br></pre></td></tr></table></figure><p>从结果可以看到，每一个线程都有自己的local 值，这就是TheadLocal的基本使用 。</p><p>下面我们从源码的角度来分析一下，ThreadLocal的工作原理。</p><h3 id="3-ThreadLocal源码分析"><a href="#3-ThreadLocal源码分析" class="headerlink" title="3. ThreadLocal源码分析"></a>3. ThreadLocal源码分析</h3><p>1、<code>set</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread&#x27;s copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="comment">//首先获取当前线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取线程中变量 ThreadLocal.ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="comment">//如果不为空，</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果为空，初始化该线程对象的map变量，其中key 为当前的threadlocal 变量</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//初始化线程内部变量 threadLocals ，key 为当前 threadlocal</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment">         * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment">         * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>汇总下，<code>ThreadLocalMap</code> 为 <code>ThreadLocal</code> 的一个静态内部类，里面定义了<code>Entry</code> 来保存数据。而且是继承的弱引用。在<code>Entry</code>内部使用<code>ThreadLocal</code>作为<code>key</code>，使用我们设置的<code>value</code>作为<code>value</code>。</p><p>对于每个线程内部有个<code>ThreadLocal.ThreadLocalMap</code> 变量，存取值的时候，也是从这个容器中来获取。</p><p>2、<code>get</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value in the current thread&#x27;s copy of this</span></span><br><span class="line"><span class="comment">     * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">     * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread&#x27;s value of this thread-local</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析，相信你对该方法已经有所理解了，首先获取当前线程，然后通过<code>key threadlocal</code> 获取 设置的<code>value</code> 。</p><h3 id="4-ThreadLocal-内存泄漏问题"><a href="#4-ThreadLocal-内存泄漏问题" class="headerlink" title="4. ThreadLocal 内存泄漏问题"></a>4. ThreadLocal 内存泄漏问题</h3><p>我们首先来看下，下面这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注释说的很清楚了，<code>Note that null keys (i.e. entry.get()* == null)</code></p><p>如果 <code>key threadlocal</code> 为 <code>null</code> 了，这个 <code>entry</code> 就可以清除了。</p><p><code>ThreadLocal</code>是一个弱引用，当为<code>null</code>时，会被当成垃圾回收 。</p><img src="/2023/05/23/%E8%AF%B4%E4%B8%80%E8%AF%B4ThreadLocal/05/23/%E8%AF%B4%E4%B8%80%E8%AF%B4ThreadLocal/v2-50b25a5f65fe02d6eebe27801a94c833_720w.webp" class title="img"><p><strong>重点来了，突然我们ThreadLocal是null了，也就是要被垃圾回收器回收了，但是此时我们的ThreadLocalMap（thread 的内部属性）生命周期和Thread的一样，它不会回收，这时候就出现了一个现象。那就是ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。</strong></p><p>解决办法：使用完<code>ThreadLocal</code>后，执行<code>remove</code>操作，避免出现内存溢出情况。</p><p>所以 如同 <code>lock</code> 的操作 最后要执行解锁操作一样，<code>ThreadLocal</code>使用完毕一定记得执行remove 方法，清除当前线程的数值。</p><p>如果不<code>remove</code> 当前线程对应的<code>VALUE</code> ,就会一直存在这个值。</p><p>使用了线程池，可以达到“线程复用”的效果。但是归还线程之前记得清除<code>ThreadLocalMap</code>，要不然再取出该线程的时候，<code>ThreadLocal</code>变量还会存在。这就不仅仅是内存泄露的问题了，整个业务逻辑都可能会出错。</p><h3 id="5-为什么key使用弱引用？"><a href="#5-为什么key使用弱引用？" class="headerlink" title="5. 为什么key使用弱引用？"></a>5. 为什么key使用弱引用？</h3><p>如果使用强引用，当<code>ThreadLocal</code> 对象的引用（强引用）被回收了，<code>ThreadLocalMap</code>本身依然还持有<code>ThreadLocal</code>的强引用，如果没有手动删除这个key ,则<code>ThreadLocal</code>不会被回收，所以只要当前线程不消亡，<code>ThreadLocalMap</code>引用的那些对象就不会被回收， 可以认为这导致<code>Entry</code>内存泄漏。</p><p>附：强引用-软引用-弱引用</p><ul><li>强引用：普通的引用，强引用指向的对象不会被回收；</li><li>软引用：仅有软引用指向的对象，只有发生gc且内存不足，才会被回收；</li><li>弱引用：仅有弱引用指向的对象，只要发生gc就会被回收。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> threadlocal </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说⼀下JVM中，哪些是共享区，哪些可以作为gc root</title>
      <link href="/2023/05/23/%E8%AF%B4%E2%BC%80%E4%B8%8BJVM%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%85%B1%E4%BA%AB%E5%8C%BA%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-root/"/>
      <url>/2023/05/23/%E8%AF%B4%E2%BC%80%E4%B8%8BJVM%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%85%B1%E4%BA%AB%E5%8C%BA%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-root/</url>
      
        <content type="html"><![CDATA[<h1 id="1-堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的"><a href="#1-堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的" class="headerlink" title="1.堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的"></a>1.堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的</span><br><span class="line">堆: 不用多说了,放对象的地方</span><br><span class="line">方法区: 类定义的成员变量丶常量丶静态变量丶方法都在这里</span><br><span class="line">栈: 程序运行才有的,会把运行时的方法压入栈,里面有局部变量等东西</span><br><span class="line">本地方法栈: 操作系统方法</span><br><span class="line">程序计数器: 标记代码走到哪里了</span><br></pre></td></tr></table></figure><img src="/2023/05/23/%E8%AF%B4%E2%BC%80%E4%B8%8BJVM%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%85%B1%E4%BA%AB%E5%8C%BA%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-root/05/23/%E8%AF%B4%E2%BC%80%E4%B8%8BJVM%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%85%B1%E4%BA%AB%E5%8C%BA%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-root/94d2022bc0284ef291f54f1b1a48bd65.png" class title="img"><h1 id="2、什么是gc-root"><a href="#2、什么是gc-root" class="headerlink" title="2、什么是gc root"></a>2、什么是gc root</h1><p>JVM在进⾏垃圾回收时，需要找到“垃圾”对象，也就是没有被引⽤的对象，但是直接<br>找“垃圾”对象是⽐较耗时的，所以反过来，先找“⾮垃圾”对象，也就是正常对象，那么就需要从某<br>些“根”开始去找，根据这些“根”的引⽤路径找到正常对象，⽽这些“根”有⼀个特征，就是它只会引⽤其他<br>对象，⽽不会被其他对象引⽤，例如：栈中的本地变量、⽅法区中的静态变量、本地⽅法栈中的变量、正<br>在运⾏的线程等可以作为gc root。</p><p><strong>什么是是可达性分析算法？</strong></p><p>现代虚拟机基本都是采用可达性分析算法来判断对象是否存活，可达性算法的原理是以一系列叫做  <strong>GC Root</strong> 的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 <strong>GC Root</strong> 为起点的引用链中，则这些对象会被判断为垃圾对象,会被 GC 回收。</p><img src="/2023/05/23/%E8%AF%B4%E2%BC%80%E4%B8%8BJVM%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%85%B1%E4%BA%AB%E5%8C%BA%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-root/05/23/%E8%AF%B4%E2%BC%80%E4%B8%8BJVM%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%85%B1%E4%BA%AB%E5%8C%BA%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-root/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9PeXdleXNDU2VMVXJZcVBpY2pWd2p1TUNoUHJQaWNOSGRYdlpMbXg5SGRlTmliUlFqbkZad1VCRlhUUTZtSnk3OWFqeDRCZHFGTWljSWlhVzRCTlFhR1RaV2liZy82NDA" class title="img"><p>如图示，如果用可达性算法即可解决上述循环引用的问题，因为从<strong>GC Root</strong> 出发没有到达 a,b,所以 a，b 可回收。</p><p><strong>a, b 对象可回收，就一定会被回收吗?</strong></p><p>并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！</p><p><strong>注意：</strong> finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!</p><p><strong>GC Roots 到底是什么东西呢，哪些对象可以作为 GC Root 呢？</strong></p><ul><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p></li><li><p>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>便于记忆，称他为两栈两方法！下面我们一一介绍一下：</p><p>1、虚拟机栈中引用的对象</p><p>如下代码所示，a 是栈帧中的本地变量，当 a &#x3D; null 时，由于此时 a 充当了 <strong>GC Root</strong> 的作用，a 与原来指向的实例 <strong>new Test()</strong> 断开了连接，所以对象会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">publicclass Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、方法区中类静态属性引用的对象</p><p>如下代码所示，当栈帧中的本地变量 a &#x3D; null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">a.s = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、方法区中常量引用的对象</p><p>如下代码所示，常量 s 指向的对象并不会因为 a 指向的对象被回收而回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    a = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、本地方法栈中 JNI 引用的对象</p><p>这是简单给不清楚本地方法为何物的童鞋简单解释一下：所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 Java 实现的，可能由 C 或 Python等其他语言实现的， Java 通过 JNI 来调用本地方法， 而本地方法是以库文件的形式存放的（在 WINDOWS 平台上是 DLL 文件形式，在 UNIX 机器上是 SO 文件形式）。通过调用本地的库文件的内部方法，使 JAVA 可以实现和本地机器的紧密联系，调用系统级的各接口方法，还是不明白？见文末参考，对本地方法定义与使用有详细介绍。</p><p>当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p><img src="/2023/05/23/%E8%AF%B4%E2%BC%80%E4%B8%8BJVM%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%85%B1%E4%BA%AB%E5%8C%BA%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-root/05/23/%E8%AF%B4%E2%BC%80%E4%B8%8BJVM%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%85%B1%E4%BA%AB%E5%8C%BA%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-root/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9PeXdleXNDU2VMVXJZcVBpY2pWd2p1TUNoUHJQaWNOSGRYdWhiZDlIQ0xCSVlSQmVrUXFpY3M3WEJyajB2VlVWU1BUSFRpYkpidXRyZEdSV2liMU1sRGQxNkpRLzY0MA" class title="img"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL Java_com_pecuyu_jnirefdemo_MainActivity_newStringNative(JNIEnv *env, jobject instance，jstring jmsg) &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">   // 缓存String的class</span><br><span class="line"></span><br><span class="line">   jclass jc = (*env)-&gt;FindClass(env, STRING_PATH);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，当 java 调用以上本地方法时，jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用，因此只会在此本地方法执行完成后才会被释放。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
            <tag> gcRoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你们项目如何排查JVM问题</title>
      <link href="/2023/05/23/%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5JVM%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/23/%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5JVM%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一、对于还在正常运行的系统"><a href="#一、对于还在正常运行的系统" class="headerlink" title="一、对于还在正常运行的系统"></a>一、对于还在正常运行的系统</h1><p>1、可以使用jmap来查看JVM中各个区域的使用情况。</p><p>2、可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现了死锁。</p><p>3、可以通过jstat命令来查看垃圾回收的情况，特别是fullgc比较频繁，那么就得进行调优了。</p><p>4、通过各个命令的结果，或者jvisualvm等工具来进行分析。</p><p>5、首先，初步猜测频繁fullgc的原因，如果频繁发生fullgc但是又一直没有出现内存溢出，那么表示fullgc实际上是回收了很多对象，所以这些对象最好能在younggc过程中直接回收掉，避免这些对象进入到老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入到老年代，尝试加大年轻代的大小，如果改完之后，fullgc减小，则说明修改有效。</p><p>6、同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存。</p><h1 id="二、对于已经发生了OOM的系统"><a href="#二、对于已经发生了OOM的系统" class="headerlink" title="二、对于已经发生了OOM的系统"></a>二、对于已经发生了OOM的系统</h1><p>1、一般生产系统中都会设置当系统发生了OOM时，生成当时的dump文件（-XX:+HeadDumpOnOutOfMemoryError -XX:HeadDumpPath&#x3D;&#x2F;usr&#x2F;local&#x2F;base）</p><p>2、我们可以利用jsisualvm等工具来分析dump文件</p><p>3、根据dump文件找到异常的实例对象，和异常的线程（占用CPU高），定位到具体的代码</p><p>4、然后再进行详细的分析和调试</p><h1 id="JVM-究竟需不需要调优？"><a href="#JVM-究竟需不需要调优？" class="headerlink" title="JVM 究竟需不需要调优？"></a>JVM 究竟需不需要调优？</h1><p>JVM 经过这么多年的发展和验证，整体是非常健壮的。个人认为99%的情况下，基本用不到 JVM 调优。</p><p>通常来说，我们的 JVM 参数配置大多还是会遵循 JVM 官方的建议，例如：</p><ul><li>-XX:NewRatio&#x3D;2，年轻代:老年代&#x3D;1:2</li><li>-XX:SurvivorRatio&#x3D;8，eden:survivor&#x3D;8:1</li><li>堆内存设置为物理内存的3&#x2F;4左右</li><li>等等</li></ul><p>JVM 参数的默认（推荐）值都是经过 JVM 团队的反复测试和前人的充分验证得出的比较合理的值，因此通常来说是比较靠谱和通用的，一般不会出大问题。</p><p>当然，更重要的是，大部分的应用 QPS 都不到10，数据量不到几万，这种低压环境下，想让 JVM 出问题，说实话也挺难的。</p><img src="/2023/05/23/%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5JVM%E9%97%AE%E9%A2%98/05/23/%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5JVM%E9%97%AE%E9%A2%98/v2-f983ea90573f9499a401b09a639a4325_720w.webp" class title="img"><p>大部分同学更常遇到的应该是自己的代码 bug 导致 OOM、CPU load高、GC频繁啥的，这些场景也基本都是代码修复即可，通常不需要动 JVM。</p><p>当然，俗话说得好，凡事无绝对，还是有一小部分场景，是可能需要用到 JVM 调优的。具体哪些场景，我们在下面介绍。</p><p>值得一提的是，我们这边所说的 JVM 调优更多的是针对自己的业务场景对 JVM 参数进行优化调整，使其更适合我们的业务，而不是指对 JVM 源码的改动。</p><h1 id="JVM-调优没有什么必要，使用性能更好的垃圾回收器就能解决问题了？"><a href="#JVM-调优没有什么必要，使用性能更好的垃圾回收器就能解决问题了？" class="headerlink" title="JVM 调优没有什么必要，使用性能更好的垃圾回收器就能解决问题了？**"></a>JVM 调优没有什么必要，使用性能更好的垃圾回收器就能解决问题了？**</h1><p>这是我在网上看到的一个说法，因为赞同的人比较多，我估计有不少同学也会有这个想法，因此在这边谈下自己的看法。</p><p><strong>1）实战角度</strong></p><p>不考虑应付面试的因素，升级垃圾回收器确实会是最有效的方式之一，例如：CMS 升级到 G1，甚至 ZGC。</p><p>这个很容易理解，更高版本的垃圾回收器相当于是 JVM 开发人员对 JVM 做的优化，人家毕竟是专门做这个的，所以通常来说升级高版本的性能会有不少的提升。</p><p>G1 目前已经有开始在逐渐应用开来，周围有不少团队在 JDK8 中使用了 G1，就我了解到的，还是存在不少问题的，不少同学在不断进行参数的调整，而在 JDK11 中能优化成啥样还有待验证。</p><p>ZGC 目前应用的还比较少，仅从对外公布的数据来看很好看，最大暂停时间不超过10ms，甚至是1ms，大家都抱有很高的期望。但是从目前我收集到的一些资料来看，ZGC 也并不是银弹，已知的明显问题有：</p><ul><li>吞吐量相较于 G1 会有所下降，官方称最大不超过15%</li><li>ZGC如果遇到非常高的对象分配速率（allocation rate）的话会跟不上，目前唯一有效的“调优”方式就是增大整个GC堆的大小来让ZGC有更大的喘息空间——R大与ZGC领队沟通后的原话</li></ul><p>而且，随着后续 ZGC 应用开来，后续一定会不断出现更多问题的。</p><p>整体而言，个人觉得 JVM 调优在某些场景下还是有必要的，毕竟有句话叫：没有最好的，只有最合适的。</p><p><strong>2）面试角度</strong></p><p>如果你回答直接升级垃圾收集器，面试官可能也赞同，但是这个话题可能就这样结束了，面试官大概率没听到他想要的回答，你在这题的肯定拿不到加分，甚至可能会被扣分。</p><p>所以，在面试的时候，你可以回答升级垃圾收集器，但是你不能只回答升级垃圾收集器。</p><h1 id="JVM-何时优化？"><a href="#JVM-何时优化？" class="headerlink" title="JVM 何时优化？"></a>JVM 何时优化？</h1><p>忌过早优化。《计算机程序设计艺术》的作者高德纳（Donald Ervin Knuth）曾说过一句经典的话：</p><blockquote><p>The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.<br>真正的问题是，程序猿在错误的地方和错误的时间花了太多的时间担心效率问题；过早的优化是编程中所有（或者至少是大部分）罪恶的根源。</p></blockquote><p>忌过早并不是说就完全不管，比较正确的做法应该是给核心服务的一些重要 JVM 指标配上监控告警，当指标出现波动或者异常时，能及时介入排查。</p><p><strong>面试官：JVM 有哪些核心指标？合理范围应该是多少？</strong></p><p>这个问题没有统一的答案，因为每个服务对AVG&#x2F;TP999&#x2F;TP9999等性能指标的要求是不同的，因此合理的范围也不同。</p><p>为了防止面试官追问，对于普通的 Java 后端应用来说，我这边给出一份相对合理的范围值。以下指标都是对于单台服务器来说：</p><ul><li>jvm.gc.time：每分钟的GC耗时在1s以内，500ms以内尤佳</li><li>jvm.gc.meantime：每次YGC耗时在100ms以内，50ms以内尤佳</li><li>jvm.fullgc.count：FGC最多几小时1次，1天不到1次尤佳</li><li>jvm.fullgc.time：每次FGC耗时在1s以内，500ms以内尤佳</li></ul><p>通常来说，只要这几个指标正常，其他的一般不会有问题，如果其他地方出了问题，一般都会影响到这几个指标。</p><h1 id="JVM-优化步骤？"><a href="#JVM-优化步骤？" class="headerlink" title="JVM 优化步骤？"></a>JVM 优化步骤？</h1><p><strong>4.1、分析和定位当前系统的瓶颈</strong></p><p>对于JVM的核心指标，我们的关注点和常用工具如下：</p><p><strong>1）CPU指标</strong></p><ul><li>查看占用CPU最多的进程</li><li>查看占用CPU最多的线程</li><li>查看线程堆栈快照信息</li><li>分析代码执行热点</li><li>查看哪个代码占用CPU执行时间最长</li><li>查看每个方法占用CPU时间比例</li></ul><p>常见的命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 显示系统各个进程的资源使用情况</span><br><span class="line">top</span><br><span class="line">// 查看某个进程中的线程占用情况</span><br><span class="line">top -Hp pid</span><br><span class="line">// 查看当前 Java 进程的线程堆栈信息</span><br><span class="line">jstack pid</span><br></pre></td></tr></table></figure><p>常见的工具：JProfiler、JVM Profiler、Arthas等。</p><p><strong>2）JVM 内存指标</strong></p><ul><li>查看当前 JVM 堆内存参数配置是否合理</li><li>查看堆中对象的统计信息</li><li>查看堆存储快照，分析内存的占用情况</li><li>查看堆各区域的内存增长是否正常</li><li>查看是哪个区域导致的GC</li><li>查看GC后能否正常回收到内存</li></ul><p>常见的命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 查看当前的 JVM 参数配置</span><br><span class="line">ps -ef | grep java</span><br><span class="line">// 查看 Java 进程的配置信息，包括系统属性和JVM命令行标志</span><br><span class="line">jinfo pid</span><br><span class="line">// 输出 Java 进程当前的 gc 情况</span><br><span class="line">jstat -gc pid</span><br><span class="line">// 输出 Java 堆详细信息</span><br><span class="line">jmap -heap pid</span><br><span class="line">// 显示堆中对象的统计信息</span><br><span class="line">jmap -histo:live pid</span><br><span class="line">// 生成 Java 堆存储快照dump文件</span><br><span class="line">jmap -F -dump:format=b,file=dumpFile.phrof pid</span><br></pre></td></tr></table></figure><p>常见的工具：Eclipse MAT、JConsole等。</p><p><strong>3）JVM GC指标</strong></p><ul><li>查看每分钟GC时间是否正常</li><li>查看每分钟YGC次数是否正常</li><li>查看FGC次数是否正常</li><li>查看单次FGC时间是否正常</li><li>查看单次GC各阶段详细耗时，找到耗时严重的阶段</li><li>查看对象的动态晋升年龄是否正常</li></ul><p>JVM 的 GC指标一般是从 GC 日志里面查看，默认的 GC 日志可能比较少，我们可以添加以下参数，来丰富我们的GC日志输出，方便我们定位问题。</p><p>GC日志常用 JVM 参数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 打印GC的详细信息</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">// 打印GC的时间戳</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">// 在GC前后打印堆信息</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">// 打印Survivor区中各个年龄段的对象的分布信息</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line">// JVM启动时输出所有参数值，方便查看参数是否被覆盖</span><br><span class="line">-XX:+PrintFlagsFinal</span><br><span class="line">// 打印GC时应用程序的停止时间</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line">// 打印在GC期间处理引用对象的时间（仅在PrintGCDetails时启用）</span><br><span class="line">-XX:+PrintReferenceGC</span><br></pre></td></tr></table></figure><p>以上就是我们定位系统瓶颈的常用手段，大部分问题通过以上方式都能定位出问题原因，然后结合代码去找到问题根源。</p><p><strong>4.2、确定优化目标</strong></p><p>定位出系统瓶颈后，在优化前先制定好优化的目标是什么，例如：</p><ul><li>将FGC次数从每小时1次，降低到1天1次</li><li>将每分钟的GC耗时从3s降低到500ms</li><li>将每次FGC耗时从5s降低到1s以内</li><li>…</li></ul><p><strong>4.3、制订优化方案</strong></p><p>针对定位出的系统瓶颈制定相应的优化方案，常见的有：</p><ul><li>代码bug：升级修复bug。典型的有：死循环、使用无界队列。</li><li>不合理的JVM参数配置：优化 JVM 参数配置。典型的有：年轻代内存配置过小、堆内存配置过小、元空间配置过小。</li></ul><p><strong>4.4、对比优化前后的指标，统计优化效果</strong></p><p><strong>4.5、持续观察和跟踪优化效果</strong></p><p><strong>4.6、如果还需要的话，重复以上步骤</strong></p><h1 id="调优案例：metaspace导致频繁FGC问题"><a href="#调优案例：metaspace导致频繁FGC问题" class="headerlink" title="调优案例：metaspace导致频繁FGC问题"></a>调优案例：metaspace导致频繁FGC问题</h1><p>以下案例来源于网络或本人真实经验，皆能自圆其说，理解掌握后同学们皆可拿来与面试官对线。</p><p><strong>服务环境：</strong>ParNew + CMS + JDK8</p><p><strong>问题现象</strong>：服务频繁出现FGC</p><p><strong>原因分析</strong>：</p><p>1）首先查看GC日志，发现出现FGC的原因是metaspace空间不够</p><p>对应GC日志：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Full GC (Metadata GC Threshold)</span><br></pre></td></tr></table></figure><p>2）进一步查看日志发现元空间存在内存碎片化现象</p><p>对应GC日志：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Metaspace       used 35337K, capacity 56242K, committed 56320K, reserved 1099776K</span><br></pre></td></tr></table></figure><p>这边简单解释下这几个参数的意义</p><ul><li>used ：已使用的空间大小</li><li>capacity：当前已经分配且未释放的空间容量大小</li><li>committed：当前已经分配的空间大小</li><li>reserved：预留的空间大小</li></ul><p>这边 used 比较容易理解，reserved 在本例不重要可以先忽略，主要是 capacity 和 committed 这2个容易搞混。</p><p>结合下图来看更容易理解，元空间的分配以 chunk 为单位，当一个 ClassLoader 被垃圾回收时，所有属于它的空间（chunk）被释放，此时该 chunk 称为 Free Chunk，而 committed chunk 就是 capacity chunk 和 free chunk 之和。</p><img src="/2023/05/23/%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5JVM%E9%97%AE%E9%A2%98/05/23/%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5JVM%E9%97%AE%E9%A2%98/v2-dc19b7f178ecd1fb19c51ce8ea96c4da_720w.webp" class title="img"><p>之所以说内存存在碎片化现象就是根据 used 和 capacity 的数据得来的，上面说了元空间的分配以 chunk 为单位，即使一个 ClassLoader 只加载1个类，也会独占整个 chunk，所以当出现 used 和 capacity 两者之差较大的时候，说明此时存在内存碎片化的情况。</p><p>GC日志demo如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">0</span> (full <span class="number">0</span>):</span><br><span class="line"> par <span class="keyword">new</span> generation   total <span class="number">314560</span>K, used <span class="number">141123</span>K [<span class="number">0x00000000c0000000</span>, <span class="number">0x00000000d5550000</span>, <span class="number">0x00000000d5550000</span>)</span><br><span class="line">  eden space <span class="number">279616</span>K,  <span class="number">50</span>% used [<span class="number">0x00000000c0000000</span>, <span class="number">0x00000000c89d0d00</span>, <span class="number">0x00000000d1110000</span>)</span><br><span class="line">  from space <span class="number">34944</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000d1110000</span>, <span class="number">0x00000000d1110000</span>, <span class="number">0x00000000d3330000</span>)</span><br><span class="line">  to   space <span class="number">34944</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000d3330000</span>, <span class="number">0x00000000d3330000</span>, <span class="number">0x00000000d5550000</span>)</span><br><span class="line"> concurrent mark-sweep generation total <span class="number">699072</span>K, used <span class="number">0</span>K [<span class="number">0x00000000d5550000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used <span class="number">35337</span>K, capacity <span class="number">56242</span>K, committed <span class="number">56320</span>K, reserved <span class="number">1099776</span>K</span><br><span class="line">  <span class="keyword">class</span> space    used <span class="number">4734</span>K, capacity <span class="number">8172</span>K, committed <span class="number">8172</span>K, reserved <span class="number">1048576</span>K</span><br><span class="line"><span class="number">1.448</span>: [Full <span class="built_in">GC</span> (Metadata GC Threshold) <span class="number">1.448</span>: [CMS: <span class="number">0</span>K-&gt;<span class="number">10221</span>K(<span class="number">699072</span>K), <span class="number">0.0487207</span> secs] <span class="number">141123</span>K-&gt;<span class="number">10221</span>K(<span class="number">1013632</span>K), [Metaspace: <span class="number">35337</span>K-&gt;<span class="number">35337</span>K(<span class="number">1099776</span>K)], <span class="number">0.0488547</span> secs] [Times: user=<span class="number">0.09</span> sys=<span class="number">0.00</span>, real=<span class="number">0.05</span> secs] </span><br><span class="line">Heap after GC invocations=<span class="number">1</span> (full <span class="number">1</span>):</span><br><span class="line"> par <span class="keyword">new</span> generation   total <span class="number">314560</span>K, used <span class="number">0</span>K [<span class="number">0x00000000c0000000</span>, <span class="number">0x00000000d5550000</span>, <span class="number">0x00000000d5550000</span>)</span><br><span class="line">  eden space <span class="number">279616</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000c0000000</span>, <span class="number">0x00000000c0000000</span>, <span class="number">0x00000000d1110000</span>)</span><br><span class="line">  from space <span class="number">34944</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000d1110000</span>, <span class="number">0x00000000d1110000</span>, <span class="number">0x00000000d3330000</span>)</span><br><span class="line">  to   space <span class="number">34944</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000d3330000</span>, <span class="number">0x00000000d3330000</span>, <span class="number">0x00000000d5550000</span>)</span><br><span class="line"> concurrent mark-sweep generation total <span class="number">699072</span>K, used <span class="number">10221</span>K [<span class="number">0x00000000d5550000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used <span class="number">35337</span>K, capacity <span class="number">56242</span>K, committed <span class="number">56320</span>K, reserved <span class="number">1099776</span>K</span><br><span class="line">  <span class="keyword">class</span> space    used <span class="number">4734</span>K, capacity <span class="number">8172</span>K, committed <span class="number">8172</span>K, reserved <span class="number">1048576</span>K</span><br><span class="line">&#125;</span><br><span class="line">&#123;Heap before GC invocations=<span class="number">1</span> (full <span class="number">1</span>):</span><br><span class="line"> par <span class="keyword">new</span> generation   total <span class="number">314560</span>K, used <span class="number">0</span>K [<span class="number">0x00000000c0000000</span>, <span class="number">0x00000000d5550000</span>, <span class="number">0x00000000d5550000</span>)</span><br><span class="line">  eden space <span class="number">279616</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000c0000000</span>, <span class="number">0x00000000c0000000</span>, <span class="number">0x00000000d1110000</span>)</span><br><span class="line">  from space <span class="number">34944</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000d1110000</span>, <span class="number">0x00000000d1110000</span>, <span class="number">0x00000000d3330000</span>)</span><br><span class="line">  to   space <span class="number">34944</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000d3330000</span>, <span class="number">0x00000000d3330000</span>, <span class="number">0x00000000d5550000</span>)</span><br><span class="line"> concurrent mark-sweep generation total <span class="number">699072</span>K, used <span class="number">10221</span>K [<span class="number">0x00000000d5550000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used <span class="number">35337</span>K, capacity <span class="number">56242</span>K, committed <span class="number">56320</span>K, reserved <span class="number">1099776</span>K</span><br><span class="line">  <span class="keyword">class</span> space    used <span class="number">4734</span>K, capacity <span class="number">8172</span>K, committed <span class="number">8172</span>K, reserved <span class="number">1048576</span>K</span><br><span class="line"><span class="number">1.497</span>: [Full <span class="built_in">GC</span> (Last ditch collection) <span class="number">1.497</span>: [CMS: <span class="number">10221</span>K-&gt;<span class="number">3565</span>K(<span class="number">699072</span>K), <span class="number">0.0139783</span> secs] <span class="number">10221</span>K-&gt;<span class="number">3565</span>K(<span class="number">1013632</span>K), [Metaspace: <span class="number">35337</span>K-&gt;<span class="number">35337</span>K(<span class="number">1099776</span>K)], <span class="number">0.0193983</span> secs] [Times: user=<span class="number">0.03</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">Heap after GC invocations=<span class="number">2</span> (full <span class="number">2</span>):</span><br><span class="line"> par <span class="keyword">new</span> generation   total <span class="number">314560</span>K, used <span class="number">0</span>K [<span class="number">0x00000000c0000000</span>, <span class="number">0x00000000d5550000</span>, <span class="number">0x00000000d5550000</span>)</span><br><span class="line">  eden space <span class="number">279616</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000c0000000</span>, <span class="number">0x00000000c0000000</span>, <span class="number">0x00000000d1110000</span>)</span><br><span class="line">  from space <span class="number">34944</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000d1110000</span>, <span class="number">0x00000000d1110000</span>, <span class="number">0x00000000d3330000</span>)</span><br><span class="line">  to   space <span class="number">34944</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000d3330000</span>, <span class="number">0x00000000d3330000</span>, <span class="number">0x00000000d5550000</span>)</span><br><span class="line"> concurrent mark-sweep generation total <span class="number">699072</span>K, used <span class="number">3565</span>K [<span class="number">0x00000000d5550000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used <span class="number">17065</span>K, capacity <span class="number">22618</span>K, committed <span class="number">35840</span>K, reserved <span class="number">1079296</span>K</span><br><span class="line">  <span class="keyword">class</span> space    used <span class="number">1624</span>K, capacity <span class="number">2552</span>K, committed <span class="number">8172</span>K, reserved <span class="number">1048576</span>K</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元空间主要适用于存放类的相关信息，而存在内存碎片化说明很可能创建了较多的类加载器，同时使用率较低。</p><p>因此，当元空间出现内存碎片化时，我们会着重关注是不是创建了大量的类加载器。</p><p>3）通过 dump 堆存储文件发现存在大量 DelegatingClassLoader</p><p>通过进一步分析，发现是由于反射导致创建大量 DelegatingClassLoader。其核心原理如下：</p><p>在 JVM 上，最初是通过 JNI 调用来实现方法的反射调用，当 JVM 注意到通过反射经常访问某个方法时，它将生成字节码来执行相同的操作，称为膨胀（inflation）机制。如果使用字节码的方式，则会为该方法生成一个 DelegatingClassLoader，如果存在大量方法经常反射调用，则会导致创建大量 DelegatingClassLoader。</p><p><strong>反射调用频次达到多少才会从 JNI 转字节码？</strong></p><p>默认是15次，可通过参数 -Dsun.reflect.inflationThreshold 进行控制，在小于该次数时会使用 JNI 的方式对方法进行调用，如果调用次数超过该次数就会使用字节码的方式生成方法调用。</p><p><strong>分析结论</strong>：反射调用导致创建大量 DelegatingClassLoader，占用了较大的元空间内存，同时存在内存碎片化现象，导致元空间利用率不高，从而较快达到阈值，触发 FGC。</p><p><strong>优化策略：</strong></p><p>1）适当调大 metaspace 的空间大小。</p><p>2）优化不合理的反射调用。例如最常见的属性拷贝工具类 BeanUtils.copyProperties 可以使用 mapstruct 替换。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当被面试官问到 JVM 调优时，完全可以按照本文的脉络回答：</p><ul><li>首先表态如果使用合理的 JVM 参数配置，在大多数情况应该是不需要调优的——对应本文第1题</li><li>其次说明可能还是存在少量场景需要调优，我们可以对一些 JVM 核心指标配置监控告警，当出现波动时人为介入分析评估——对应本文第3题</li><li>最后举一个实际的调优例子来加以说明——对应本文第5题</li></ul><p>如果面试官反问怎么分析排查的，则可以使用本文第4题的常用命令和工具来与之对线。</p><p>这一套流程下来，我相信大部分面试官都会对你印象不错。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java jvm jvm调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于死锁以及如何查看线程是否有死锁</title>
      <link href="/2023/05/23/%E5%85%B3%E4%BA%8E%E6%AD%BB%E9%94%81%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%9C%89%E6%AD%BB%E9%94%81/"/>
      <url>/2023/05/23/%E5%85%B3%E4%BA%8E%E6%AD%BB%E9%94%81%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%9C%89%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>在 Java 的并发编程中，有一个问题需要特别注意，那就是死锁，如果发生了死锁，基本就是重启，而重启将会丢失运行中的数据。所以，了解死锁的形成并排查死锁到预防死锁成了一个重要的问题。</p><h1 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> cn.sxt.game;    </span><br><span class="line">  <span class="comment">/* 死锁</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          Object o1=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">          Object o2=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">          Thread t1=<span class="keyword">new</span> <span class="title class_">MyThread1</span>(o1,o2);</span><br><span class="line">          Thread t2=<span class="keyword">new</span> <span class="title class_">MyThread2</span>(o1,o2);</span><br><span class="line">          t1.setName(<span class="string">&quot;t1&quot;</span>);<span class="comment">//给线程起名字t1</span></span><br><span class="line">          t2.setName(<span class="string">&quot;t2&quot;</span>);<span class="comment">//给线程起名字t2</span></span><br><span class="line">          t1.start();</span><br><span class="line">          t2.start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">      Object o1;</span><br><span class="line">      Object o2;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">MyThread1</span><span class="params">(Object o1,Object o2)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.o1=o1;</span><br><span class="line">          <span class="built_in">this</span>.o2=o2;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;获取资源1&quot;</span>);</span><br><span class="line">                  sleep(<span class="number">1000</span>);<span class="comment">// 等待 1 秒让另一个线程拿到锁</span></span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">synchronized</span> (o2)&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread2</span><span class="params">(Object o1,Object o2)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.o1=o1;</span><br><span class="line">        <span class="built_in">this</span>.o2=o2;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取资源2&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1000</span>);<span class="comment">// 等待 1 秒让另一个线程拿到锁</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​这里面的代码中，我们启用了两个线程，分别抢占2个资源，但这两个资源又分别被不同的对象（字符串）锁住了。当第一个线程，进入同步块，拿到o1锁，并等待 1 秒钟去拿o2锁，当第二个线程进入同步块后，拿到o2锁，并等待 1 秒钟去拿o1锁，注意：此时， 拿着 o1 锁的线程企图拿到 o2 的锁，但这个时候，拿着 o2 的线程也想去拿o1 的锁。于是就出现了互相僵持的情况，谁也无法拿到对方的锁，整个系统就卡死了。</p><p>这种情况就是死锁。</p><p>像我们现在写的代码是自己故意造出来的死锁，我们能够发现，那如果是线上环境怎么办，假如我们的系统卡死了，我们怎么知道到底是哪一段代码出现了问题，有没有可能使死锁的问题。也就是如何检测死锁。</p><h1 id="如何检测死锁？"><a href="#如何检测死锁？" class="headerlink" title="如何检测死锁？"></a>如何检测死锁？</h1><p>由于死锁极难通过人工的方式查出来，因此JDK 提供了命令来检测某个java进程中心线程的情况，并排查有没有死锁。 jps , 用来查看java 程序的进程号，当然在 Linux 中也可以通过别的方式获取， jstack 进程号命令则可以答应对应进程的栈信息，并找到死锁。<br>在<strong>windows使用jps的命令</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\16047&gt;<span class="title">jps</span></span></span><br><span class="line"><span class="function">    1488 <span class="title">Jps</span></span></span><br><span class="line"><span class="function">    3028 <span class="title">Launcher</span></span></span><br><span class="line"><span class="function">    9188 <span class="title">DeadLock</span></span></span><br><span class="line"><span class="function">    2632</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\16047&gt;<span class="title">jstack</span> 9188</span></span><br><span class="line"><span class="function">2020-04-14 09:05:35</span></span><br><span class="line"><span class="function"><span class="title">Full</span> <span class="title">thread</span> <span class="title">dump</span> <span class="title">Java</span> <span class="title">HotSpot</span>(<span class="title">TM</span>) 64-<span class="title">Bit</span> <span class="title">Server</span> <span class="title">VM</span> (13.0.1+9 <span class="title">mixed</span> <span class="title">mode</span>, <span class="title">sharing</span>):</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Threads</span> <span class="title">class</span> <span class="title">SMR</span> <span class="title">info</span>:</span></span><br><span class="line"><span class="function"><span class="title">_java_thread_list</span>=0<span class="title">x00000254ffd7b290</span>, <span class="title">length</span>=13, <span class="title">elements</span>=&#123;</span></span><br><span class="line"><span class="function">0<span class="title">x00000254ffa11000</span>, 0<span class="title">x00000254ffa14800</span>, 0<span class="title">x00000254ffa37000</span>, 0<span class="title">x00000254ffa38000</span>,</span></span><br><span class="line"><span class="function">0<span class="title">x00000254ffa39800</span>, 0<span class="title">x00000254ffae1000</span>, 0<span class="title">x00000254ffa42800</span>, 0<span class="title">x00000254ff9f5800</span>,</span></span><br><span class="line"><span class="function">0<span class="title">x00000254ffced800</span>, 0<span class="title">x00000254ffcf7000</span>, 0<span class="title">x00000254ffd04800</span>, 0<span class="title">x00000254ffd3f800</span>,</span></span><br><span class="line"><span class="function">0<span class="title">x00000254f8011800</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">Reference</span> <span class="title">Handler</span>&quot; #2 <span class="title">daemon</span> <span class="title">prio</span>=10 <span class="title">os_prio</span>=2 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.48<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffa11000</span> <span class="title">nid</span>=0<span class="title">x28e4</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span>  [0<span class="title">x00000065b3afe000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">RUNNABLE</span></span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.lang.ref.Reference.waitForReferencePendingList</span>(<span class="title">java.base</span>@13.0.1/<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.lang.ref.Reference.processPendingReferences</span>(<span class="title">java.base</span>@13.0.1/<span class="title">Reference.java</span>:241)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.lang.ref.Reference</span>$<span class="title">ReferenceHandler.run</span>(<span class="title">java.base</span>@13.0.1/<span class="title">Reference.java</span>:213)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">Finalizer</span>&quot; #3 <span class="title">daemon</span> <span class="title">prio</span>=8 <span class="title">os_prio</span>=1 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.48<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffa14800</span> <span class="title">nid</span>=0<span class="title">x4204</span> <span class="title">in</span> <span class="title">Object.wait</span>()  [0<span class="title">x00000065b3bfe000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">WAITING</span> (<span class="title">on</span> <span class="title">object</span> <span class="title">monitor</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.lang.Object.wait</span>(<span class="title">java.base</span>@13.0.1/<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">- <span class="title">waiting</span> <span class="title">on</span> &lt;0<span class="title">x0000000089d0aec8</span>&gt; (<span class="title">a</span> <span class="title">java.lang.ref.ReferenceQueue</span>$<span class="title">Lock</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.lang.ref.ReferenceQueue.remove</span>(<span class="title">java.base</span>@13.0.1/<span class="title">ReferenceQueue.java</span>:155)</span></span><br><span class="line"><span class="function">- <span class="title">locked</span> &lt;0<span class="title">x0000000089d0aec8</span>&gt; (<span class="title">a</span> <span class="title">java.lang.ref.ReferenceQueue</span>$<span class="title">Lock</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.lang.ref.ReferenceQueue.remove</span>(<span class="title">java.base</span>@13.0.1/<span class="title">ReferenceQueue.java</span>:176)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.lang.ref.Finalizer</span>$<span class="title">FinalizerThread.run</span>(<span class="title">java.base</span>@13.0.1/<span class="title">Finalizer.java</span>:170)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">Signal</span> <span class="title">Dispatcher</span>&quot; #4 <span class="title">daemon</span> <span class="title">prio</span>=9 <span class="title">os_prio</span>=2 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.46<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffa37000</span> <span class="title">nid</span>=0<span class="title">x181c</span> <span class="title">runnable</span>  [0<span class="title">x0000000000000000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">RUNNABLE</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">Attach</span> <span class="title">Listener</span>&quot; #5 <span class="title">daemon</span> <span class="title">prio</span>=5 <span class="title">os_prio</span>=2 <span class="title">cpu</span>=31.25<span class="title">ms</span> <span class="title">elapsed</span>=108.46<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffa38000</span> <span class="title">nid</span>=0<span class="title">x2bb4</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span>  [0<span class="title">x0000000000000000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">RUNNABLE</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">C2</span> <span class="title">CompilerThread0</span>&quot; #6 <span class="title">daemon</span> <span class="title">prio</span>=9 <span class="title">os_prio</span>=2 <span class="title">cpu</span>=62.50<span class="title">ms</span> <span class="title">elapsed</span>=108.46<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffa39800</span> <span class="title">nid</span>=0<span class="title">x25c0</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span>  [0<span class="title">x0000000000000000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">RUNNABLE</span></span></span><br><span class="line"><span class="function"><span class="title">No</span> <span class="title">compile</span> <span class="title">task</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">C1</span> <span class="title">CompilerThread0</span>&quot; #9 <span class="title">daemon</span> <span class="title">prio</span>=9 <span class="title">os_prio</span>=2 <span class="title">cpu</span>=46.88<span class="title">ms</span> <span class="title">elapsed</span>=108.46<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffae1000</span> <span class="title">nid</span>=0<span class="title">x2988</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span>  [0<span class="title">x0000000000000000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">RUNNABLE</span></span></span><br><span class="line"><span class="function"><span class="title">No</span> <span class="title">compile</span> <span class="title">task</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">Sweeper</span> <span class="title">thread</span>&quot; #10 <span class="title">daemon</span> <span class="title">prio</span>=9 <span class="title">os_prio</span>=2 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.46<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffa42800</span> <span class="title">nid</span>=0<span class="title">x3ce8</span> <span class="title">runnable</span>  [0<span class="title">x0000000000000000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">RUNNABLE</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">Common</span>-<span class="title">Cleaner</span>&quot; #11 <span class="title">daemon</span> <span class="title">prio</span>=8 <span class="title">os_prio</span>=1 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.44<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ff9f5800</span> <span class="title">nid</span>=0<span class="title">x3b78</span> <span class="title">in</span> <span class="title">Object.wait</span>()  [0<span class="title">x00000065b41fe000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">on</span> <span class="title">object</span> <span class="title">monitor</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.lang.Object.wait</span>(<span class="title">java.base</span>@13.0.1/<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">- <span class="title">waiting</span> <span class="title">on</span> &lt;0<span class="title">x0000000089db21c0</span>&gt; (<span class="title">a</span> <span class="title">java.lang.ref.ReferenceQueue</span>$<span class="title">Lock</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.lang.ref.ReferenceQueue.remove</span>(<span class="title">java.base</span>@13.0.1/<span class="title">ReferenceQueue.java</span>:155)</span></span><br><span class="line"><span class="function">- <span class="title">locked</span> &lt;0<span class="title">x0000000089db21c0</span>&gt; (<span class="title">a</span> <span class="title">java.lang.ref.ReferenceQueue</span>$<span class="title">Lock</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">jdk.internal.ref.CleanerImpl.run</span>(<span class="title">java.base</span>@13.0.1/<span class="title">CleanerImpl.java</span>:148)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.lang.Thread.run</span>(<span class="title">java.base</span>@13.0.1/<span class="title">Thread.java</span>:830)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">jdk.internal.misc.InnocuousThread.run</span>(<span class="title">java.base</span>@13.0.1/<span class="title">InnocuousThread.java</span>:134)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">Monitor</span> <span class="title">Ctrl</span>-<span class="title">Break</span>&quot; #12 <span class="title">daemon</span> <span class="title">prio</span>=5 <span class="title">os_prio</span>=0 <span class="title">cpu</span>=15.63<span class="title">ms</span> <span class="title">elapsed</span>=108.36<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffced800</span> <span class="title">nid</span>=0<span class="title">x2a38</span> <span class="title">runnable</span>  [0<span class="title">x00000065b43fe000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">RUNNABLE</span></span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">sun.nio.ch.SocketDispatcher.read0</span>(<span class="title">java.base</span>@13.0.1/<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">sun.nio.ch.SocketDispatcher.read</span>(<span class="title">java.base</span>@13.0.1/<span class="title">SocketDispatcher.java</span>:46)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">sun.nio.ch.NioSocketImpl.tryRead</span>(<span class="title">java.base</span>@13.0.1/<span class="title">NioSocketImpl.java</span>:262)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">sun.nio.ch.NioSocketImpl.implRead</span>(<span class="title">java.base</span>@13.0.1/<span class="title">NioSocketImpl.java</span>:313)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">sun.nio.ch.NioSocketImpl.read</span>(<span class="title">java.base</span>@13.0.1/<span class="title">NioSocketImpl.java</span>:351)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">sun.nio.ch.NioSocketImpl</span>$1.<span class="title">read</span>(<span class="title">java.base</span>@13.0.1/<span class="title">NioSocketImpl.java</span>:802)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.net.Socket</span>$<span class="title">SocketInputStream.read</span>(<span class="title">java.base</span>@13.0.1/<span class="title">Socket.java</span>:937)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">sun.nio.cs.StreamDecoder.readBytes</span>(<span class="title">java.base</span>@13.0.1/<span class="title">StreamDecoder.java</span>:297)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">sun.nio.cs.StreamDecoder.implRead</span>(<span class="title">java.base</span>@13.0.1/<span class="title">StreamDecoder.java</span>:339)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">sun.nio.cs.StreamDecoder.read</span>(<span class="title">java.base</span>@13.0.1/<span class="title">StreamDecoder.java</span>:188)</span></span><br><span class="line"><span class="function">- <span class="title">locked</span> &lt;0<span class="title">x0000000089b125a0</span>&gt; (<span class="title">a</span> <span class="title">java.io.InputStreamReader</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.io.InputStreamReader.read</span>(<span class="title">java.base</span>@13.0.1/<span class="title">InputStreamReader.java</span>:185)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.io.BufferedReader.fill</span>(<span class="title">java.base</span>@13.0.1/<span class="title">BufferedReader.java</span>:161)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.io.BufferedReader.readLine</span>(<span class="title">java.base</span>@13.0.1/<span class="title">BufferedReader.java</span>:326)</span></span><br><span class="line"><span class="function">- <span class="title">locked</span> &lt;0<span class="title">x0000000089b125a0</span>&gt; (<span class="title">a</span> <span class="title">java.io.InputStreamReader</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">java.io.BufferedReader.readLine</span>(<span class="title">java.base</span>@13.0.1/<span class="title">BufferedReader.java</span>:392)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">com.intellij.rt.execution.application.AppMainV2</span>$1.<span class="title">run</span>(<span class="title">AppMainV2.java</span>:64)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">Service</span> <span class="title">Thread</span>&quot; #13 <span class="title">daemon</span> <span class="title">prio</span>=9 <span class="title">os_prio</span>=0 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.36<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffcf7000</span> <span class="title">nid</span>=0<span class="title">x42b4</span> <span class="title">runnable</span>  [0<span class="title">x0000000000000000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">RUNNABLE</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">t1</span>&quot; #14 <span class="title">prio</span>=5 <span class="title">os_prio</span>=0 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.35<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffd04800</span> <span class="title">nid</span>=0<span class="title">x3384</span> <span class="title">waiting</span> <span class="title">for</span> <span class="title">monitor</span> <span class="title">entry</span>  [0<span class="title">x00000065b46fe000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">BLOCKED</span> (<span class="title">on</span> <span class="title">object</span> <span class="title">monitor</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">cn.sxt.game.MyThread1.run</span>(<span class="title">DeadLock.java</span>:36)</span></span><br><span class="line"><span class="function">- <span class="title">waiting</span> <span class="title">to</span> <span class="title">lock</span> &lt;0<span class="title">x0000000089ccb560</span>&gt; (<span class="title">a</span> <span class="title">java.lang.Object</span>)</span></span><br><span class="line"><span class="function">- <span class="title">locked</span> &lt;0<span class="title">x0000000089ccb550</span>&gt; (<span class="title">a</span> <span class="title">java.lang.Object</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">t2</span>&quot; #15 <span class="title">prio</span>=5 <span class="title">os_prio</span>=0 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.35<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffd3f800</span> <span class="title">nid</span>=0<span class="title">x3c18</span> <span class="title">waiting</span> <span class="title">for</span> <span class="title">monitor</span> <span class="title">entry</span>  [0<span class="title">x00000065b47ff000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">BLOCKED</span> (<span class="title">on</span> <span class="title">object</span> <span class="title">monitor</span>)</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">cn.sxt.game.MyThread2.run</span>(<span class="title">DeadLock.java</span>:59)</span></span><br><span class="line"><span class="function">- <span class="title">waiting</span> <span class="title">to</span> <span class="title">lock</span> &lt;0<span class="title">x0000000089ccb550</span>&gt; (<span class="title">a</span> <span class="title">java.lang.Object</span>)</span></span><br><span class="line"><span class="function">- <span class="title">locked</span> &lt;0<span class="title">x0000000089ccb560</span>&gt; (<span class="title">a</span> <span class="title">java.lang.Object</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">DestroyJavaVM</span>&quot; #16 <span class="title">prio</span>=5 <span class="title">os_prio</span>=0 <span class="title">cpu</span>=156.25<span class="title">ms</span> <span class="title">elapsed</span>=108.35<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254f8011800</span> <span class="title">nid</span>=0<span class="title">x2780</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span>  [0<span class="title">x0000000000000000</span>]</span></span><br><span class="line"><span class="function"><span class="title">java.lang.Thread.State</span>: <span class="title">RUNNABLE</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">VM</span> <span class="title">Thread</span>&quot; <span class="title">os_prio</span>=2 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.48<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffa10000</span> <span class="title">nid</span>=0<span class="title">x2544</span> <span class="title">runnable</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">GC</span> <span class="title">Thread</span>#0&quot; <span class="title">os_prio</span>=2 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.49<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254f8055800</span> <span class="title">nid</span>=0<span class="title">x117c</span> <span class="title">runnable</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">G1</span> <span class="title">Main</span> <span class="title">Marker</span>&quot; <span class="title">os_prio</span>=2 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.49<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254f8066800</span> <span class="title">nid</span>=0<span class="title">x3098</span> <span class="title">runnable</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">G1</span> <span class="title">Conc</span>#0&quot; <span class="title">os_prio</span>=2 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.49<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254f8068800</span> <span class="title">nid</span>=0<span class="title">x24e4</span> <span class="title">runnable</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">G1</span> <span class="title">Refine</span>#0&quot; <span class="title">os_prio</span>=2 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.49<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ff88a800</span> <span class="title">nid</span>=0<span class="title">x127c</span> <span class="title">runnable</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;<span class="title">G1</span> <span class="title">Young</span> <span class="title">RemSet</span> <span class="title">Sampling</span>&quot; <span class="title">os_prio</span>=2 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.49<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ff88c000</span> <span class="title">nid</span>=0<span class="title">x1900</span> <span class="title">runnable</span></span></span><br><span class="line"><span class="function">&quot;<span class="title">VM</span> <span class="title">Periodic</span> <span class="title">Task</span> <span class="title">Thread</span>&quot; <span class="title">os_prio</span>=2 <span class="title">cpu</span>=0.00<span class="title">ms</span> <span class="title">elapsed</span>=108.36<span class="title">s</span> <span class="title">tid</span>=0<span class="title">x00000254ffcfa800</span> <span class="title">nid</span>=0<span class="title">x230c</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">JNI</span> <span class="title">global</span> <span class="title">refs</span>: 16, <span class="title">weak</span> <span class="title">refs</span>: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 找到一个死锁</span></span><br><span class="line"><span class="function"><span class="title">Found</span> <span class="title">one</span> <span class="title">Java</span>-<span class="title">level</span> <span class="title">deadlock</span>:</span></span><br><span class="line"><span class="function">=============================</span></span><br><span class="line"><span class="function">&quot;<span class="title">t1</span>&quot;:</span></span><br><span class="line"><span class="function"><span class="title">waiting</span> <span class="title">to</span> <span class="title">lock</span> <span class="title">monitor</span> 0<span class="title">x00000254ffa1df00</span> (<span class="title">object</span> 0<span class="title">x0000000089ccb560</span>, <span class="title">a</span> <span class="title">java.lang.Object</span>),</span></span><br><span class="line"><span class="function"><span class="title">which</span> <span class="title">is</span> <span class="title">held</span> <span class="title">by</span> &quot;<span class="title">t2</span>&quot;</span></span><br><span class="line"><span class="function">&quot;<span class="title">t2</span>&quot;:</span></span><br><span class="line"><span class="function"><span class="title">waiting</span> <span class="title">to</span> <span class="title">lock</span> <span class="title">monitor</span> 0<span class="title">x00000254ffa1dd00</span> (<span class="title">object</span> 0<span class="title">x0000000089ccb550</span>, <span class="title">a</span> <span class="title">java.lang.Object</span>),</span></span><br><span class="line"><span class="function"><span class="title">which</span> <span class="title">is</span> <span class="title">held</span> <span class="title">by</span> &quot;<span class="title">t1</span>&quot;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Java</span> <span class="title">stack</span> <span class="title">information</span> <span class="title">for</span> <span class="title">the</span> <span class="title">threads</span> <span class="title">listed</span> <span class="title">above</span>:</span></span><br><span class="line"><span class="function">===================================================</span></span><br><span class="line"><span class="function">&quot;<span class="title">t1</span>&quot;:</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">cn.sxt.game.MyThread1.run</span>(<span class="title">DeadLock.java</span>:36)</span></span><br><span class="line"><span class="function">// 等待 0<span class="title">x0000000089ccb560</span> 锁</span></span><br><span class="line"><span class="function">- <span class="title">waiting</span> <span class="title">to</span> <span class="title">lock</span> &lt;0<span class="title">x0000000089ccb560</span>&gt; (<span class="title">a</span> <span class="title">java.lang.Object</span>)</span></span><br><span class="line"><span class="function">//持有0<span class="title">x0000000089ccb550</span> 锁</span></span><br><span class="line"><span class="function">- <span class="title">locked</span> &lt;0<span class="title">x0000000089ccb550</span>&gt; (<span class="title">a</span> <span class="title">java.lang.Object</span>)</span></span><br><span class="line"><span class="function">&quot;<span class="title">t2</span>&quot;:</span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">cn.sxt.game.MyThread2.run</span>(<span class="title">DeadLock.java</span>:59)</span></span><br><span class="line"><span class="function">//等待0<span class="title">x0000000089ccb550</span> 锁</span></span><br><span class="line"><span class="function">- <span class="title">waiting</span> <span class="title">to</span> <span class="title">lock</span> &lt;0<span class="title">x0000000089ccb550</span>&gt; (<span class="title">a</span> <span class="title">java.lang.Object</span>)</span></span><br><span class="line"><span class="function">// 持有 0<span class="title">x0000000089ccb560</span> 锁</span></span><br><span class="line"><span class="function">- <span class="title">locked</span> &lt;0<span class="title">x0000000089ccb560</span>&gt; (<span class="title">a</span> <span class="title">java.lang.Object</span>)</span></span><br><span class="line"><span class="function">//发现一个死锁</span></span><br><span class="line"><span class="function"><span class="title">Found</span> 1 <span class="title">deadlock</span>.</span></span><br></pre></td></tr></table></figure><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1  waiting to lock &lt;<span class="number">0</span>x0000000089ccb560&gt;locked &lt;<span class="number">0</span>x0000000089ccb550&gt;</span><br><span class="line">t2  waiting to lock &lt;<span class="number">0</span>x0000000089ccb550&gt;locked &lt;<span class="number">0</span>x0000000089ccb560&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们首先使用 jps 命令找到 java 进程号，然后使用 jstack 进程号 打印进程栈的信息，其中，在最后的部分，jstack 告诉我们，他找到了一个死锁，其中又详细的信息：t1 线程（这里我们已经给线程起名字为t1，通常情况下，给线程起一个合适的名字将更有利于排查）持有Object类型的编号为 0x0000000089ccb550 的锁，等待编号为 0x0000000089ccb560 的锁 ， 但这个锁由 t2 持有，于此同时，t1 和 t2 相反。t2 线程持有 0x0000000089ccb560 的锁，等待 0x0000000089ccb550 的锁。我们的注释里也写上了。</p><p>那么发生了死锁，该怎么办呢？最简单的办法就是重启，重启之后，对 jstack 中打印的堆栈信息中的代码进行修改。重新发布。当然还有一些高级策略，比如让进程回滚到死锁前的状态，然后让他们顺序进入同步块。</p><h1 id="死锁有哪些形成的原因"><a href="#死锁有哪些形成的原因" class="headerlink" title="死锁有哪些形成的原因"></a>死锁有哪些形成的原因</h1><p>一般来说，要出现死锁问题需要满足以下条件：</p><p>互斥条件：一个资源每次只能被一个线程使用。</p><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</p><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>死锁是由四个必要条件导致的，所以一般来说，只要破坏这四个必要条件中的一个条件，死锁情况就应该不会发生。<br>我们在编程的时候尽量避免发生死锁，如果出现死锁可以使用 jstack 命令查看线程是否有死锁。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程之间如何进⾏通讯的</title>
      <link href="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/"/>
      <url>/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1、为什么需要线程通信"><a href="#1、为什么需要线程通信" class="headerlink" title="1、为什么需要线程通信"></a><strong>1、为什么需要线程通信</strong></h2><p>线程是操作系统调度的最小单位，有自己的栈空间，可以按照既定的代码逐步的执行，但是如果每个线程间都孤立的运行，那就会造资源浪费。所以在现实中，我们需要这些线程间可以按照指定的规则共同完成一件任务，所以这些线程之间就需要互相协调，这个过程被称为线程的通信。</p><p>线程的通信可以被定义为：</p><blockquote><p>线程通信就是当多个线程共同操作共享的资源时，互相告知自己的状态以避免资源争夺。</p></blockquote><h2 id="2、线程通信的方式"><a href="#2、线程通信的方式" class="headerlink" title="2、线程通信的方式"></a><strong>2、线程通信的方式</strong></h2><p>线程通信主要可以分为三种方式，分别为<strong>共享内存</strong>、<strong>消息传递</strong>和<strong>管道流</strong>。每种方式有不同的方法来实现</p><ul><li>共享内存：线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式通信。</li></ul><blockquote><p>volatile共享内存</p></blockquote><ul><li>消息传递：线程之间没有公共的状态，线程之间必须通过明确的发送信息来显示的进行通信。</li></ul><blockquote><p>wait&#x2F;notify等待通知方式<br>join方式</p></blockquote><ul><li>管道流</li></ul><blockquote><p>管道输入&#x2F;输出流的形式</p></blockquote><h3 id="2-1共享内存"><a href="#2-1共享内存" class="headerlink" title="2.1共享内存"></a><strong>2.1共享内存</strong></h3><p>在学习Volatile之前，我们先了解下Java的内存模型，</p><img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-347345d6926e3a1dfc81126bad653c2d_720w.webp" class title="img"><p>在java中，所有堆内存中的所有的数据（实例域、静态域和数组元素）存放在主内存中可以在线程之间共享，一些局部变量、方法中定义的参数存放在本地内存中不会在线程间共享。线程之间的共享变量存储在主内存中，本地内存存储了共享变量的副本。如果线程A要和线程B通信，则需要经过以下步骤</p><blockquote><p>①线程A把本地内存A更新过的共享变量刷新到主内存中<br>②线程B到内存中去读取线程A之前已更新过的共享变量。</p></blockquote><p>这保证了线程间的通信必须经过主内存。下面引出我们要学习的关键字<strong>volatile</strong></p><p>volatile有一个关键的特性：保证内存可见性，即多个线程访问内存中的同一个被volatile关键字修饰的变量时，当某一个线程修改完该变量后，需要先将这个最新修改的值写回到主内存，从而保证下一个读取该变量的线程取得的就是主内存中该数据的最新值，这样就保证线程之间的透明性，便于线程通信。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Simon Lang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/5 15:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">                        flag=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：线程A和线程B交替执行</p><img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-8b019fb2a574d808b018bc76892d4b38_720w.webp" class title="img"><h3 id="2-2消息传递"><a href="#2-2消息传递" class="headerlink" title="2.2消息传递"></a><strong>2.2消息传递</strong></h3><h3 id="2-2-1wait-x2F-notify等待通知方式"><a href="#2-2-1wait-x2F-notify等待通知方式" class="headerlink" title="2.2.1wait&#x2F;notify等待通知方式"></a>2.2.1wait&#x2F;notify等待通知方式</h3><p>从字面上理解，等待通知机制就是将处于等待状态的线程将由其它线程发出通知后重新获取CPU资源，继续执行之前没有执行完的任务。最典型的例子生产者–消费者模式</p><img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-871a224a8559dfba4f751656453f996d_720w.webp" class title="img"><p>有一个产品队列，生产者想要在队列中添加产品，消费者需要从队列中取出产品，如果队列为空，消费者应该等待生产者添加产品后才进行消费，队列为满时，生产者需要等待消费者消费一部分产品后才能继续生产。队列可以认为是java模型里的临界资源，生产者和消费者认为是不同的线程，它们需要交替的占用临界资源来进行各自方法的执行，所以就需要线程间通信。</p><p>生产者–消费者模型主要为了方便复用和解耦，java语言实现线程之间的通信协作的方式是等待&#x2F;通知机制</p><p>等待&#x2F;通知机制提供了三个方法用于线程间的通信</p><p><strong>wait()当前线程释放锁并进入等待(阻塞)状态</strong>notify()唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后继续竞争锁notifyAll()唤醒所有正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后继续竞争锁</p><p>等待&#x2F;通知机制是指一个线程A调用了对象Object的wait()方法进入等待状态，而另一线程B调用了对象Object的notify()或者notifyAll()方法，当线程A收到通知后就可以从对象Object的wait()方法返回，进而执行后序的操作。线程间的通信需要对象Object来完成，对象中的wait()、notify()、notifyAll()方法就如同开关信号，用来完成等待方和通知方的交互。</p><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">static</span> Object lock=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       Thread waitThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitThread</span>(),<span class="string">&quot;WaitThread&quot;</span>);</span><br><span class="line">       waitThread.start();</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">       Thread notifyThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">NotifyThread</span>(),<span class="string">&quot;NotifyThread&quot;</span>);</span><br><span class="line">       notifyThread.start();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//等待线程</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="comment">//加锁</span></span><br><span class="line">           <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">               <span class="comment">//条件不满足时，继续等待，同时释放lock锁</span></span><br><span class="line">               <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;flag为true，不满足条件，继续等待&quot;</span>);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       lock.wait();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//条件满足</span></span><br><span class="line">               System.out.println(<span class="string">&quot;flag为false，我要从wait状态返回继续执行了&quot;</span>);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//通知线程</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotifyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="comment">//加锁</span></span><br><span class="line">           <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">               <span class="comment">//获取lock锁，然后进行通知，但不会立即释放lock锁，需要该线程执行完毕</span></span><br><span class="line">               lock.notifyAll();</span><br><span class="line">               System.out.println(<span class="string">&quot;设置flag为false,我发出通知了，但是我不会立马释放锁&quot;</span>);</span><br><span class="line">               flag=<span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-c7ba75ae87a07c84a40a9e9d053f4ece_720w.webp" class title="img"><p><strong>NOTE</strong>：使用wait()、notify()和notifyAll()需要注意以下细节</p><ul><li>使用wait()、notify()和notifyAll()需要先调用对象加锁</li><li>调用wait()方法后，线程状态由Running变成Waiting，并将当前线程放置到对象的等待队列</li><li>notify()和notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()和notifyAll()的线程释放锁之后等待线程才有机会从wait()返回</li><li>notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部转移到同步队列，被移到的线程状态由Waiting变为Blocked。</li><li>从wait()方法返回的前提是获得调用对象的锁</li></ul><p>其实等待通知机制有有一个经典的范式，该范式可以分为两部分，分别是等待方（消费者）和通知方（生产者）</p><ul><li>等待方</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line"><span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">对象.wait()</span><br><span class="line">&#125;</span><br><span class="line">对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通知方</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">改变条件</span><br><span class="line">对象.notifyAll</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2join方式"><a href="#2-2-2join方式" class="headerlink" title="2.2.2join方式"></a>2.2.2join方式</h3><p>在很多应用场景中存在这样一种情况，主线程创建并启动子线程后，如果子线程要进行很耗时的计算，那么主线程将比子线程先结束，但是主线程需要子线程的计算的结果来进行自己下一步的计算，这时主线程就需要等待子线程，java中提供可join()方法解决这个问题。</p><p>join()方法的作用是：在当前线程A调用线程B的join()方法后，会让当前线程A阻塞，直到线程B的逻辑执行完成，A线程才会解除阻塞，然后继续执行自己的业务逻辑，这样做可以节省计算机中资源。</p><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程0开始执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            JoinThread jt=<span class="keyword">new</span> <span class="title class_">JoinThread</span>(thread,i);</span><br><span class="line">            jt.start();</span><br><span class="line">            thread=jt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JoinThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">JoinThread</span><span class="params">(Thread thread,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.thread=thread;</span><br><span class="line">            <span class="built_in">this</span>.i=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-0399a18ecdba2fc75eeb9bdf4cb2b95f_720w.webp" class title="img"><p><strong>NOTE</strong>：每个线程的终止的前提是前驱线程的终止，每个线程等待前驱线程终止后，才从join方法返回，实际上，这里涉及了等待&#x2F;通知机制，即下一个线程的执行需要接受前驱线程结束的通知。</p><h3 id="2-3管道输入-x2F-输出流"><a href="#2-3管道输入-x2F-输出流" class="headerlink" title="2.3管道输入&#x2F;输出流"></a><strong>2.3管道输入&#x2F;输出流</strong></h3><p>管道流是是一种使用比较少的线程间通信方式，管道输入&#x2F;输出流和普通文件输入&#x2F;输出流或者网络输出&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，传输的媒介为管道。</p><p>管道输入&#x2F;输出流主要包括4种具体的实现：PipedOutputStrean、PipedInputStrean、PipedReader和PipedWriter，前两种面向字节，后两种面向字符。</p><p>java的管道的输入和输出实际上使用的是一个循环缓冲数组来实现的，默认为1024，输入流从这个数组中读取数据，输出流从这个数组中写入数据，当这个缓冲数组已满的时候，输出流所在的线程就会被阻塞，当向这个缓冲数组为空时，输入流所在的线程就会被阻塞。</p><img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-2d66bec02a173901042d5a7a8758f910_720w.webp" class title="img"><blockquote><p>buffer：缓冲数组，默认为1024<br>out：从缓冲数组中读数据<br>in：从缓冲数组中写数据</p></blockquote><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPip</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PipedWriter</span> <span class="variable">writer</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedWriter</span>();</span><br><span class="line">        <span class="type">PipedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedReader</span>();</span><br><span class="line">        <span class="comment">//使用connect方法将输入流和输出流连接起来</span></span><br><span class="line">        writer.connect(reader);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(reader) , <span class="string">&quot;PrintThread&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程printThread</span></span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//读取输入的内容</span></span><br><span class="line">            <span class="keyword">while</span>((receive = System.in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                writer.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader reader;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Print</span><span class="params">(PipedReader reader)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.reader = reader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = reader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//字符转换</span></span><br><span class="line">                    System.out.print((<span class="type">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.print(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><img src="/2023/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/05/23/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E2%BE%8F%E9%80%9A%E8%AE%AF%E7%9A%84/v2-c41f942b2334033655a44371ea0fe480_720w.webp" class title="img"><p><strong>NOTE</strong>：对于Piped类型的流，必须先进性绑定，也就是调用connect()方法，如果没有将输入&#x2F;输出流绑定起来，对于该流的访问将抛出异常。</p><p>如果有什么疑问可以联系我，（公众号有我的联系方式）让我们每天一起每天进步一点点</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务原理</title>
      <link href="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring事务原理一探"><a href="#Spring事务原理一探" class="headerlink" title="Spring事务原理一探"></a><strong>Spring事务原理一探</strong></h2><p>概括来讲，事务是一个由有限操作集合组成的逻辑单元。事务操作包含两个目的，数据一致以及操作隔离。数据一致是指事务提交时保证事务内的所有操作都成功完成，并且更改永久生效；事务回滚时，保证能够恢复到事务执行之前的状态。操作隔离则是指多个同时执行的事务之间应该相互独立，互不影响。</p><p>事务是一个比较广泛的概念，事务管理资源除了我们熟知的数据库外，还可以包含消息队列、文件系统等。当然，一般来说，我们说的事务单指“数据库事务”。接下来我们会以MySQL数据库、Spring声明式事务为主要研究对象，但是很多事务概念、接口抽象和实现方式同时适用于其他情况。</p><h2 id="事务属性和行为"><a href="#事务属性和行为" class="headerlink" title="事务属性和行为"></a><strong>事务属性和行为</strong></h2><p><strong>ACID属性</strong></p><p>提到事务，不可避免需要涉及到事务的ACID属性：</p><ul><li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。</li></ul><p>我们将严格遵循ACID属性的事务称为<strong>刚性事务</strong>。与之相对，期望最终一致性，在事务执行的中间状态允许暂时不遵循ACID属性的事务称为<strong>柔性事务</strong>，可参考<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/ab1a1c6b08a1">传统事务与柔性事务</a>，柔性事务的使用涉及到<strong>分布式事务</strong>方案，可以后续扩展，这里我们先将注意集中在事务实现原理上。</p><p><strong>隔离级别</strong></p><p>根据SQL92标准，MySQL的InnoDB引擎提供四种<strong>隔离级别</strong>（即ACID中的I）：读未提交（READ UNCOMMITTED）、读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）和串行化（SERIALIZABLE），InnoDB默认的隔离级别是<code>REPEATABLE READ</code>，其可避免<em>脏读</em>和<em>不可重复读</em>，但不能避免<em>幻读</em>，需要指出的是，InnoDB引擎的多版本并发控制机制（MVCC）并没有完全避免<em>幻读</em>，关于该问题以及隔离级别说明，可参考<a href="https://link.zhihu.com/?target=http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">MySQL的InnoDB的幻读问题</a>。</p><p><strong>传播机制</strong></p><p>Spring针对方法嵌套调用时事务的创建行为定义了七种<strong>事务传播机制</strong>，分别是PROPAGATION_REQUIRED、PROPAGATION_SUPPORT、PROPAGATION_MANDATORY、PROPAGATION_REQUIRES_NEW、PROPAGATION_NOT_SUPPORTED、PROPAGATION_NEVER以及PROPAGATION_NESTED，基本上从字面意思就能知道每种传播机制各自的行为表现，Spring默认的事务传播机制是<code>PROPAGATION_REQUIRED</code>，即如果当前存在事务，则使用当前事务，否则创建新的事务。详情可参考<a href="https://link.zhihu.com/?target=https://juejin.im/post/5ae9639af265da0b926564e7">Spring事务传播行为</a>。</p><p><strong>事务行为</strong></p><p>事务的行为包括事务开启、事务提交和事务回滚。InnoDB所有的用户SQL执行都在事务控制之内，在默认情况下，<strong>autocommit</strong>设置为<code>true</code>，单条SQL执行成功后，MySQL会自动提交事务，或者如果SQL执行出错，则根据异常类型执行事务提交或者回滚。可以使用<code>START TRANSACTION</code>（SQL标准）或者<code>BEGIN</code>开启事务，使用<code>COMMIT</code>和<code>ROLLBACK</code>提交和回滚事务；也可以通过设置autocommit属性来控制事务行为，当设置autocommit为<code>false</code>时，其后执行的多条SQL语句将在一个事务内，直到执行<code>COMMIT</code>或者<code>ROLLBACK</code>事务才会提交或者回滚。</p><h2 id="AOP增强"><a href="#AOP增强" class="headerlink" title="AOP增强"></a><strong>AOP增强</strong></h2><p>Spring使用<strong>AOP</strong>（面向切面编程）来实现<strong>声明式事务</strong>，后续在讲Spring事务具体实现的时候会详细说明，关于AOP的概念可参考<a href="https://link.zhihu.com/?target=https://blog.csdn.net/qukaiwei/article/details/50367761">Spring AOP概念理解（通俗易懂）</a>，这里不再细说。说下<strong>动态代理</strong>和<strong>AOP增强</strong>。</p><p>动态代理是Spring实现AOP的默认方式，分为两种：<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong>。JDK动态代理面向接口，通过反射生成目标代理接口的匿名实现类；CGLIB动态代理则通过继承，使用字节码增强技术（或者<code>objenesis</code>类库）为目标代理类生成代理子类。Spring默认对接口实现使用JDK动态代理，对具体类使用CGLIB，同时也支持配置全局使用CGLIB来生成代理对象。</p><p>我们在切面配置中会使用到<code>@Aspect</code>注解，这里用到了<strong>Aspectj</strong>的切面表达式。Aspectj是java语言实现的一个AOP框架，使用静态代理模式，拥有完善的AOP功能，与Spring AOP互为补充。Spring采用了Aspectj强大的切面表达式定义方式，但是默认情况下仍然使用动态代理方式，并未使用Aspectj的编译器和织入器，当然也支持配置使用Aspectj静态代理替代动态代理方式。Aspectj功能更强大，比方说它支持对字段、POJO类进行增强，与之相对，Spring只支持对Bean方法级别进行增强。</p><p>Spring对方法的增强有五种方式：</p><ul><li>前置增强（<code>org.springframework.aop.BeforeAdvice</code>）：在目标方法执行之前进行增强；</li><li>后置增强（<code>org.springframework.aop.AfterReturningAdvice</code>）：在目标方法执行之后进行增强；</li><li>环绕增强（<code>org.aopalliance.intercept.MethodInterceptor</code>）：在目标方法执行前后都执行增强；</li><li>异常抛出增强（<code>org.springframework.aop.ThrowsAdvice</code>）：在目标方法抛出异常后执行增强；</li><li>引介增强（<code>org.springframework.aop.IntroductionInterceptor</code>）：为目标类添加新的方法和属性。</li></ul><p>声明式事务的实现就是通过环绕增强的方式，在目标方法执行之前开启事务，在目标方法执行之后提交或者回滚事务，事务拦截器的继承关系图可以体现这一点：</p><img src="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/v2-e1b27f9e03b55e4695b72177d3fc60d8_720w.webp" class title="img"><h2 id="Spring事务抽象"><a href="#Spring事务抽象" class="headerlink" title="Spring事务抽象"></a>Spring事务抽象</h2><p>统一一致的事务抽象是Spring框架的一大优势，无论是全局事务还是本地事务，JTA、JDBC、Hibernate还是JPA，Spring都使用统一的编程模型，使得应用程序可以很容易地在全局事务与本地事务，或者不同的事务框架之间进行切换。下图是Spring事务抽象的核心类图：</p><img src="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/v2-ff9900cb40f07db75d1190628f464564_720w.webp" class title="img"><p>接口<code>PlatformTransactionManager</code>定义了事务操作的行为，其依赖<code>TransactionDefinition</code>和<code>TransactionStatus</code>接口，其实大部分的事务属性和行为我们以MySQL数据库为例已经有过了解，这里再对应介绍下。</p><ul><li><code>PlatformTransactionManager</code>：事务管理器</li><li><code>getTransaction</code>方法：事务获取操作，根据事务属性定义，获取当前事务或者创建新事物；</li><li><code>commit</code>方法：事务提交操作，注意这里所说的提交并非直接提交事务，而是根据当前事务状态执行提交或者回滚操作；</li><li><code>rollback</code>方法：事务回滚操作，同样，也并非一定直接回滚事务，也有可能只是标记事务为只读，等待其他调用方执行回滚。</li><li><code>TransactionDefinition</code>：事务属性定义</li><li><code>getPropagationBehavior</code>方法：返回事务的传播属性，默认是<code>PROPAGATION_REQUIRED</code>；</li><li><code>getIsolationLevel</code>方法：返回事务隔离级别，事务隔离级别只有在创建新事务时才有效，也就是说只对应传播属性<code>PROPAGATION_REQUIRED</code>和<code>PROPAGATION_REQUIRES_NEW</code>；</li><li><code>getTimeout</code>方法：返回事务超时时间，以秒为单位，同样只有在创建新事务时才有效；</li><li><code>isReadOnly</code>方法：是否优化为只读事务，支持这项属性的事务管理器会将事务标记为只读，只读事务不允许有写操作，不支持只读属性的事务管理器需要忽略这项设置，这一点跟其他事务属性定义不同，针对其他不支持的属性设置，事务管理器应该抛出异常。</li><li><code>getName</code>方法：返回事务名称，声明式事务中默认值为“类的完全限定名.方法名”。</li><li><code>TransactionStatus</code>：当前事务状态</li><li><code>isNewTransaction</code>方法：当前方法是否创建了新事务（区别于使用现有事务以及没有事务）；</li><li><code>hasSavepoint</code>方法：在嵌套事务场景中，判断当前事务是否包含保存点；</li><li><code>setRollbackOnly</code>和<code>isRollbackOnly</code>方法：只读属性设置（主要用于标记事务，等待回滚）和查询；</li><li><code>flush</code>方法：刷新底层会话中的修改到数据库，一般用于刷新如Hibernate&#x2F;JPA的会话，是否生效由具体事务资源实现决定；</li><li><code>isCompleted</code>方法：判断当前事务是否已完成（已提交或者已回滚）。</li></ul><p>部分Spring包含的对<code>PlatformTransactionManager</code>的实现类如下图所示：</p><img src="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/v2-d3e4c3f534dd8a1981f972d429e2c982_720w.webp" class title="img"><p><code>AbstractPlatformTransactionManager</code>抽象类实现了Spring事务的标准流程，其子类<code>DataSourceTransactionManager</code>是我们使用较多的JDBC单数据源事务管理器，而<code>JtaTransactionManager</code>是JTA（Java Transaction API）规范的实现类，另外两个则分别是JavaEE容器<em>WebLogic</em>和<em>WebSphere</em>的JTA事务管理器的具体实现。</p><h2 id="Spring事务切面"><a href="#Spring事务切面" class="headerlink" title="Spring事务切面"></a>Spring事务切面</h2><p>之前提到，Spring采用AOP来实现声明式事务，那么事务的AOP切面是如何织入的呢？这一点涉及到AOP动态代理对象的生成过程。</p><p>代理对象生成的核心类是<code>AbstractAutoProxyCreator</code>，实现了<code>BeanPostProcessor</code>接口，会在<strong>Bean初始化完成之后</strong>，通过<code>postProcessAfterInitialization</code>方法生成代理对象，关于<code>BeanPostProcessor</code>在Bean生命周期中的作用，可参考<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/xrq730/p/5721366.html">一些常用的Spring扩展接口</a>。</p><p>看一下<code>AbstractAutoProxyCreator</code>类的核心代码，主要关注三个方法：postProcessAfterInitialization、wrapIfNecessary和createProxy，为了突出核心流程，以注释代替了部分代码的具体实现，后续的源码分析也采用相同的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 创建代理对象</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数检查，跳过已经执行过代理对象生成，或者已知的不需要生成代理对象的Bean</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    <span class="comment">// 查询当前Bean所有的AOP增强配置，最终是通过AOPUtils工具类实现</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 执行AOP织入，创建代理对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">        <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化代理工厂类</span></span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当全局使用动态代理时，设置是否需要对目标Bean强制使用CGLIB动态代理</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建AOP增强顾问，包含框架公共增强和应用程序自定义增强</span></span><br><span class="line">    <span class="comment">// 设置proxyFactory属性，如增强、目标类、是否允许变更等</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是通过调用<code>ProxyFactory#getProxy(java.lang.ClassLoader)</code>方法来创建代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProxyFactory.class</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProxyFactory父类ProxyCreatorSupport.class</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyCreatorSupport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.aopProxyFactory = <span class="keyword">new</span> <span class="title class_">DefaultAopProxyFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ProxyFactory</code>的父类构造器实例化了<code>DefaultAopProxyFactory</code>类，从其源代码我们可以看到Spring动态代理方式选择策略的实现：如果目标类optimize，proxyTargetClass属性设置为<code>true</code>或者未指定需要代理的接口，则使用CGLIB生成代理对象，否则使用JDK动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">AopProxyFactory</span>, Serializable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">        <span class="comment">// 如果optimize，proxyTargetClass属性设置为true或者未指定代理接口，则使用CGLIB生成代理对象</span></span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="comment">// 参数检查，targetClass为空抛出异常</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 目标类本身是接口或者代理对象，仍然使用JDK动态代理</span></span><br><span class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Objenesis是一个可以不通过构造器创建子类的java工具类库</span></span><br><span class="line">            <span class="comment">// 作为Spring 4.0后CGLIB的默认实现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则使用JDK动态代理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring事务拦截"><a href="#Spring事务拦截" class="headerlink" title="Spring事务拦截"></a>Spring事务拦截</h2><p>我们已经了解了AOP切面织入生成代理对象的过程，当Bean方法通过代理对象调用时，会触发对应的AOP增强拦截器，前面提到声明式事务是一种环绕增强，对应接口为<code>MethodInterceptor</code>，事务增强对该接口的实现为<code>TransactionInterceptor</code>，类图如下：</p><img src="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/v2-8abdb6f84a52c95957d22497b7a9c248_720w.webp" class title="img"><p>事务拦截器<code>TransactionInterceptor</code>在<code>invoke</code>方法中，通过调用父类<code>TransactionAspectSupport</code>的<code>invokeWithinTransaction</code>方法进行事务处理，该方法支持声明式事务和编程式事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionInterceptor.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 获取targetClass</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> <span class="title class_">InvocationCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 实际执行目标方法</span></span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransactionInterceptor父类TransactionAspectSupport.class</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">    <span class="comment">// 查询目标方法事务属性、确定事务管理器、构造连接点标识（用于确认事务名称）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// 事务获取</span></span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过回调执行目标方法</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 目标方法执行抛出异常，根据异常类型执行事务提交或者回滚操作</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理当前线程事务信息</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标方法执行成功，提交事务</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 带回调的事务执行处理，一般用于编程式事务</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在讲Spring事务抽象时，有提到事务抽象的核心接口为<code>PlatformTransactionManager</code>，它负责管理事务行为，包括事务的获取、提交和回滚。在<code>invokeWithinTransaction</code>方法中，我们可以看到<code>createTransactionIfNecessary</code>、<code>commitTransactionAfterReturning</code>和<code>completeTransactionAfterThrowing</code>都是针对该接口编程，并不依赖于特定事务管理器，这里是对Spring事务抽象的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TransactionAspectSupport.class</span></span><br><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(</span></span><br><span class="line"><span class="params">        PlatformTransactionManager tm, TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取事务</span></span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commitTransactionAfterReturning</span><span class="params">(TransactionInfo txInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">completeTransactionAfterThrowing</span><span class="params">(TransactionInfo txInfo, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 异常类型为回滚异常，执行事务回滚</span></span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 异常类型为非回滚异常，仍然执行事务提交</span></span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TransactionInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>另外，在获取事务时，<code>AbstractPlatformTransactionManager#doBegin</code>方法负责开启新事务，在<code>DataSourceTransactionManager</code>有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数据库连接con</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">        txObject.setMustRestoreAutoCommit(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Switching JDBC Connection [&quot;</span> + con + <span class="string">&quot;] to manual commit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里才真正开启了数据库事务。</p><h2 id="Spring事务同步"><a href="#Spring事务同步" class="headerlink" title="Spring事务同步"></a>Spring事务同步</h2><p>提到事务传播机制时，我们经常提到一个条件“如果当前已有事务”，那么Spring是如何知道当前是否已经开启了事务呢？在<code>AbstractPlatformTransactionManager</code>中是这样做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPlatformTransactionManager.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line">    <span class="comment">// 参数为null时构造默认值</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前事务对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title function_">doGetTransaction</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前事务对象是否包含活跃事务</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isExistingTransaction</span><span class="params">(Object transaction)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>getTransaction</code>方法是<code>final</code>的，无法被子类覆盖，保证了获取事务流程的一致和稳定。抽象方法<code>doGetTransaction</code>获取当前事务对象，方法<code>isExistingTransaction</code>判断当前事务对象是否存在活跃事务，具体逻辑由特定事务管理器实现，看下我们使用最多的<code>DataSourceTransactionManager</code>对应的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataSourceTransactionManager.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doGetTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionObject</span>();</span><br><span class="line">    txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">    <span class="type">ConnectionHolder</span> <span class="variable">conHolder</span> <span class="operator">=</span></span><br><span class="line">            (ConnectionHolder) TransactionSynchronizationManager.getResource(<span class="built_in">this</span>.dataSource);</span><br><span class="line">    txObject.setConnectionHolder(conHolder, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isExistingTransaction</span><span class="params">(Object transaction)</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line">    <span class="keyword">return</span> (txObject.hasConnectionHolder() &amp;&amp; txObject.getConnectionHolder().isTransactionActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，获取当前事务对象时，使用了<code>TransactionSynchronizationManager#getResource</code>方法，类图如下：</p><img src="/2023/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/05/23/Spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/v2-102f07dd273c2a9e093ea4dec88c18c5_720w.webp" class title="img"><p><code>TransactionSynchronizationManager</code>通过<code>ThreadLocal</code>对象在当前线程记录了<code>resources</code>和<code>synchronizations</code>属性。<code>resources</code>是一个HashMap，用于记录当前参与事务的事务资源，方便进行事务同步，在<code>DataSourceTransactionManager</code>的例子中就是以<code>dataSource</code>作为key，保存了数据库连接，这样在同一个线程中，不同的方法调用就可以通过<code>dataSource</code>获取相同的数据库连接，从而保证所有操作在一个事务中进行。<code>synchronizations</code>属性是一个<code>TransactionSynchronization</code>对象的集合，<code>AbstractPlatformTransactionManager</code>类中定义了事务操作各个阶段的调用流程，以事务提交为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPlatformTransactionManager.class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">beforeCompletionInvoked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prepareForCommit(status);</span><br><span class="line">            triggerBeforeCommit(status);</span><br><span class="line">            triggerBeforeCompletion(status);</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 记录日志</span></span><br><span class="line">                ...</span><br><span class="line">                doCommit(status);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="comment">// 事务调用异常处理</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            triggerAfterCommit(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，有很多<em>trigger</em>前缀的方法，这些方法用于在事务操作的各个阶段触发回调，从而可以精确控制在事务执行的不同阶段所要执行的操作，这些回调实际上都通过<code>TransactionSynchronizationUtils</code>来实现，它会遍历<code>TransactionSynchronizationManager#synchronizations</code>集合中的<code>TransactionSynchronization</code>对象，然后分别触发集合中各个元素对应方法的调用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> <span class="title class_">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCommit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something after commit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码就在当前线程的事务<code>synchronizations</code>属性中，添加了一个自定义同步类，如果当前存在事务，那么在事务管理器执行事务提交之后，就会触发<code>afterCommit</code>方法，可以通过这种方式在事务执行的不同阶段自定义一些操作。</p><p>到这里，我们已经对Spring事务的实现原理和处理流程有了一定的了解。</p><p>想要阅读更多技术干货、行业洞察，欢迎关注<a href="https://link.zhihu.com/?target=https://yunxin.163.com/dev-blog/?from=zhihu&utm_source=zhihu&utm_medium=article&">网易云信博客</a>。</p><p>了解<a href="https://link.zhihu.com/?target=https://yunxin.163.com/?from=zhihu&utm_source=zhihu&utm_medium=article&">网易云信</a>，来自网易核心架构的通信与视频云服务。</p><hr><p>网易云信（NeteaseYunXin）是集网易18年IM以及音视频技术打造的PaaS服务产品，来自网易核心技术架构的通信与视频云服务，稳定易用且功能全面，致力于提供全球领先的技术能力和场景化解决方案。开发者通过集成客户端SDK和云端OPEN API，即可快速实现包含IM、音视频通话、直播、点播、互动白板、短信等功能。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 事务 </tag>
            
            <tag> innobd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo的负载均衡</title>
      <link href="/2023/05/23/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2023/05/23/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<p>Dubbo是一个分布式服务框架，能避免单点故障和支持服务的横向扩容。一个服务通常会部署多个实例。如何从多个服务 Provider 组成的集群中挑选出一个进行调用，就涉及到一个负载均衡的策略。</p><hr><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><p>在讨论负载均衡之前，我想先解释一下这3个概念。</p><ol><li>负载均衡</li><li>集群容错</li><li>服务路由</li></ol><p>这3个概念容易混淆。他们都描述了怎么从多个 Provider 中选择一个来进行调用。那他们到底有什么区别呢?下面我来举一个简单的例子，把这几个概念阐述清楚吧。</p><p>有一个Dubbo的用户服务，在北京部署了10个，在上海部署了20个。一个杭州的服务消费方发起了一次调用，然后发生了以下的事情:</p><ol><li>根据配置的路由规则，如果杭州发起的调用，会路由到比较近的上海的20个 Provider。</li><li>根据配置的随机负载均衡策略，在20个 Provider 中随机选择了一个来调用，假设随机到了第7个 Provider。</li><li>结果调用第7个 Provider 失败了。</li><li>根据配置的Failover集群容错模式，重试其他服务器。</li><li>重试了第13个 Provider，调用成功。</li></ol><p>上面的第1，2，4步骤就分别对应了路由，负载均衡和集群容错。 Dubbo中，先通过路由，从多个 Provider 中按照路由规则，选出一个子集。再根据负载均衡从子集中选出一个 Provider 进行本次调用。如果调用失败了，根据集群容错策略，进行重试或定时重发或快速失败等。 可以看到Dubbo中的路由，负载均衡和集群容错发生在一次RPC调用的不同阶段。最先是路由，然后是负载均衡，最后是集群容错。 本文档只讨论负载均衡，路由和集群容错在其他的文档中进行说明。</p><h2 id="Dubbo内置负载均衡策略"><a href="#Dubbo内置负载均衡策略" class="headerlink" title="Dubbo内置负载均衡策略"></a>Dubbo内置负载均衡策略</h2><p>Dubbo内置了4种负载均衡策略:</p><ol><li>RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的<strong>默认</strong>负载均衡策略。</li><li>RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。</li><li>LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。</li><li>ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。</li></ol><h3 id="1-随机负载均衡"><a href="#1-随机负载均衡" class="headerlink" title="1.随机负载均衡"></a>1.随机负载均衡</h3><p>顾名思义，随机负载均衡策略就是从多个 Provider 中随机选择一个。但是 Dubbo 中的随机负载均衡有一个权重的概念，即按照权重设置随机概率。比如说，有10个 Provider，并不是说，每个 Provider 的概率都是一样的，而是要结合这10个 Provider 的权重来分配概率。</p><p>Dubbo中，可以对 Provider 设置权重。比如机器性能好的，可以设置大一点的权重，性能差的，可以设置小一点的权重。权重会对负载均衡产生影响。可以在Dubbo Admin中对 Provider 进行权重的设置。</p><p><strong>基于权重的负载均衡算法</strong></p><p>随机策略会先判断所有的 Invoker 的权重是不是一样的，如果都是一样的，那么处理就比较简单了。使用random.nexInt(length)就可以随机生成一个 Invoker 的序号,根据序号选择对应的 Invoker 。如果没有在Dubbo Admin中对服务 Provider 设置权重，那么所有的 Invoker 的权重就是一样的，默认是100。 如果权重不一样，那就需要结合权重来设置随机概率了。算法大概如下： 假如有4个 Invoker。</p><img src="/2023/05/23/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/05/23/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/v2-28b41cd3916d26b04a3231216e0a5eba_720w.webp" class title="img"><p>A，B，C和D总的权重是10 + 20 + 20 + 30 &#x3D; 80。将80个数分布在如下的图中:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------------------------------------------+</span><br><span class="line">|          |                    |                    |                              |</span><br><span class="line">+-----------------------------------------------------------------------------------+</span><br><span class="line">1          10                   30                   50                             80</span><br><span class="line"></span><br><span class="line">|-----A----|---------B----------|----------C---------|---------------D--------------|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------15</span><br><span class="line"></span><br><span class="line">-------------------------------------------37</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------54</span><br></pre></td></tr></table></figure><p>上面的图中一共有4块区域，长度分别是A，B，C和D的权重。使用random.nextInt(10 + 20 + 20 + 30)，从80个数中随机选择一个。然后再判断该数分布在哪个区域。比如，如果随机到37，37是分布在C区域的，那么就选择 Invoker C。15是在B区域，54是在D区域。</p><p><strong>随机负载均衡源码</strong></p><p>下面是随机负载均衡的源码，为了方便阅读和理解，我把无关部分都去掉了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> invokers.size();      <span class="comment">// Invoker 总数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>;               <span class="comment">// 所有 Invoker 的权重的和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是不是所有的 Invoker 的权重都是一样的</span></span><br><span class="line">        <span class="comment">// 如果权重都一样，就简单了。直接用Random生成索引就可以了。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sameWeight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> getWeight(invokers.get(i), invocation);</span><br><span class="line">            totalWeight += weight; <span class="comment">// Sum</span></span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; weight != getWeight(invokers.get(i - <span class="number">1</span>), invocation)) &#123;</span><br><span class="line">                sameWeight = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 如果不是所有的 Invoker 权重都相同，那么基于权重来随机选择。权重越大的，被选中的概率越大</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> random.nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                offset -= getWeight(invokers.get(i), invocation);</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有 Invoker 权重相同</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(random.nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-轮询负载均衡"><a href="#2-轮询负载均衡" class="headerlink" title="2.轮询负载均衡"></a>2.轮询负载均衡</h3><p>轮询负载均衡，就是依次的调用所有的 Provider。和随机负载均衡策略一样，轮询负载均衡策略也有权重的概念。 轮询负载均衡算法可以让RPC调用严格按照我们设置的比例来分配。不管是少量的调用还是大量的调用。但是轮询负载均衡算法也有不足的地方，存在慢的 Provider 累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上，导致整个系统变慢。</p><h3 id="3-最少活跃调用数负载均衡"><a href="#3-最少活跃调用数负载均衡" class="headerlink" title="3.最少活跃调用数负载均衡"></a>3.最少活跃调用数负载均衡</h3><p>官方解释：</p><blockquote><p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差，使慢的机器收到更少。</p></blockquote><p>这个解释好像说的不是太明白。目的是让更慢的机器收到更少的请求，但具体怎么实现的还是不太清楚。举个例子：每个服务维护一个活跃数计数器。当A机器开始处理请求，该计数器加1，此时A还未处理完成。若处理完毕则计数器减1。而B机器接受到请求后很快处理完毕。那么A,B的活跃数分别是1，0。当又产生了一个新的请求，则选择B机器去执行(B活跃数最小)，这样使慢的机器A收到少的请求。</p><p>处理一个新的请求时，Consumer 会检查所有 Provider 的活跃数，如果具有最小活跃数的 Invoker 只有一个，直接返回该 Invoker：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果只有一个最小则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> invokers.get(leastIndexs[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果最小活跃数的 Invoker 有多个，且权重不相等同时总权重大于0，这时随机生成一个权重，范围在 (0，totalWeight) 间内。最后根据随机生成的权重，来选择 Invoker。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果权重不相同且权重大于0则按总权重数随机</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offsetWeight</span> <span class="operator">=</span> random.nextInt(totalWeight);</span><br><span class="line">    <span class="comment">// 并确定随机值落在哪个片断上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leastIndex</span> <span class="operator">=</span> leastIndexs[i];</span><br><span class="line">        offsetWeight -= getWeight(invokers.get(leastIndex), invocation);</span><br><span class="line">        <span class="keyword">if</span> (offsetWeight &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-一致性Hash算法"><a href="#4-一致性Hash算法" class="headerlink" title="4.一致性Hash算法"></a>4.一致性Hash算法</h3><p>使用一致性 Hash 算法，让相同参数的请求总是发到同一 Provider。 当某一台 Provider 崩溃时，原本发往该 Provider 的请求，基于虚拟节点，平摊到其它 Provider，不会引起剧烈变动。 算法参见：<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a>。</p><p>缺省只对第一个参数Hash，如果要修改，请配置:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br></pre></td></tr></table></figure><p>缺省用160份虚拟节点，如果要修改，请配置:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure><p>一致性Hash算法可以和缓存机制配合起来使用。比如有一个服务getUserInfo(String userId)。设置了Hash算法后，相同的userId的调用，都会发送到同一个 Provider。这个 Provider 上可以把用户数据在内存中进行缓存，减少访问数据库或分布式缓存的次数。如果业务上允许这部分数据有一段时间的不一致，可以考虑这种做法。减少对数据库，缓存等中间件的依赖和访问次数，同时减少了网络IO操作，提高系统性能。</p><h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><p>如果不指定负载均衡，默认使用随机负载均衡。我们也可以根据自己的需要，显式指定一个负载均衡。 可以在多个地方类来配置负载均衡，比如 Provider 端，Consumer端，服务级别，方法级别等。</p><h3 id="服务端服务级别"><a href="#服务端服务级别" class="headerlink" title="服务端服务级别"></a>服务端服务级别</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br></pre></td></tr></table></figure><p>该服务的所有方法都使用roundrobin负载均衡。</p><h3 id="客户端服务级别"><a href="#客户端服务级别" class="headerlink" title="客户端服务级别"></a>客户端服务级别</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br></pre></td></tr></table></figure><p>该服务的所有方法都使用roundrobin负载均衡。</p><h3 id="服务端方法级别"><a href="#服务端方法级别" class="headerlink" title="服务端方法级别"></a>服务端方法级别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service interface=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;hello&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br></pre></td></tr></table></figure><p>只有该服务的hello方法使用roundrobin负载均衡。</p><h3 id="客户端方法级别"><a href="#客户端方法级别" class="headerlink" title="客户端方法级别"></a>客户端方法级别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference interface=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;hello&quot;</span> loadbalance=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure><p>只有该服务的hello方法使用roundrobin负载均衡。</p><p>和Dubbo其他的配置类似，多个配置是有覆盖关系的：</p><ol><li>方法级优先，接口级次之，全局配置再次之。</li><li>如果级别一样，则消费方优先，提供方次之。</li></ol><p>所以，上面4种配置的优先级是:</p><ol><li>客户端方法级别配置。</li><li>客户端接口级别配置。</li><li>服务端方法级别配置。</li><li>服务端接口级别配置。</li></ol><h2 id="扩展负载均衡"><a href="#扩展负载均衡" class="headerlink" title="扩展负载均衡"></a>扩展负载均衡</h2><p>Dubbo的4种负载均衡的实现，大多数情况下能满足要求。有时候，因为业务的需要，我们可能需要实现自己的负载均衡策略。本章只说明如何配置负载均衡算法。关于Dubbo扩展机制的更多内容，请前往<a href="https://link.zhihu.com/?target=https://lark.alipay.com/aliware_articles/vtpf9h/pe9pyr">Dubbo可扩展机制实战</a>。</p><ol><li>实现LoadBalance接口, 以下是Dubbo的LoadBalance接口:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(RandomLoadBalance.NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="meta">@Adaptive(&quot;loadbalance&quot;)</span></span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是SPI的接口，select方法的参数如下:</p><ul><li>invokers: 所有的服务 Provider 列表。</li><li>url: 一些配置信息，比如接口名，是否check，序列化方式。</li><li>invocation: RPC调用的信息，包括方法名，方法参数类型，方法参数。 下面是我们自己实现的一个LoadBalance，实现很简单，选择第一个 Invoker:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.dubbo;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoLoadBalance</span> <span class="keyword">implements</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[DemoLoadBalance]Select the first invoker...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>添加资源文件 添加文件:<code>src/main/resource/META-INF/dubbo/com.alibaba.dubbo.rpc.cluster.LoadBalance</code>。这是一个简单的文本文件。文件内容如下:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo=my=com.demo.dubbo.DemoLoadBalance</span><br></pre></td></tr></table></figure><ol><li>配置使用自定义LoadBalance</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference id=&quot;helloService&quot; interface=&quot;com.demo.dubbo.api.IHelloService&quot; loadbalance=&quot;demo&quot; /&gt;</span><br></pre></td></tr></table></figure><p>在Consumer端的<code>dubbo:reference</code>中配置<code>&lt;loadbalance=&quot;demo&quot;&gt;</code></p><p>经过上面的3个步骤，我们编写了一个自定义的LoadBalance，并告诉Dubbo使用它了。启动Dubbo，我们就能看到Dubbo已经使用了自定义的DemoLoadBalance。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java dubbo 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务注解@Transactional 失效的3种场景及解决办法</title>
      <link href="/2023/05/21/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional-%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2023/05/21/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional-%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>@Transactional 这个是Spring中常用的事物注解，如果事物运行失败，则进行回滚，那么偶尔会遇到这个注解失效的情况，下面进行分析</p><hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>@Transactional</code> 注解相信大家并不陌生，平时开发中很常用的一个注解，它能保证方法内多个数据库操作要么同时成功、要么同时失败。使用<code>@Transactional</code>注解时需要注意许多的细节，不然你会发现<code>@Transactional</code>总是莫名其妙的就失效了。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务管理在系统开发中是不可缺少的一部分，<code>Spring</code>提供了很好事务管理机制，主要分为<code>编程式事务</code>和<code>声明式事务</code>两种。</p><p><strong>编程式事务</strong>：是指在代码中手动的管理事务的提交、回滚等操作，代码侵入性比较强，如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TODO something</span></span><br><span class="line">     transactionManager.commit(status);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    transactionManager.rollback(status);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvoiceApplyException</span>(<span class="string">&quot;异常失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明式事务</strong>：基于<code>AOP</code>面向切面的，它将具体业务与事务处理部分解耦，代码侵入性很低，所以在实际开发中声明式事务用的比较多。声明式事务也有两种实现方式，一是基于<code>TX</code>和<code>AOP</code>的xml配置文件方式，二种就是基于@Transactional注解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">       <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="Transactional介绍"><a href="#Transactional介绍" class="headerlink" title="@Transactional介绍"></a>@Transactional介绍</h1><h2 id="1、-Transactional注解可以作用于哪些地方？"><a href="#1、-Transactional注解可以作用于哪些地方？" class="headerlink" title="1、@Transactional注解可以作用于哪些地方？"></a>1、@Transactional注解可以作用于哪些地方？</h2><p>@Transactional 可以作用在<code>接口</code>、<code>类</code>、<code>类方法</code>。</p><ul><li><strong>作用于类</strong>：当把@Transactional 注解放在类上时，表示所有该类的<code>public</code>方法都配置相同的事务属性信息。</li><li><strong>作用于方法</strong>：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。</li><li><strong>作用于接口</strong>：不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CityInfoDictMapper cityInfoDictMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setCityLevel(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setCityCode(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">        <span class="keyword">return</span> insert + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、-Transactional注有哪些属性？"><a href="#2、-Transactional注有哪些属性？" class="headerlink" title="2、@Transactional注有哪些属性？"></a>2、@Transactional注有哪些属性？</h2><h3 id="propagation属性"><a href="#propagation属性" class="headerlink" title="propagation属性"></a><strong>propagation属性</strong></h3><p><code>propagation</code> 代表事务的传播行为，默认值为 <code>Propagation.REQUIRED</code>，其他的属性信息如下：</p><ul><li><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。**(** 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></li><li><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</li><li><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li><li><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。**(** 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></li><li><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</li><li><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</li><li><code>Propagation.NESTED</code> ：和 Propagation.REQUIRED 效果一样。</li></ul><h5 id="isolation-属性"><a href="#isolation-属性" class="headerlink" title="isolation 属性"></a><strong>isolation 属性</strong></h5><p><code>isolation</code> ：事务的隔离级别，默认值为 <code>Isolation.DEFAULT</code>。</p><ul><li>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</li><li>Isolation.READ_UNCOMMITTED</li><li>Isolation.READ_COMMITTED</li><li>Isolation.REPEATABLE_READ</li><li>Isolation.SERIALIZABLE</li></ul><h5 id="timeout-属性"><a href="#timeout-属性" class="headerlink" title="timeout 属性"></a><strong>timeout 属性</strong></h5><p><code>timeout</code> ：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><h5 id="readOnly-属性"><a href="#readOnly-属性" class="headerlink" title="readOnly 属性"></a><strong>readOnly 属性</strong></h5><p><code>readOnly</code> ：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p><h5 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a><strong>rollbackFor 属性</strong></h5><p><code>rollbackFor</code> ：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p><h5 id="noRollbackFor属性"><a href="#noRollbackFor属性" class="headerlink" title="noRollbackFor属性**"></a><strong>noRollbackFor</strong>属性**</h5><p><code>noRollbackFor</code>：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</p><h1 id="Transactional失效场景"><a href="#Transactional失效场景" class="headerlink" title="@Transactional失效场景"></a>@Transactional失效场景</h1><p>接下来我们结合具体的代码分析一下哪些场景下，@Transactional 注解会失效。</p><h4 id="1、-Transactional-应用在非-public-修饰的方法上"><a href="#1、-Transactional-应用在非-public-修饰的方法上" class="headerlink" title="1、@Transactional 应用在非 public 修饰的方法上"></a>1、@Transactional 应用在非 public 修饰的方法上</h4><p>如果<code>Transactional</code>注解应用在非<code>public</code> 修饰的方法上，Transactional将会失效。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/19/170f0e025a51a1b4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><p>之所以会失效是因为在Spring AOP 代理时，如上图所示 <code>TransactionInterceptor</code> （事务拦截器）在目标方法执行前后进行拦截，<code>DynamicAdvisedInterceptor</code>（CglibAopProxy 的内部类）的 intercept 方法或 <code>JdkDynamicAopProxy</code> 的 invoke 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>的 <code>computeTransactionAttribute</code> 方法，获取Transactional 注解的事务配置信息。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">oxygene复制代码<span class="keyword">protected</span> TransactionAttribute computeTransactionAttribute(<span class="keyword">Method</span> <span class="title function_">method</span>,</span><br><span class="line">    <span class="title function_">Class</span>&lt;?&gt; <span class="title function_">targetClass</span>) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">        // Don&#x27;t allow no-public methods as required.</span></span><br><span class="line"><span class="comment">        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p><p><strong>注意：<code>protected</code>、<code>private</code> 修饰的方法上使用 <code>@Transactional</code> 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</strong></p><h4 id="2、-Transactional-注解属性-propagation-设置错误"><a href="#2、-Transactional-注解属性-propagation-设置错误" class="headerlink" title="2、@Transactional 注解属性 propagation 设置错误"></a>2、@Transactional 注解属性 propagation 设置错误</h4><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p><p><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 <code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 <code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</p><h4 id="3、-Transactional-注解属性-rollbackFor-设置错误"><a href="#3、-Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="3、@Transactional  注解属性 rollbackFor 设置错误"></a>3、@Transactional  注解属性 rollbackFor 设置错误</h4><p><code>rollbackFor</code> 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查<code>unchecked</code>异常（继承自 <code>RuntimeException</code> 的异常）或者 <code>Error</code>才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 <strong>rollbackFor</strong>属性。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/19/170f0e025b17b3ca~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stylus复制代码<span class="comment">// 希望自定义的异常可以进行回滚</span></span><br><span class="line">@<span class="built_in">Transactional</span>(propagation= Propagation<span class="selector-class">.REQUIRED</span>,rollbackFor= MyException.class</span><br></pre></td></tr></table></figure><p>若在目标方法中抛出的异常是 <code>rollbackFor</code> 指定的异常的子类，事务同样会回滚。Spring源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(Class&lt;?&gt; exceptionClass, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (exceptionClass.getName().contains(<span class="built_in">this</span>.exceptionName)) &#123;</span><br><span class="line">            <span class="comment">// Found it!</span></span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// If we&#x27;ve gone as far as we can go and haven&#x27;t found it...</span></span><br><span class="line">        <span class="keyword">if</span> (exceptionClass == Throwable.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getDepth(exceptionClass.getSuperclass(), depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、同一个类中方法调用，导致-Transactional失效"><a href="#4、同一个类中方法调用，导致-Transactional失效" class="headerlink" title="4、同一个类中方法调用，导致@Transactional失效"></a>4、同一个类中方法调用，导致@Transactional失效</h4><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用<code>Spring AOP</code>代理造成的，因为只有<strong>当事务方法被当前类以外的代码调用</strong>时，才会由<code>Spring</code>生成的代理对象来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Transactional</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">this</span>.insertB();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> insert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional()</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">insertB</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="5、异常被你的-catch“吃了”导致-Transactional失效"><a href="#5、异常被你的-catch“吃了”导致-Transactional失效" class="headerlink" title="5、异常被你的 catch“吃了”导致@Transactional失效"></a>5、异常被你的 catch“吃了”导致@Transactional失效</h4><p>这种情况是最常见的一种@Transactional注解失效场景，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">            cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            b.insertB();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：看具体的情况，如果B本身也有事务注解，那么会回滚。</p><p>请参考下面的截图分析</p><p><img src="/2023/05/21/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional-%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/df52c75a5a884709aff63c3f4134ebff~tplv-k3u1fbpfcp-zoom-1.awebp" alt="img"></p><p>会抛出异常：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.<span class="keyword">transaction</span>.UnexpectedRollbackException: <span class="keyword">Transaction</span> rolled back because it has been marked <span class="keyword">as</span> <span class="keyword">rollback</span>-<span class="keyword">only</span></span><br></pre></td></tr></table></figure><p>因为当<code>ServiceB</code>中抛出了一个异常以后，<code>ServiceB</code>标识当前事务需要<code>rollback</code>。但是<code>ServiceA</code>中由于你手动的捕获这个异常并进行处理，<code>ServiceA</code>认为当前事务应该正常<code>commit</code>。此时就出现了前后不一致，也就是因为这样，抛出了前面的<code>UnexpectedRollbackException</code>异常。</p><p><code>spring</code>的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行<code>commit</code> or <code>rollback</code>，事务是否执行取决于是否抛出<code>runtime异常</code>。如果抛出<code>runtime exception</code> 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要抛出<code>throw new RuntimeException()</code>，或者注解中指定抛异常类型<code>@Transactional(rollbackFor=Exception.class)</code>，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p><h4 id="6、数据库引擎不支持事务"><a href="#6、数据库引擎不支持事务" class="headerlink" title="6、数据库引擎不支持事务"></a>6、数据库引擎不支持事务</h4><p>这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的<code>innodb</code>引擎。一旦数据库引擎切换成不支持事务的<code>myisam</code>，那事务就从根本上失效了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>@Transactional 注解的看似简单易用，但如果对它的用法一知半解，还是会踩到很多坑的。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Transactional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列产生严重消息堆积怎么处理?</title>
      <link href="/2023/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/"/>
      <url>/2023/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么产生消息堆积？"><a href="#为什么产生消息堆积？" class="headerlink" title="为什么产生消息堆积？"></a>为什么产生消息堆积？</h2><p>大多是因为 Consumer 出问题了，没有及时发现，或者故障恢复需要较长的时间，导致大量消息积压在 MQ 中。</p><h2 id="消息堆积会有什么后果呢？"><a href="#消息堆积会有什么后果呢？" class="headerlink" title="消息堆积会有什么后果呢？"></a>消息堆积会有什么后果呢？</h2><h3 id="消息被丢弃"><a href="#消息被丢弃" class="headerlink" title="消息被丢弃"></a>消息被丢弃</h3><p>例如 RabbitMQ 有一个消息过期时间 TTL，过期的消息会被扔掉，这样消息就彻底没有了。</p><h3 id="磁盘满了"><a href="#磁盘满了" class="headerlink" title="磁盘满了"></a>磁盘满了</h3><p>如果堆积量太大，可能导致磁盘空间不足，那么新消息就进不来了。</p><h3 id="海量消息待处理"><a href="#海量消息待处理" class="headerlink" title="海量消息待处理"></a>海量消息待处理</h3><p>如果消息没过期，并且磁盘空间也够用，那么就是产生海量消息等待被消费，Consumer 的噩梦。</p><h2 id="如何应对呢？"><a href="#如何应对呢？" class="headerlink" title="如何应对呢？"></a>如何应对呢？</h2><h3 id="消息被丢弃的情况"><a href="#消息被丢弃的情况" class="headerlink" title="消息被丢弃的情况"></a>消息被丢弃的情况</h3><p>首先，要实现防止消息过期问题，不应该设置过期时间。</p><p>如果就是设置了过期时间，导致了消息丢失，怎么补救呢？</p><p>那就只能在夜深人静，趁着访问量最低的时候，写一个临时程序来补消息了。</p><p>例如有订单消息丢了，那就需要找出哪些订单消息丢了，然后重新发到队列。</p><h3 id="磁盘不足的情况"><a href="#磁盘不足的情况" class="headerlink" title="磁盘不足的情况"></a>磁盘不足的情况</h3><p>系统通常都是有监控的，达到空间阈值时就会发警报，这时就要马上处理了。</p><img src="/2023/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/v2-5dc767965bf2b813bafecd51e13ed41c_720w.webp" class title="img"><p>例如，在其他机器上创建临时的消息队列，再写一个临时的 Consumer，作为消息的中转，把消息积压队列中的消息取出来，放到临时队列里面去。</p><p>快速疏散积压的消息，让磁盘空间恢复正常水平。</p><h3 id="快速处理海量积压消息"><a href="#快速处理海量积压消息" class="headerlink" title="快速处理海量积压消息"></a>快速处理海量积压消息</h3><p>Consumer 恢复正常之后，面对堆积如山的消息，怎么处理呢？</p><p>如何按照之前正常情况处理的话，猴年马月才能消费完，此过程中还有新消息在不断进来。</p><p>例如，积压了 100 万条，有 3 个 Consumer，每一个每秒能处理 200 条，3 个 Consumer 每秒一共能处理 600 条。</p><p>大概需要一个多小时才能处理完。</p><p>这一个多小时又会积压多少新的消息呢？</p><p>所以正常处理肯定不行，需要提速。</p><p>例如 Kafka，这个消息积压的 Topic 有 3 个 Partition，那最多就能用 3 个 Consumer，所以增加 Consumer 没有用。</p><p>还是可以使用<strong>临时队列</strong>的方式。</p><img src="/2023/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/05/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/v2-8a6a18065863900773f1491c82af4884_720w.webp" class title="img"><p>新建一个 Topic，设置为 20 个 Partition</p><p>Consumer 不再处理业务逻辑了，只负责搬运，把消息放到临时 Topic 中</p><p>这 20 个 Partition 可以有 20个 Consumer 了，它们来处理原来的业务逻辑。</p><p>这 20 个 Consumer 每秒一共能处理 4000 条了，这样几分钟就可以处理完积压的 100 万条。</p><p>这几分钟新来的消息也不会太多，所以很快就可以恢复正常水平，之后，再把整体结构恢复为原来的形式。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>消息积压还是比较麻烦的，最好是提前防范，做好硬件和消息系统的健康监控。如果出现消息丢失，就要人工查找丢失的消息，然后补上。在消费不过来的时候，可以考虑使用临时队列作为中转，提升处理能力。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程：搞懂 wait() 和 join()的关系</title>
      <link href="/2023/05/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%90%9E%E6%87%82wait()%E5%92%8Cjoin()%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2023/05/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%90%9E%E6%87%82wait()%E5%92%8Cjoin()%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>多线程：因为上一篇文章join中提到了wait，容易搞混谁等待，谁运行的关系，这篇文章来彻底讲解一下两者的对比</p><hr><h1 id="前置知识-线程状态"><a href="#前置知识-线程状态" class="headerlink" title="前置知识:线程状态"></a>前置知识:线程状态</h1><p>   public enum State {</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    NEW,</span><br><span class="line"> </span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br><span class="line">**NEW (初始):** 新创建线程对象，但还没有调用 start() 方法</span><br><span class="line">**RUNNABLE (运行):** java 把 就绪 (ready) 和运行 (running) 一起归属于runnable。线程对象创建后，被其它的线程（如: main线程）调用start() 方法。该线程就处于就绪（ready）状态进入可运行线程池中，等待cpu线程调度。就绪状态的线程获得cpu时间片后变为 运行状态 (running)</span><br><span class="line">**BLOCKED (阻塞) :** 线程阻塞于锁</span><br><span class="line">**WAITING（等待) :** 线程等待其它线程唤醒</span><br><span class="line">**TIMED_WAITING (超时等待) :** 该状态不同于WAITING，它可以在指定的时间后自行返回。</span><br><span class="line">**TERMINATED (终止) ：**该线程执行完毕</span><br></pre></td></tr></table></figure><p><img src="/2023/05/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%90%9E%E6%87%82wait()%E5%92%8Cjoin()%E7%9A%84%E5%85%B3%E7%B3%BB/1ea3223fe421ffdf6575a2d304cc4be5.png" alt="线程流转变动"></p><h1 id="wait-详解"><a href="#wait-详解" class="headerlink" title="wait() 详解"></a>wait() 详解</h1><p><strong>wait() notify() notifyAll()</strong> 都是 Object类的方法，使用这三个方法的前提是先获得该对象的锁。</p><p>调用 wait 方法后，释放持有的对象锁，线程状态有 Running 变为 Waiting，并将当前线程放置到对象的 等待队列；<br>调用notify 或者 notifyAll 方法后，等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回；<br><strong>notify</strong> 方法：将等待队列的一个等待线程从等待队列种移到同步队列中 ，<br><strong>notifyAll</strong> 方法：将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked。<br><strong>等待队列（等待池） 同步队列（锁池）</strong></p><p><strong>同步队列（锁池）</strong>：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked。</p><p><strong>等待队列（等待池）</strong>：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时 线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting。如果另外的一个线程调用了相同对象的notifyAll()方法，那么 处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么 仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）。</p><h1 id="深入join"><a href="#深入join" class="headerlink" title="深入join()"></a>深入join()</h1><p>join() : 保证线程的执行顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        MyThread1 t=<span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;执行！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一句话总结: <strong>让获得这个线程锁（t1）的线程(main) 等待，t1 执行完再唤醒线程(main)，这样就保证了执行顺序。</strong></p><p>看完下面的分析就可以更好理解上面的总结</p><p>JDK中 join() 的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span>    <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;  </span><br><span class="line">       wait(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;  </span><br><span class="line">        <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        wait(delay);  </span><br><span class="line">        now = System.currentTimeMillis() - base;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>join的实现就是调用wait()方法。</p><p>wait() 方法源码&#96;&#96;public final native void wait(long timeout) throws InterruptedException;&#96;<br>该方法为本地方法，调用此方法的当前线程需要释放锁，并等待唤醒。在上述例子中，主线程调用子线程对象的join()方法，因此主线程在此位置需要释放锁，并进行等待。</p><p>main线程运行，运行到t.join(等待时间)时，相当于运行 t.wait()，main线程获得线程对象 t 的锁，调用wait(等待时间)方法，main线程又释放掉 线程对象t 的锁，从 running变为 blocked 进入等待队列，等待线程对象t唤醒。</p><p><strong>那么join()方法在什么时候唤醒 main线程？</strong></p><p>查看Thread类中存在exit()方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * This method is called by the system to give a Thread</span></span><br><span class="line"><span class="comment">      a chance to clean up before it actually exits.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * 这个方法由系统调用，当该线程完全退出前给它一个机会去释放空间。</span></span><br><span class="line"><span class="comment">          /</span></span><br><span class="line"><span class="comment">          private void exit() &#123;</span></span><br><span class="line"><span class="comment">          if (group != null) &#123;                //线程组在Thread初始化时创建，存有创建的子线程</span></span><br><span class="line"><span class="comment">              group.threadTerminated(this);   //调用threadTerminated()方法</span></span><br><span class="line"><span class="comment">              group = null;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">          /* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">          target = <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">          threadLocals = <span class="literal">null</span>;</span><br><span class="line">          inheritableThreadLocals = <span class="literal">null</span>;</span><br><span class="line">          inheritedAccessControlContext = <span class="literal">null</span>;</span><br><span class="line">          blocker = <span class="literal">null</span>;</span><br><span class="line">          uncaughtExceptionHandler = <span class="literal">null</span>;</span><br><span class="line">          </span><br><span class="line">          </span><br></pre></td></tr></table></figure><p>   *<br>        exit()在线程执行完run()方法之后会被调用，此时线程组中存在当前子线程，因此会调用线程组的threadTerminated()方法。 查看ThreadGroup.threadTerminated()方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is called by the system to give a Thread</span></span><br><span class="line"><span class="comment">     * a chance to clean up before it actually exits.</span></span><br><span class="line"><span class="comment">     * 这个方法由系统调用，当该线程完全退出前给它一个机会去释放空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="literal">null</span>) &#123;                <span class="comment">//线程组在Thread初始化时创建，存有创建的子线程</span></span><br><span class="line">            group.threadTerminated(<span class="built_in">this</span>);   <span class="comment">//调用threadTerminated()方法</span></span><br><span class="line">            group = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">        target = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">        threadLocals = <span class="literal">null</span>;</span><br><span class="line">        inheritableThreadLocals = <span class="literal">null</span>;</span><br><span class="line">        inheritedAccessControlContext = <span class="literal">null</span>;</span><br><span class="line">        blocker = <span class="literal">null</span>;</span><br><span class="line">        uncaughtExceptionHandler = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>通知线程组，t线程已经终止。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    /** Notifies the group that the thread &#123;@code t&#125; has terminated.</span><br><span class="line">      * 通知线程组，t线程已经终止。</span><br><span class="line">*/</span><br><span class="line">    void threadTerminated(Thread t) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                remove(t);                          //从线程组中删除此线程</span><br><span class="line">    </span><br><span class="line">                if (nthreads == 0) &#123;                //当线程组中线程数为0时</span><br><span class="line">                    notifyAll();                    //唤醒所有待定中的线程</span><br><span class="line">                &#125;</span><br><span class="line">                if (daemon &amp;&amp; (nthreads == 0) &amp;&amp;</span><br><span class="line">                    (nUnstartedThreads == 0) &amp;&amp; (ngroups == 0))</span><br><span class="line">              &#123;</span><br><span class="line">                  destroy();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>​<br>​    通过此方法，将子线程从线程组中删除，并唤醒其他等待的线程。在上述例子中，此时子线程被销毁，并释放占用的资源，并唤醒等待中的线程。而在join()方法中等待的主线程被唤醒，并获得锁，继续往下执行 t.join() 后面的代码。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解java Thread中的join方法</title>
      <link href="/2023/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/"/>
      <url>/2023/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="join-方法作用与原理"><a href="#join-方法作用与原理" class="headerlink" title="join()方法作用与原理"></a>join()方法作用与原理</h1><ol><li>join()的作用</li><li>join()的原理</li><li>总结</li></ol><h2 id="join-的作用"><a href="#join-的作用" class="headerlink" title="join()的作用"></a>join()的作用</h2><p> <code>join()</code>是 Thread 类中的一个方法，当我们需要让线程按照自己指定的顺序执行的时候，就可以利用这个方法。<strong>「<code>Thread.join()</code>方法表示调用此方法的线程被阻塞，仅当该方法完成以后，才能继续运行」</strong>。</p><blockquote><p>❝ 作用于 main( )主线程时，会等待其他线程结束后再结束主线程。<br>❞</p></blockquote><p><strong>「示例」</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread t1 run&quot;</span>);</span><br><span class="line">            count=<span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();<span class="comment">//若把这一行注释掉，则打印的count为0</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 run</span><br><span class="line">count=10</span><br></pre></td></tr></table></figure><p>说明在调用<code>t1.join( )</code>方法以后，<code>main()</code>的线程被阻塞，等到<code>t1</code>线程完成以后，<code>main()</code>线程再结束。</p><img src="/2023/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/v2-cac99aa740e47b608880c65cb24cec83_720w.webp" class title="img"><h2 id="join-方法的原理"><a href="#join-方法的原理" class="headerlink" title="join()方法的原理"></a>join()方法的原理</h2><blockquote><p>❝ 主要两点，线程如何被阻塞，线程又是如何被唤醒<br>❞</p></blockquote><p><code>join()</code>方法是<code>Thread</code>类中的，所以我们可以直接查看源码，找到<code>join()</code>方法，如下。</p><p>还有另外一个重载的方法，不过实际上调用的就是下图<code>join()</code>方法，只是参数为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;<span class="comment">//只要线程还没结束，主线程就会一直阻塞</span></span><br><span class="line">            wait(<span class="number">0</span>);<span class="comment">//这里的wait调用的本地方法。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//等待一段指定的时间</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 从源码来看，实际上<code>join</code>方法就是调用了<code>wait</code>方法来使得线程阻塞，一直到线程结束运行。注意到，<code>join</code>方法前的<code>synchronized</code>修饰符，它相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span>&#123;</span><br><span class="line"> <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="comment">//代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 也就是说加锁的对象即调用这个锁的线程对象，在<code>main()</code>方法中即为<code>t1</code>，持有这个锁的是主线程即<code>main()</code>方法，也就是说代码相当于如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t1.join()前的代码</span></span><br><span class="line"><span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line"> <span class="comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span></span><br><span class="line"> <span class="keyword">while</span> (t1.isAlive()) &#123;</span><br><span class="line">  t1.wait(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t1.join()后的代码</span></span><br></pre></td></tr></table></figure><p>也因此主线程进入等待队列，直到<code>t1</code>线程结束。</p><blockquote><p>❝ wait 方法被调用以后，是让持有锁的线程进入等待队列，即主线程，t1是被主线程持有的锁对象，因此 t1 线程并不会被阻塞。<br>❞</p></blockquote><p><strong>「那么问题在于，这里只看到了<code>wait</code>方法，却并没有看到<code>notify</code>或者是<code>notifyAll</code>方法，那么主线程在那里被唤醒呢」</strong>。</p><p>这里参考<code>jvm</code>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ensure_join</span><span class="params">(JavaThread* thread)</span> &#123;</span><br><span class="line"></span><br><span class="line"> Handle <span class="title function_">threadObj</span><span class="params">(thread, thread-&gt;threadObj()</span>);</span><br><span class="line"></span><br><span class="line"> ObjectLocker <span class="title function_">lock</span><span class="params">(threadObj, thread)</span>;</span><br><span class="line"></span><br><span class="line"> hread-&gt;clear_pending_exception();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//这一句中的TERMINATED表示这是线程结束以后运行的</span></span><br><span class="line"> java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里会清楚native线程，isAlive()方法会返回false</span></span><br><span class="line">    java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//thread就是当前线程，调用这个方法唤醒等待的线程。</span></span><br><span class="line"> lock.notify_all(thread);</span><br><span class="line"></span><br><span class="line"> hread-&gt;clear_pending_exception();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其实是<code>jvm</code>虚拟机中存在方法<code>lock.notify_all(thread)</code>，在<code>t1</code>线程结束以后，会调用该方法，最后唤醒主线程。</p><p> 所以简化一下，流程即：</p><img src="/2023/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/05/21/%E8%AF%A6%E8%A7%A3java-Thread%E4%B8%AD%E7%9A%84join%E6%96%B9%E6%B3%95/v2-8d1ed7f5621e6a4411486e8952b72139_720w.webp" class title="img"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要注意的其实就两点：</p><ol><li><code>wait</code>方法是使持有锁的线程进入等待队列，所以主线程会阻塞。</li><li>唤醒进程的方法位于<code>jvm</code>中，在线程（调用<code>join</code>方法的线程）结束后主线程被调用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWriteArrayList的机制如何保证读取到数据是最新的？</title>
      <link href="/2023/05/21/CopyOnWriteArrayList%E7%9A%84%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%8F%96%E5%88%B0%E6%95%B0%E6%8D%AE%E6%98%AF%E6%9C%80%E6%96%B0%E7%9A%84%EF%BC%9F/"/>
      <url>/2023/05/21/CopyOnWriteArrayList%E7%9A%84%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%8F%96%E5%88%B0%E6%95%B0%E6%8D%AE%E6%98%AF%E6%9C%80%E6%96%B0%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>CopyOnWriteArrayList是写时复制一个数组，读取的还是在原数组，那如何保证读取到数据是最新的</p><hr><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>很可惜，<strong>不能保证读到的数据一定是最新的</strong>，因为CopyOnWriteArrayList是弱数据一致性，具体的原因可以看一下这篇文章。</p><p>这篇文章想来跟大家来探讨一下，在Java中已经提供了并发安全的集合，为什么有的场景还需要使用<a href="https://www.zhihu.com/search?q=%E8%AF%BB%E5%86%99%E9%94%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">读写锁</a>，直接用并发安全的集合难道不行么？</p><p>在java中，并发安全的集合有很多，这里我就选用常见的CopyOnWriteArrayList为例，解决上述问题的同时，也来说明一下读写锁的价值到底提现在哪。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><em>CopyOnWriteArrayList核心源码分析</em>*</p><p>接下来我们分析一下CopyOnWriteArrayList核心的增删改查的方法</p><p><a href="https://www.zhihu.com/search?q=%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">成员变量</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//底层用来存放元素的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>add方法：往集合中添加某个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add操作先通过lock加锁，保证同一时刻最多只有一个线程可以操作。加锁成功获取到成员变量的数据，然后拷贝<a href="https://www.zhihu.com/search?q=%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%95%B0%E7%BB%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">成员变量数组</a>的元素到新的数组，再基于新的数据来添加元素，最后将新拷贝的数组通过setArray来替换旧的成员变量的数组。</p><p>remove方法：移除集合中的某个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                                 numMoved);</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/search?q=remove&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">remove</a>操作也要先获取到锁。它先是取出对应数组下标的旧元素，然后新建了一个原数组长度减1的新数组，将除了被移除的元素之外，剩余的元素拷贝到新的数组，最后再通过setArray替换旧的成员变量的数组。</p><p>set方法：将集合中指定位置的元素替换成新的元素</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">            if (oldValue != element) &#123;</span><br><span class="line">                int len = elements.length;</span><br><span class="line">                Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">                newElements[index] = element;</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Not quite a no-op; ensures volatile write semantics</span><br><span class="line">                setArray(elements);</span><br><span class="line">            &#125;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>set方法跟add，remove操作一样得先获取到锁才能继续执行。将原数组的原有元素拷贝到新的数组上，在新的数组完成数据的替换，最后也是通过setArray替换旧的成员变量的数组。</p><p>size方法：获取集合中元素的个数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">        return getArray().length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size方法操作很简单，就是简单地返回一下当前数组的长度。</p><p><a href="https://www.zhihu.com/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">迭代器</a>的构造</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造COWIterator的时候传入当前数组的对象，然后基于当前数组来遍历，也不需要加锁。</p><h1 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h1><p>讲完CopyOnWriteArrayList源码，我们可以看出CopyOnWriteArrayList的核心原理就是在对数组进行增删改的时候全部都是先加独占锁，然后对原有的数组进行拷贝，然后基于新复制的数组进行操作，最后将这个新的数组替换成员变量的数组；而对于读的操作来说，都是不加锁的，是基于当前成员变量的数组的这一时刻的快照来读的。其实CopyOnWriteArrayList是基于一种写时复制的思想，写的时候基于新拷贝的数组来操作，之后再赋值给成员变量，读的时候是原有的数组，这样读写其实就是不是同一个数组，这样就避免了读写冲突的情况，这其实也体现了一种<a href="https://www.zhihu.com/search?q=%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2441509719%7D">读写分离</a>的思想，读写操作的是不同的数组。</p><p><strong>CopyOnWriteArrayList适用场景</strong></p><p>接下来我们来思考一下，CopyOnWriteArrayList适合使用在什么样的场景中。通过上面源码的分析，我们可以看出，所有的写操作，包括增删改都需要加同一把独占锁，所以同时只允许一个线程对数组进行拷贝赋值的操作，多线程并发情况下所有的操作都是串行执行的，势必会导致并发能力降低，同时每次操作都涉及到了数组的拷贝，性能也不太好；而所有的读操作都不需要加锁，所以同一时间可以允许大量的线程同时读，并发性能高。所以综上我们可以得出一个结论，那就是CopyOnWriteArrayList适合读多写少的场景。</p><p><strong>CopyOnWriteArrayList的局限性</strong></p><p>说完CopyOnWriteArrayList，我们来想一想它有没有什么缺点。看起来CopyOnWriteArrayList除了写的并发性能差点，好像没有什么缺点了。的确，单从性能来看，确实是这种情况，但是，从数据一致性的角度来看，CopyOnWriteArrayList的数据一致性能力较弱，属于数据弱一致性。所谓的弱一致性，你可以这么理解，在某一个时刻，读到的数据并不是当前这一时刻最新的数据。</p><p>就拿CopyOnWriteArrayList举例来说，当有个线程A正在调用add方法来添加元素，此时已经完成了数组的拷贝，并且也将元素添加到数组中，但是还没有将新的数组赋值给成员变量，此时，另一个线程B来调用CopyOnWriteArrayList的size方法，来读取集合中元素的个数，那么此时读到的元素个数其实是不包括线程A要添加的元素，因为线程A并没有将新的数组赋值给成员变量，这就导致了线程B读到的数据不是最新的数据，也就是跟实际的数据不一致。</p><p>所以，从上面我们可以看出，CopyOnWriteArrayList对于数据一致性的保证，还是比较弱的。其实不光是CopyOnWriteArrayList，其实Java中的很多集合，队列的实现对于数据一致性的保证都比较弱。</p><p><strong>如何来保证数据的强一致性</strong></p><p>那么有什么好的办法可以保证数据的强一致性么？当然，保证并发安全，加锁就可以完成，但是加什么锁可以保证数据读写安全和数据一致性，其实最简单粗暴的方法就是对所有的读写都加上同一把独占锁，这样保证所有的读写操作都是串行执行，那么读的时候，其他线程一定不能写，那么读的一定是最新的数据。</p><p>如果真的这么去加独占锁，的确能够保证读写安全，但是性能却会很差，这也是为什么CopyOnWriteArrayList的读不加锁的原因，其实CopyOnWriteArrayList在设计的时候，就是降低数据一致性来换取读的性能。</p><p>那有没有什么折中的方法，既能保证读的性能不差，又能保证数据强一致性呢。这时就可以用读写锁来实现。所谓的读写锁，就是写的时候，其他线程不能写也不能读，读的时候，其他线程能读，但是不能写。也就是写写、读写互斥，但是读读不互斥。基于这种方式，就能保证读的时候，一定没有人在写，这样读到的数据就一定是最新的，同时也能保证其他线程也能读，不会出现上面举例的那种情况了，也就能保证数据的强一致性。读写锁相比独占锁而言，大大提高了读的并发能力，但是写的时候不能读，相比于CopyOnWriteArrayList而言，读的并发能力有所降低，这可能就是鱼（并发性能）和熊掌（数据一致性）不可兼得吧。</p><p>Java中也提供了读写锁的实现，ReentrantReadWriteLock，底层是基于AQS来实现的。有兴趣的小伙伴可以翻一下源码，看看是如何实现的，这里就不再剖析源码了。</p><p><strong>总结</strong></p><p>好了，通过这篇文章，想必大家知道为什么有并发安全的集合之后，还需要读写锁的原因，因为很多并发安全的集合对于数据一致性的保证是比较弱的，一旦遇到对于数据一致性要求比较高的场景，一些并发安全的集合就不适用了；同时为了避免独占锁带来的性能问题，可以选择读写锁来保证读的并发能力。小伙伴们在实际应用中需要根据应用场景来灵活地选择使用并发安全的集合、读写锁或者是独占锁，其实永远没有最好的选择，只有更好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在不适用锁的情况下解决高并发问题？</title>
      <link href="/2023/05/21/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%80%82%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F/"/>
      <url>/2023/05/21/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%80%82%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>问题的原话是：如何在实际业务实现中不使用锁解决高并发问题，有没有相关的解决办法？</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>除了使用 synchronized、Lock 加锁之外，Java 中还有很多不需要加锁就可以解决并发问题的工具类</p><img src="/2023/05/21/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%80%82%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F/05/21/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%80%82%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F/v2-b732e0e46b87abad6ff059a454e5e825_720w.png" class title="img"><h1 id="原子工具类"><a href="#原子工具类" class="headerlink" title="原子工具类"></a>原子工具类</h1><p>JDK 1.8 中， java.util.concurrent.atomic 包下类都是原子类，原子类都是基于 sun.misc.Unsafe 实现的。</p><ul><li>CPU 为了解决并发问题，提供了 CAS 指令，全称 Compare And Swap，即比较并交互</li><li>CAS 指令需要 3 个参数，变量、比较值、新值。当变量的当前值与比较值相等时，才把变量更新为新值</li><li>CAS 是一条 CPU 指令，由 CPU 硬件级别上保证原子性</li><li>java.util.concurrent.atomic 包中的原子分为：原子性基本数据类型、原子性对象引用类型、原子性数组、原子性对象属性更新器和原子性累加器</li></ul><p><strong>原子性基本数据类型</strong>：AtomicBoolean、AtomicInteger、AtomicLong</p><p><strong>原子性对象引用类型</strong>：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p><p><strong>原子性数组</strong>：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p><strong>原子性对象属性更新</strong>：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、 AtomicReferenceFieldUpdater</p><p><strong>原子性累加器</strong>：DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</p><p>修改我们之前测试原子性问题的类，使用 AtomicInteger 的简单例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.concurrency.a026;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 原子类 AtomicInteger</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAtomicInteger</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 计数变量</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> <span class="comment">// 线程 1 给 count 加 10000</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">10000</span>; j++) &#123;</span><br><span class="line"> count.incrementAndGet();</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;thread t1 count 加 10000 结束&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 线程 2 给 count 加 10000</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">10000</span>; j++) &#123;</span><br><span class="line"> count.incrementAndGet();</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;thread t2 count 加 10000 结束&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 启动线程 1</span></span><br><span class="line"> t1.start();</span><br><span class="line"> <span class="comment">// 启动线程 2</span></span><br><span class="line"> t2.start();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 等待线程 1 执行完成</span></span><br><span class="line"> t1.join();</span><br><span class="line"> <span class="comment">// 等待线程 2 执行完成</span></span><br><span class="line"> t2.join();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 打印 count 变量</span></span><br><span class="line"> System.out.println(count.get());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如预期</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread t2 count 加 10000 结束</span><br><span class="line">thread t1 count 加 10000 结束</span><br><span class="line">20000</span><br></pre></td></tr></table></figure><h1 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h1><ul><li>java.lang.ThreadLocal 类用于线程本地化存储。</li><li>线程本地化存储，就是为每一个线程创建一个变量，只有本线程可以在该变量中查看和修改值。</li><li>典型的使用例子就是，spring 在处理数据库事务问题的时候，就用了 ThreadLocal 为每个线程存储了各自的数据库连接 Connection。</li><li>使用 ThreadLocal 要注意，在不使用该变量的时候，一定要调用 remove() 方法移除变量，否则可能造成内存泄漏的问题。</li></ul><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">package</span> constxiong.concurrency.a026;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 原子类 AtomicInteger</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadLocal</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 线程本地存储变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; THREAD_LOCAL_NUM = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;<span class="comment">//初始值</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">3</span>; i++) &#123;<span class="comment">// 启动三个线程</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> add10ByThreadLocal();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> t.start();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程本地存储变量加 5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add10ByThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line"> <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> THREAD_LOCAL_NUM.get();</span><br><span class="line"> n += <span class="number">1</span>;</span><br><span class="line"> THREAD_LOCAL_NUM.set(n);</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : ThreadLocal num=&quot;</span> + n);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> THREAD_LOCAL_NUM.remove();<span class="comment">// 将变量移除</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程最后一个值都打印到了 5</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="title class_">Thread</span>-<span class="number">0</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">1</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">2</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">1</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">1</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">1</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">2</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">2</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">0</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">2</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">2</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">3</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">0</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">3</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">1</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">2</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">0</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">4</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">2</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">4</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">0</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">5</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">1</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">3</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">2</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">5</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">1</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">4</span></span><br><span class="line"><span class="title class_">Thread</span>-<span class="number">1</span> : <span class="title class_">ThreadLocal</span> num=<span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="copy-on-write"><a href="#copy-on-write" class="headerlink" title="copy-on-write"></a>copy-on-write</h1><ul><li>根据英文名称可以看出，需要写时复制，体现的是一种延时策略。</li><li>Java 中的 copy-on-write 容器包括：CopyOnWriteArrayList、CopyOnWriteArraySet。</li><li>涉及到数组的全量复制，所以也比较耗内存，在写少的情况下使用比较适合。</li></ul><p>简单的 CopyOnWriteArrayList 的示例，<strong>这里只是说明 CopyOnWriteArrayList 怎么用，并且是线程安全的。这个场景并不适合使用 CopyOnWriteArrayList，因为写多读少</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">package</span> constxiong.concurrency.a026;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 copy-on-write</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ConstXiong</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCopyOnWrite</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">R</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;Integer&gt; cowList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// private static ArrayList&lt;Integer&gt; cowList = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> List&lt;Thread&gt; threadList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line"> <span class="comment">//启动 1000 个线程，向 cowList 添加 5 个随机整数</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">5</span>; j++) &#123;</span><br><span class="line"> <span class="comment">//休眠 10 毫秒，让线程同时向 cowList 添加整数，引出并发问题</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">10</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> cowList.add(R.nextInt(<span class="number">100</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;) ;</span><br><span class="line"> t.start();</span><br><span class="line"> threadList.add(t);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (Thread t : threadList) &#123;</span><br><span class="line"> t.join();</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(cowList.size());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码<span class="number">5000</span></span><br></pre></td></tr></table></figure><p>如果把</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;Integer&gt; cowList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码<span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; cowList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>打印结果就是小于 5000 的整数了</p><p><strong>注意：高并发情况下CopyOnWrite获取到的可能不是最新的值</strong>，具体可以参考下另外一篇文章<a href="CopyOnWriteArrayList%E7%9A%84%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%8F%96%E5%88%B0%E6%95%B0%E6%8D%AE%E6%98%AF%E6%9C%80%E6%96%B0%E7%9A%84%EF%BC%9F.md">《CopyOnWriteArrayList的机制如何保证读取到数据是最新的？》</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 银行类 </tag>
            
            <tag> 金融类 </tag>
            
            <tag> 券商类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客中插入图片失败--解决思路及个人最终解决办法</title>
      <link href="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>今天晚上花了大概2个小时在晚上搜寻各种hexo博客插入图片无法显示的解决办法，很多方法是重叠的，所以真正不同的解决方法并不多。</p><p>昨天晚上和今天晚上一共花了2个小时在网上找各种hexo博客插入图片无法显示的解决办法，很多方法是重叠的，且有的方法已经因为hexo版本升级而不可用，所以真正不同的解决方法并不多。其中很多博文的内容几乎一摸一样，没有实际的用处，且不考虑时间效应，直接复制粘贴，很浪费阅读者的时间。</p><p>本文的问题解决时间为2023-05-21，hexo版本为6.3.0。本回答受该博客启发较大，感谢各位先驱大佬的贡献。</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="创建图片资源文件夹"><a href="#创建图片资源文件夹" class="headerlink" title="创建图片资源文件夹"></a>创建图片资源文件夹</h3><p>网上有关的解决方式几乎很大一部分会提到这一点：<strong>将_config.yml 文件中的post_asset_folder 选项设为 true 来打开</strong>。事实上这正是hexo官方文档给出的解决方案之一中的一个步骤。仔细阅读后会发现如下几点：</p><p>该操作的作用就是在使用hexo new xxx指令新建博文时，在相同路径下同步创建一个xxx文件夹，而xxx文件夹的作用就是用来存放图片资源；那么直接新建xxx.md再新建xxx文件夹，这种操作的最终效果和使用hexo new xxx指令新建博文的效果一样吗？经过实测，是一样的。基于以上，直接总结一下：</p><p>新建博文可以不用hexo new xxx指令，我较为推荐直接新建文件和文件夹的方式，只要达到一个md文件，一个同名文件夹的效果即可；<strong>【将_config.yml 文件中的post_asset_folder 选项设为 true 】</strong>是必须的！理论上既然没用hexo new xxx指令，文件夹也是我自己新建的，这一步设置的意义似乎并不存在，但是后文介绍的插件必须在post_asset_folder 选项设为 true的情况下才能生效——本人亲测，大家记住这么设置即可！</p><h3 id="typora中图像设置"><a href="#typora中图像设置" class="headerlink" title="typora中图像设置"></a>typora中图像设置</h3><p>一般来说，大家会现在typora里写好md格式的博客，然后通过hexo clean、hexo g、hexo s进行一下本地测试，确认无误后再发布到远端。</p><p>暂且不说hexo博客的图片插入是个问题，我相信当初单纯利用typora做笔记时，图片文件的管理就让很多人头疼过，typora官方似乎也意识到这个问题，所以偏好设置中图像是专门的一项，提供了很多选择。</p><p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/20200707222506636.png" alt="typora插图"></p><p>我相信大多数同学写md时的图片很多可能是直接截图或者在其他地方copy的，然后在typora中直接粘贴就ok了。但是这么做之前最好把typora插入图片时采取何种操作配置好，否则md文件和图片相隔十万八千里，后续一旦移动md文件图片就识别不出来，相信大家用过typora都深有体会。</p><p>所以接下来讲一下typora如何设置。直接给结论：</p><p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/20200707224416296.png" alt="在这里插入图片描述">框里的路径是：.&#x2F;${filename}。.&#x2F;表示当前文件夹，${filename}表示当前文件名。这么设置的好处：</p><ul><li>图片资源文件夹有了；</li><li>而且是同名文件夹！（上面提到的需要创建的文件夹其实不用手动添加了）</li><li>这么设置的结果就是：想写篇博客，在source_posts文件夹下新建xxx.md文件，写着写着需要插一张图，从别处复制，然后在typora中直接粘贴，图片资源文件夹自动搞定，并不用关心什么文件夹，只管专注于md文件即可。</li></ul><h3 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h3><p>这个很多博客也有提到，插件的名字叫hexo-asset-image，相信在网上找了一波解决方案的同学一定对这个名字不陌生。</p><p>这个插件的不同版本可能会有不同的影响，我最终成功解决问题的版本是用如下命令下载的：</p><p><code>npm install hexo-asset-img --save</code></p><p>注意一定不要使用下面的这个，因为hexo版本已经变了，带入了日期参数，使用下面的这个会导致问题，具体原因分析如下。</p><p><code>npm install hexo-asset-image --save</code> <strong>不要用！！！</strong></p><p>为什么需要这么插件呢？</p><p>因为我们虽然在source_posts文件夹下写了md文件，也有了图片资源文件夹存了图片，但从我们前面typora中的设置不难知道，实际上md文件中的图片路径都是相对路径（.&#x2F;${filename}）。而实际网上看到的博文显然不是md文件，而是html文件，从md到html的转变就是hexo帮我们做的，还记得hexo g命令吗？就是干这个的。转换后的html文件在public目录下，路径是通过日期指示的。</p><p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/image-20230521010750761.png" alt="image-20230521010759555"></p><p>上图为md文件保存地址和对应图片的保存地址，下图为hexo g 之后生成的public地址</p><p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/image-20230521010918633.png" alt="image-20230521010918633"></p><p>大家如果了解过html的话，应该知道里面的图片应该是指定绝对路径的，大家可以打开上面第二张图的index.html，找到插入图片的地方，查看是否是可用的绝对路径，我的如下图。大家如果问题还没解决的话应该不是像我一样的日期+文件夹指明的绝对路径。<br>说到这儿，大家应该知道，理论上需要将md中图片的相对路径转换成html中的绝对路径，这样图片才能正常显示。因为我们图片资源也有了，显示不出来只能是路径不对（为验证，大家图片显示不对的话，打开index.html，插图片地方的路径肯定是一串不明所以的字母数字）。</p><p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/image-20230521011026522.png" alt="image-20230521011026522"></p><p>路径转换就是该节最开始提到的插件的作用：根据md图片的相对路径，给出html中图片的绝对路径。如果使用的插件是image的话，会生成错误的地址路径，日期和目录名重复，有兴趣的朋友可以试一下，这也是排错的一个思路。</p><p>路径：md文件名&#x2F;图片名，图片资源文件夹：自动生成且同名。这时如果用hexo clean、hexo g生成html文件，用Notepad++或其他工具打开index.html（路径见下方第一张图），找到插图片的地方，查看图片路径：发现图片路径似乎多了一串日期加目录信息，如果用hexo s在本地查看网页，会发现图片不显示，使用F12查看源码会发现图片位置提示404：</p><p><strong>既然是路径问题，那么是不是插件有问题？或者我们使用方法错了？</strong></p><p>找到插件安装位置（插件都在node_modules文件夹下），打开readme文件<br>readme如下：</p><p><img src="/2023/05/21/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/image-20230521011811207.png" alt="image-20230521011811207">瞬间发现别人的说明书讲得明明白白，言简意赅！我们的转化后路径不对正是因为我们md文件中图片的路径不对，图片名前面不能有其他东西！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>找解决方案，断断续续找了2个多小时，写这篇博客又写了1个小时。感觉应该把整个过程讲得还算比较清楚了。</p><p>但是这种问题向来因人而异，同样的解决方法可能可以解决我的问题，但对另一个人无效。还是要多查找资料，多尝试，多思考。重要的是要<strong>锻炼自己定位问题的能力</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo+Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Next主题搭建个人博客+优化全过程（完整详细版）</title>
      <link href="/2023/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>​使用Hexo + Next 搭建个人博客的原因是作为一名后端开发，我需要一个比较私人的地方来记录个人成长和总结工作、学习中遇到的各种知识点，并进行系统的梳理，加强个人的理解深度。需求本身并不复杂，我也不喜欢花里胡哨的页面，且Hexo + Next主题很成熟，遇到问题也能直接上网查询大佬的解决方案。</p><hr><p>[TOC]</p><h2 id="前置内容"><a href="#前置内容" class="headerlink" title="前置内容"></a>前置内容</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ol><li>hexo是什么，next又是什么</li></ol><p>   ​Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。next是Hexo中常用的一个主题，用来扩展Hexo的功能和展示效果。</p>   <img src="/2023/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/v2-a193a47cf70fe6ecf156e5f3d34920ea_b.jpg" class title="img"><h3 id="优点和不足"><a href="#优点和不足" class="headerlink" title="优点和不足"></a>优点和不足</h3><p>   <strong>优点：</strong>完全免费；静态站点，轻量快速；可按需求自由定制改造；托管在 GitHub，安全省心；迁移方便……</p><p>   <strong>不足：</strong>发文不便，依赖于本地环境；更适合个人博客使用；GitHub 在国内访问速度有点不快。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>   <strong>git 的下载</strong>： 官网下载较慢，这边推荐阿里镜像下载：</p><ol><li><p>git本身是分布式版本管理工具，对于个人用户而言远优于svn。详细的git和svn的具体介绍，请参考<a href="https://zhuanlan.zhihu.com/p/48148269">GIT比对SVN</a>。</p></li><li><p><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">git的下载地址</a>。</p></li><li><p>选择适合自己操作系统的最新版本，下载好后安装过程一直选择默认即可。</p></li></ol><p>  <strong>Nodejs下载</strong></p><pre><code>      1. 直接搜索 Nodejs或点击[Nodejs下载](https://link.zhihu.com/?target=https%3A//nodejs.org/en/)，选择最新的版本进行下载</code></pre><hr><h2 id="hexo创建个人博客"><a href="#hexo创建个人博客" class="headerlink" title="hexo创建个人博客"></a>hexo创建个人博客</h2><h3 id="连接-Github"><a href="#连接-Github" class="headerlink" title="连接 Github"></a>连接 Github</h3><p>   使用邮箱注册 <a href="https://link.zhihu.com/?target=https://github.com/">GitHub</a> 账户，选择免费账户（Free），并完成邮件验证。</p><p>   右键 -&gt; Git Bash Here，<strong>设置用户名和邮箱</strong>：</p>   <figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub 用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure><p>   <strong>创建 SSH 密匙</strong>：</p><p>   输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。</p><p>   <strong>添加密匙：</strong></p><p>   进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p><p>   登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p><p>   Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p><p>​    <img src="/2023/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/v2-9125065afd24332d7cd84feb6a350730_720w.jpg" class title="img"></p><p>   <strong>验证连接：</strong></p><p>   打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。</p><img src="/2023/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/v2-b4c7524a2451f4ab42f9c22ea3c7b6be_720w.jpg" class title="img"><p>   显示 “Hi xxx! You’ve successfully……” 即连接成功。</p><h3 id="创建-Github-Pages-仓库"><a href="#创建-Github-Pages-仓库" class="headerlink" title="创建 Github Pages 仓库"></a>创建 Github Pages 仓库</h3><p>   GitHub 主页右上角加号 -&gt; New repository：</p><ul><li>Repository name 中输入 <code>用户名.github.io</code></li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>   填好后点击 Create repository 创建。</p><p>​    <img src="/2023/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/v2-67a8165154f4c5f4a6333e76e78ed815_720w.jpg" class title="img"></p><p>  创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p><h3 id="本地安装-Hexo-博客程序"><a href="#本地安装-Hexo-博客程序" class="headerlink" title="本地安装 Hexo 博客程序"></a>本地安装 Hexo 博客程序</h3><p>在创建的本地博客目录中依次执行以下程序</p>   <figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli # 安装对应的hexo客户端</span><br><span class="line">hexo init blog          # 初始化</span><br><span class="line">npm install             # 安装组件</span><br><span class="line">hexo g                  # genarete的简写，生成页面预览</span><br><span class="line">hexo s                  # server的简写，启动服务,可以使用-p <span class="number">8080</span> 指定对应端口</span><br></pre></td></tr></table></figure><p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p><img src="/2023/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/v2-1c3baeecf1ef3bec5c8ef3f14639f68b_b.jpg" class title="img"><p><strong>Tips：</strong>如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo server -p 5000</code> 更改端口号后重试。</p><p>Hexo 博客文件夹目录结构如下：</p><h3 id="部署-Hexo-到-GitHub-Pages"><a href="#部署-Hexo-到-GitHub-Pages" class="headerlink" title="部署 Hexo 到 GitHub Pages"></a>部署 Hexo 到 GitHub Pages</h3><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>首先<strong>安装 hexo-deployer-git</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后<strong>修改 _config.yml</strong> 文件末尾的 Deployment 部分，修改成如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><h3 id="绑定域名（可选）"><a href="#绑定域名（可选）" class="headerlink" title="绑定域名（可选）"></a>绑定域名（可选）</h3><p>博客搭建完成使用的是 GitHub 的子域名（用户名.<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a>），我们可以为 Hexo 博客绑定自己的域名替换 GitHub 域名，更加个性化和专业，也利于 SEO。</p><p>我们使用 <a href="https://link.zhihu.com/?target=https://www.namesilo.com/?rid=d27fa32do">Namesilo</a> 进行注册，便宜好用没啥套路，使用优惠码 <code>okoff</code> 优惠一美元，com 域名大概 50 块一年。</p><ul><li>域名注册和解析教程：<a href="https://zhuanlan.zhihu.com/p/33921436">Namesilo 域名购买及使用教程</a></li></ul><p>按上面教程注册并解析域名，在 DNS 设置部分，删除自带的记录，然后添加 CNAME 记录将 www 域名解析指向 <code>用户名.github.io</code>。</p><img src="/2023/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/v2-d5d37c8ad523d8ab5c7c200fabc9585e_720w.jpg" class title="img"><p>绑定域名到 Hexo 博客</p><p>进入本地博客文件夹的 source 目录，打开记事本，里面输入自己的域名，如 <a href="http://www.example.com,保存名称为/">http://www.example.com，保存名称为</a> “CNAME”，格式为 “所有文件”（无 .txt 后缀）。</p><p>清除缓存等文件并重新发布网站：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   # 清除缓存文件等</span><br><span class="line">hexo g       # 生成页面</span><br><span class="line">hexo s       # 启动预览12</span><br></pre></td></tr></table></figure><p>现在就可以使用自己的域名访问 Hexo 博客了。</p><h3 id="开启-HTTPS"><a href="#开启-HTTPS" class="headerlink" title="开启 HTTPS"></a>开启 HTTPS</h3><p>配置自己的域名后，需要我们手动开启 HTTPS。打开博客所在 GitHub 仓库，Settings -&gt; 下拉找到 GitHub Pages -&gt; 勾选 Enforce HTTPS。</p><img src="/2023/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/v2-54f8744afc9746884e6b3acecfc5f8cf_720w.jpg" class title="img"><p>HTTPS 证书部署成功需要一定时间，等大概几分钟再访问域名，就可以看到域名前面的小绿锁了，HTTPS 配置完成！</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p><p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。<strong>以后每次发布文章都是这两条命令。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo d   # 部署发布1</span><br></pre></td></tr></table></figure><hr><p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo g</code> 和 <code>hexo d</code> 发布。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">- Diary</span><br><span class="line">tags: # 标签</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">---</span><br><span class="line">123456789</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="网站设置"><a href="#网站设置" class="headerlink" title="网站设置"></a>网站设置</h3><p>包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a>按需要编辑。</p><p>注意：冒号后要加一个空格！</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>在 <a href="https://link.zhihu.com/?target=https://hexo.io/themes/">Themes | Hexo</a> 选择一个喜欢的主题，比如 <a href="https://link.zhihu.com/?target=http://theme-next.iissnan.com/getting-started.html">NexT</a>，进入网站目录打开 Git Bash Here 下载主题：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后修改 _config.yml 中的 theme 为新主题名称 next，发布。（有的主题需要将 _config.yml 替换为主题自带的，参考主题说明。）</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo new “name”       # 新建文章</span><br><span class="line">hexo new page “name”  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助1234567</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>1、Hexo 设置显示文章摘要，首页不显示全文</strong></p><p>Hexo 主页文章列表默认会显示文章全文，浏览时很不方便，可以在文章中插入 <code>&lt;!–more–&gt;</code> 进行分段。</p><p>该代码前面的内容会作为摘要显示，而后面的内容会替换为 “Read More” 隐藏起来。</p><img src="/2023/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/05/19/Hexo-Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/v2-45701cf120ca77e6733ad30b40666f33_b.jpg" class title="img"> <p><strong>2、设置网站图标</strong></p><p>进入 themes&#x2F;主题 文件夹，打开 _config.yml 配置文件，找到 favicon 修改，一般格式为：<code>favicon: 图标地址</code>。（不同主题可能略有差别）</p><p><strong>3、修改并部署后没有效果</strong></p><p>使用 <code>hexo clean</code> 清理后重新部署。</p><p><strong>4、开启 HTTPS 后访问网站显示连接不安全？</strong></p><p>证书还未部署生效，等待一会儿，清除浏览器缓存再试。</p><p><strong>5、Mac 安装 Hexo 报错无法安装</strong></p><p>Mac 用户需要管理员权限运行，使用 <code>sudo npm install -g hexo-cli</code> 命令安装。</p><p><strong>6、npm 下载速度慢，甚至完全没反应</strong></p><p>使用 npm 安装程序等待很久也没反应，或者下载速度很慢，可以更换 npm 源为国内 npm 镜像。</p><p>临时更换方法：在 npm 安装命令后面加上：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">–registry https://registry.npm.taobao.org </span><br></pre></td></tr></table></figure><p><strong>7、hexo版本升级后，typora正常显示，但是hexo上无法显示的问题</strong></p><p>这个问题非常棘手，在这里卡了3，4个小时，中间各种查找原因+找对应的插件，终于解决了，详细解决过程请参考下一篇文章</p><p>《hexo博客中插入图片失败——解决思路及个人最终解决办法》</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Hexo 是一种纯静态的博客，我们必须要在本地完成文章的编辑再部署到 GitHub 上，依赖于本地环境。不能像 WordPress 或 Typecho 那样的动态博客一样能直接在浏览器中完成撰文和发布。</p><p>可以说是一种比较极客的写博客方式，但是优势也是明显的——免费稳定省心，比较适合爱折腾研究的用户，或者没有在线发文需求的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo+Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/18/hello-world/"/>
      <url>/2023/05/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
